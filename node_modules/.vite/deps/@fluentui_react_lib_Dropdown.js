import {
  require_react_dom
} from "./chunk-5KAMKWUC.js";
import {
  __toESM,
  require_react
} from "./chunk-5TBDGQCY.js";

// node_modules/@fluentui/set-version/lib/setVersion.js
var packagesCache = {};
var _win = void 0;
try {
  _win = window;
} catch (e) {
}
function setVersion(packageName, packageVersion) {
  if (typeof _win !== "undefined") {
    var packages = _win.__packages__ = _win.__packages__ || {};
    if (!packages[packageName] || !packagesCache[packageName]) {
      packagesCache[packageName] = packageVersion;
      var versions = packages[packageName] = packages[packageName] || [];
      versions.push(packageVersion);
    }
  }
}

// node_modules/@fluentui/set-version/lib/index.js
setVersion("@fluentui/set-version", "6.0.0");

// node_modules/@fluentui/react/lib/version.js
setVersion("@fluentui/react", "8.115.6");

// node_modules/@fluentui/utilities/lib/dom/canUseDOM.js
function canUseDOM() {
  return (
    // eslint-disable-next-line no-restricted-globals
    typeof window !== "undefined" && !!// eslint-disable-next-line no-restricted-globals, deprecation/deprecation
    (window.document && window.document.createElement)
  );
}

// node_modules/@fluentui/utilities/lib/dom/getWindow.js
var _window = void 0;
try {
  _window = window;
} catch (e) {
}
function getWindow(rootElement) {
  if (!canUseDOM() || typeof _window === "undefined") {
    return void 0;
  } else {
    var el = rootElement;
    return el && el.ownerDocument && el.ownerDocument.defaultView ? el.ownerDocument.defaultView : _window;
  }
}

// node_modules/@fluentui/utilities/lib/Async.js
var Async = (
  /** @class */
  function() {
    function Async2(parent, onError) {
      this._timeoutIds = null;
      this._immediateIds = null;
      this._intervalIds = null;
      this._animationFrameIds = null;
      this._isDisposed = false;
      this._parent = parent || null;
      this._onErrorHandler = onError;
      this._noop = function() {
      };
    }
    Async2.prototype.dispose = function() {
      var id;
      this._isDisposed = true;
      this._parent = null;
      if (this._timeoutIds) {
        for (id in this._timeoutIds) {
          if (this._timeoutIds.hasOwnProperty(id)) {
            this.clearTimeout(parseInt(id, 10));
          }
        }
        this._timeoutIds = null;
      }
      if (this._immediateIds) {
        for (id in this._immediateIds) {
          if (this._immediateIds.hasOwnProperty(id)) {
            this.clearImmediate(parseInt(id, 10));
          }
        }
        this._immediateIds = null;
      }
      if (this._intervalIds) {
        for (id in this._intervalIds) {
          if (this._intervalIds.hasOwnProperty(id)) {
            this.clearInterval(parseInt(id, 10));
          }
        }
        this._intervalIds = null;
      }
      if (this._animationFrameIds) {
        for (id in this._animationFrameIds) {
          if (this._animationFrameIds.hasOwnProperty(id)) {
            this.cancelAnimationFrame(parseInt(id, 10));
          }
        }
        this._animationFrameIds = null;
      }
    };
    Async2.prototype.setTimeout = function(callback, duration) {
      var _this = this;
      var timeoutId = 0;
      if (!this._isDisposed) {
        if (!this._timeoutIds) {
          this._timeoutIds = {};
        }
        timeoutId = setTimeout(function() {
          try {
            if (_this._timeoutIds) {
              delete _this._timeoutIds[timeoutId];
            }
            callback.apply(_this._parent);
          } catch (e) {
            _this._logError(e);
          }
        }, duration);
        this._timeoutIds[timeoutId] = true;
      }
      return timeoutId;
    };
    Async2.prototype.clearTimeout = function(id) {
      if (this._timeoutIds && this._timeoutIds[id]) {
        clearTimeout(id);
        delete this._timeoutIds[id];
      }
    };
    Async2.prototype.setImmediate = function(callback, targetElement) {
      var _this = this;
      var immediateId = 0;
      var win = getWindow(targetElement);
      if (!this._isDisposed) {
        if (!this._immediateIds) {
          this._immediateIds = {};
        }
        var setImmediateCallback = function() {
          try {
            if (_this._immediateIds) {
              delete _this._immediateIds[immediateId];
            }
            callback.apply(_this._parent);
          } catch (e) {
            _this._logError(e);
          }
        };
        immediateId = win.setTimeout(setImmediateCallback, 0);
        this._immediateIds[immediateId] = true;
      }
      return immediateId;
    };
    Async2.prototype.clearImmediate = function(id, targetElement) {
      var win = getWindow(targetElement);
      if (this._immediateIds && this._immediateIds[id]) {
        win.clearTimeout(id);
        delete this._immediateIds[id];
      }
    };
    Async2.prototype.setInterval = function(callback, duration) {
      var _this = this;
      var intervalId = 0;
      if (!this._isDisposed) {
        if (!this._intervalIds) {
          this._intervalIds = {};
        }
        intervalId = setInterval(function() {
          try {
            callback.apply(_this._parent);
          } catch (e) {
            _this._logError(e);
          }
        }, duration);
        this._intervalIds[intervalId] = true;
      }
      return intervalId;
    };
    Async2.prototype.clearInterval = function(id) {
      if (this._intervalIds && this._intervalIds[id]) {
        clearInterval(id);
        delete this._intervalIds[id];
      }
    };
    Async2.prototype.throttle = function(func, wait, options) {
      var _this = this;
      if (this._isDisposed) {
        return this._noop;
      }
      var waitMS = wait || 0;
      var leading = true;
      var trailing = true;
      var lastExecuteTime = 0;
      var lastResult;
      var lastArgs;
      var timeoutId = null;
      if (options && typeof options.leading === "boolean") {
        leading = options.leading;
      }
      if (options && typeof options.trailing === "boolean") {
        trailing = options.trailing;
      }
      var callback = function(userCall) {
        var now2 = Date.now();
        var delta = now2 - lastExecuteTime;
        var waitLength = leading ? waitMS - delta : waitMS;
        if (delta >= waitMS && (!userCall || leading)) {
          lastExecuteTime = now2;
          if (timeoutId) {
            _this.clearTimeout(timeoutId);
            timeoutId = null;
          }
          lastResult = func.apply(_this._parent, lastArgs);
        } else if (timeoutId === null && trailing) {
          timeoutId = _this.setTimeout(callback, waitLength);
        }
        return lastResult;
      };
      var resultFunction = function() {
        var args = [];
        for (var _i = 0; _i < arguments.length; _i++) {
          args[_i] = arguments[_i];
        }
        lastArgs = args;
        return callback(true);
      };
      return resultFunction;
    };
    Async2.prototype.debounce = function(func, wait, options) {
      var _this = this;
      if (this._isDisposed) {
        var noOpFunction = function() {
        };
        noOpFunction.cancel = function() {
          return;
        };
        noOpFunction.flush = function() {
          return null;
        };
        noOpFunction.pending = function() {
          return false;
        };
        return noOpFunction;
      }
      var waitMS = wait || 0;
      var leading = false;
      var trailing = true;
      var maxWait = null;
      var lastCallTime = 0;
      var lastExecuteTime = Date.now();
      var lastResult;
      var lastArgs;
      var timeoutId = null;
      if (options && typeof options.leading === "boolean") {
        leading = options.leading;
      }
      if (options && typeof options.trailing === "boolean") {
        trailing = options.trailing;
      }
      if (options && typeof options.maxWait === "number" && !isNaN(options.maxWait)) {
        maxWait = options.maxWait;
      }
      var markExecuted = function(time) {
        if (timeoutId) {
          _this.clearTimeout(timeoutId);
          timeoutId = null;
        }
        lastExecuteTime = time;
      };
      var invokeFunction = function(time) {
        markExecuted(time);
        lastResult = func.apply(_this._parent, lastArgs);
      };
      var callback = function(userCall) {
        var now2 = Date.now();
        var executeImmediately = false;
        if (userCall) {
          if (leading && now2 - lastCallTime >= waitMS) {
            executeImmediately = true;
          }
          lastCallTime = now2;
        }
        var delta = now2 - lastCallTime;
        var waitLength = waitMS - delta;
        var maxWaitDelta = now2 - lastExecuteTime;
        var maxWaitExpired = false;
        if (maxWait !== null) {
          if (maxWaitDelta >= maxWait && timeoutId) {
            maxWaitExpired = true;
          } else {
            waitLength = Math.min(waitLength, maxWait - maxWaitDelta);
          }
        }
        if (delta >= waitMS || maxWaitExpired || executeImmediately) {
          invokeFunction(now2);
        } else if ((timeoutId === null || !userCall) && trailing) {
          timeoutId = _this.setTimeout(callback, waitLength);
        }
        return lastResult;
      };
      var pending = function() {
        return !!timeoutId;
      };
      var cancel = function() {
        if (pending()) {
          markExecuted(Date.now());
        }
      };
      var flush = function() {
        if (pending()) {
          invokeFunction(Date.now());
        }
        return lastResult;
      };
      var resultFunction = function() {
        var args = [];
        for (var _i = 0; _i < arguments.length; _i++) {
          args[_i] = arguments[_i];
        }
        lastArgs = args;
        return callback(true);
      };
      resultFunction.cancel = cancel;
      resultFunction.flush = flush;
      resultFunction.pending = pending;
      return resultFunction;
    };
    Async2.prototype.requestAnimationFrame = function(callback, targetElement) {
      var _this = this;
      var animationFrameId = 0;
      var win = getWindow(targetElement);
      if (!this._isDisposed) {
        if (!this._animationFrameIds) {
          this._animationFrameIds = {};
        }
        var animationFrameCallback = function() {
          try {
            if (_this._animationFrameIds) {
              delete _this._animationFrameIds[animationFrameId];
            }
            callback.apply(_this._parent);
          } catch (e) {
            _this._logError(e);
          }
        };
        animationFrameId = win.requestAnimationFrame ? win.requestAnimationFrame(animationFrameCallback) : win.setTimeout(animationFrameCallback, 0);
        this._animationFrameIds[animationFrameId] = true;
      }
      return animationFrameId;
    };
    Async2.prototype.cancelAnimationFrame = function(id, targetElement) {
      var win = getWindow(targetElement);
      if (this._animationFrameIds && this._animationFrameIds[id]) {
        win.cancelAnimationFrame ? win.cancelAnimationFrame(id) : win.clearTimeout(id);
        delete this._animationFrameIds[id];
      }
    };
    Async2.prototype._logError = function(e) {
      if (this._onErrorHandler) {
        this._onErrorHandler(e);
      }
    };
    return Async2;
  }()
);

// node_modules/@fluentui/dom-utilities/lib/isVirtualElement.js
function isVirtualElement(element) {
  return element && !!element._virtual;
}

// node_modules/@fluentui/dom-utilities/lib/getVirtualParent.js
function getVirtualParent(child) {
  var parent;
  if (child && isVirtualElement(child)) {
    parent = child._virtual.parent;
  }
  return parent;
}

// node_modules/@fluentui/dom-utilities/lib/getParent.js
function getParent(child, allowVirtualParents) {
  if (allowVirtualParents === void 0) {
    allowVirtualParents = true;
  }
  return child && (allowVirtualParents && getVirtualParent(child) || child.parentNode && child.parentNode);
}

// node_modules/@fluentui/dom-utilities/lib/elementContains.js
function elementContains(parent, child, allowVirtualParents) {
  if (allowVirtualParents === void 0) {
    allowVirtualParents = true;
  }
  var isContained = false;
  if (parent && child) {
    if (allowVirtualParents) {
      if (parent === child) {
        isContained = true;
      } else {
        isContained = false;
        while (child) {
          var nextParent = getParent(child);
          if (nextParent === parent) {
            isContained = true;
            break;
          }
          child = nextParent;
        }
      }
    } else if (parent.contains) {
      isContained = parent.contains(child);
    }
  }
  return isContained;
}

// node_modules/@fluentui/dom-utilities/lib/findElementRecursive.js
function findElementRecursive(element, matchFunction, doc) {
  doc !== null && doc !== void 0 ? doc : doc = document;
  if (!element || element === doc.body) {
    return null;
  }
  return matchFunction(element) ? element : findElementRecursive(getParent(element), matchFunction);
}

// node_modules/@fluentui/dom-utilities/lib/elementContainsAttribute.js
function elementContainsAttribute(element, attribute, doc) {
  var elementMatch = findElementRecursive(element, function(testElement) {
    return testElement.hasAttribute(attribute);
  }, doc);
  return elementMatch && elementMatch.getAttribute(attribute);
}

// node_modules/@fluentui/dom-utilities/lib/setPortalAttribute.js
var DATA_PORTAL_ATTRIBUTE = "data-portal-element";
function setPortalAttribute(element) {
  element.setAttribute(DATA_PORTAL_ATTRIBUTE, "true");
}

// node_modules/@fluentui/dom-utilities/lib/portalContainsElement.js
function portalContainsElement(target, parent, doc) {
  var elementMatch = findElementRecursive(target, function(testElement) {
    return parent === testElement || testElement.hasAttribute(DATA_PORTAL_ATTRIBUTE);
  }, doc);
  return elementMatch !== null && elementMatch.hasAttribute(DATA_PORTAL_ATTRIBUTE);
}

// node_modules/@fluentui/dom-utilities/lib/setVirtualParent.js
function setVirtualParent(child, parent) {
  var virtualChild = child;
  var virtualParent = parent;
  if (!virtualChild._virtual) {
    virtualChild._virtual = {
      children: []
    };
  }
  var oldParent = virtualChild._virtual.parent;
  if (oldParent && oldParent !== parent) {
    var index = oldParent._virtual.children.indexOf(virtualChild);
    if (index > -1) {
      oldParent._virtual.children.splice(index, 1);
    }
  }
  virtualChild._virtual.parent = virtualParent || void 0;
  if (virtualParent) {
    if (!virtualParent._virtual) {
      virtualParent._virtual = {
        children: []
      };
    }
    virtualParent._virtual.children.push(virtualChild);
  }
}

// node_modules/@fluentui/dom-utilities/lib/version.js
setVersion("@fluentui/dom-utilities", "2.2.14");

// node_modules/@fluentui/utilities/lib/dom/getDocument.js
function getDocument(rootElement) {
  if (!canUseDOM() || typeof document === "undefined") {
    return void 0;
  } else {
    var el = rootElement;
    return el && el.ownerDocument ? el.ownerDocument : document;
  }
}

// node_modules/@fluentui/utilities/lib/focus.js
var IS_FOCUSABLE_ATTRIBUTE = "data-is-focusable";
var IS_VISIBLE_ATTRIBUTE = "data-is-visible";
var FOCUSZONE_ID_ATTRIBUTE = "data-focuszone-id";
var FOCUSZONE_SUB_ATTRIBUTE = "data-is-sub-focuszone";
function getFirstFocusable(rootElement, currentElement, includeElementsInFocusZones) {
  return getNextElement(rootElement, currentElement, true, false, false, includeElementsInFocusZones);
}
function getLastFocusable(rootElement, currentElement, includeElementsInFocusZones) {
  return getPreviousElement(rootElement, currentElement, true, false, true, includeElementsInFocusZones);
}
function getFirstTabbable(rootElement, currentElement, includeElementsInFocusZones, checkNode) {
  if (checkNode === void 0) {
    checkNode = true;
  }
  return getNextElement(
    rootElement,
    currentElement,
    checkNode,
    false,
    false,
    includeElementsInFocusZones,
    false,
    true
    /*tabbable*/
  );
}
function getLastTabbable(rootElement, currentElement, includeElementsInFocusZones, checkNode) {
  if (checkNode === void 0) {
    checkNode = true;
  }
  return getPreviousElement(
    rootElement,
    currentElement,
    checkNode,
    false,
    true,
    includeElementsInFocusZones,
    false,
    true
    /*tabbable*/
  );
}
function focusFirstChild(rootElement, bypassHiddenElements) {
  var element = getNextElement(rootElement, rootElement, true, false, false, true, void 0, void 0, bypassHiddenElements);
  if (element) {
    focusAsync(element);
    return true;
  }
  return false;
}
function getPreviousElement(rootElement, currentElement, checkNode, suppressParentTraversal, traverseChildren, includeElementsInFocusZones, allowFocusRoot, tabbable) {
  if (!currentElement || !allowFocusRoot && currentElement === rootElement) {
    return null;
  }
  var isCurrentElementVisible = isElementVisible(currentElement);
  if (traverseChildren && isCurrentElementVisible && (includeElementsInFocusZones || !(isElementFocusZone(currentElement) || isElementFocusSubZone(currentElement)))) {
    var childMatch = getPreviousElement(rootElement, currentElement.lastElementChild, true, true, true, includeElementsInFocusZones, allowFocusRoot, tabbable);
    if (childMatch) {
      if (tabbable && isElementTabbable(childMatch, true) || !tabbable) {
        return childMatch;
      }
      var childMatchSiblingMatch = getPreviousElement(rootElement, childMatch.previousElementSibling, true, true, true, includeElementsInFocusZones, allowFocusRoot, tabbable);
      if (childMatchSiblingMatch) {
        return childMatchSiblingMatch;
      }
      var childMatchParent = childMatch.parentElement;
      while (childMatchParent && childMatchParent !== currentElement) {
        var childMatchParentMatch = getPreviousElement(rootElement, childMatchParent.previousElementSibling, true, true, true, includeElementsInFocusZones, allowFocusRoot, tabbable);
        if (childMatchParentMatch) {
          return childMatchParentMatch;
        }
        childMatchParent = childMatchParent.parentElement;
      }
    }
  }
  if (checkNode && isCurrentElementVisible && isElementTabbable(currentElement, tabbable)) {
    return currentElement;
  }
  var siblingMatch = getPreviousElement(rootElement, currentElement.previousElementSibling, true, true, true, includeElementsInFocusZones, allowFocusRoot, tabbable);
  if (siblingMatch) {
    return siblingMatch;
  }
  if (!suppressParentTraversal) {
    return getPreviousElement(rootElement, currentElement.parentElement, true, false, false, includeElementsInFocusZones, allowFocusRoot, tabbable);
  }
  return null;
}
function getNextElement(rootElement, currentElement, checkNode, suppressParentTraversal, suppressChildTraversal, includeElementsInFocusZones, allowFocusRoot, tabbable, bypassHiddenElements) {
  if (!currentElement || currentElement === rootElement && suppressChildTraversal && !allowFocusRoot) {
    return null;
  }
  var checkElementVisibility = bypassHiddenElements ? isElementVisibleAndNotHidden : isElementVisible;
  var isCurrentElementVisible = checkElementVisibility(currentElement);
  if (checkNode && isCurrentElementVisible && isElementTabbable(currentElement, tabbable)) {
    return currentElement;
  }
  if (!suppressChildTraversal && isCurrentElementVisible && (includeElementsInFocusZones || !(isElementFocusZone(currentElement) || isElementFocusSubZone(currentElement)))) {
    var childMatch = getNextElement(rootElement, currentElement.firstElementChild, true, true, false, includeElementsInFocusZones, allowFocusRoot, tabbable, bypassHiddenElements);
    if (childMatch) {
      return childMatch;
    }
  }
  if (currentElement === rootElement) {
    return null;
  }
  var siblingMatch = getNextElement(rootElement, currentElement.nextElementSibling, true, true, false, includeElementsInFocusZones, allowFocusRoot, tabbable, bypassHiddenElements);
  if (siblingMatch) {
    return siblingMatch;
  }
  if (!suppressParentTraversal) {
    return getNextElement(rootElement, currentElement.parentElement, false, false, true, includeElementsInFocusZones, allowFocusRoot, tabbable, bypassHiddenElements);
  }
  return null;
}
function isElementVisible(element) {
  if (!element || !element.getAttribute) {
    return false;
  }
  var visibilityAttribute = element.getAttribute(IS_VISIBLE_ATTRIBUTE);
  if (visibilityAttribute !== null && visibilityAttribute !== void 0) {
    return visibilityAttribute === "true";
  }
  return element.offsetHeight !== 0 || element.offsetParent !== null || // eslint-disable-next-line @typescript-eslint/no-explicit-any
  element.isVisible === true;
}
function isElementVisibleAndNotHidden(element, win) {
  var theWin = win !== null && win !== void 0 ? win : getWindow();
  return !!element && isElementVisible(element) && !element.hidden && theWin.getComputedStyle(element).visibility !== "hidden";
}
function isElementTabbable(element, checkTabIndex) {
  if (!element || element.disabled) {
    return false;
  }
  var tabIndex = 0;
  var tabIndexAttributeValue = null;
  if (element && element.getAttribute) {
    tabIndexAttributeValue = element.getAttribute("tabIndex");
    if (tabIndexAttributeValue) {
      tabIndex = parseInt(tabIndexAttributeValue, 10);
    }
  }
  var isFocusableAttribute = element.getAttribute ? element.getAttribute(IS_FOCUSABLE_ATTRIBUTE) : null;
  var isTabIndexSet = tabIndexAttributeValue !== null && tabIndex >= 0;
  var result = !!element && isFocusableAttribute !== "false" && (element.tagName === "A" || element.tagName === "BUTTON" || element.tagName === "INPUT" || element.tagName === "TEXTAREA" || element.tagName === "SELECT" || isFocusableAttribute === "true" || isTabIndexSet);
  return checkTabIndex ? tabIndex !== -1 && result : result;
}
function isElementFocusZone(element) {
  return !!(element && element.getAttribute && !!element.getAttribute(FOCUSZONE_ID_ATTRIBUTE));
}
function isElementFocusSubZone(element) {
  return !!(element && element.getAttribute && element.getAttribute(FOCUSZONE_SUB_ATTRIBUTE) === "true");
}
function doesElementContainFocus(element) {
  var doc = getDocument(element);
  var currentActiveElement = doc && doc.activeElement;
  if (currentActiveElement && elementContains(element, currentActiveElement)) {
    return true;
  }
  return false;
}
function shouldWrapFocus(element, noWrapDataAttribute, doc) {
  var theDoc = doc !== null && doc !== void 0 ? doc : getDocument();
  return elementContainsAttribute(element, noWrapDataAttribute, theDoc) === "true" ? false : true;
}
var animationId = void 0;
function focusAsync(element) {
  if (element) {
    var win = getWindow(element);
    if (win) {
      if (animationId !== void 0) {
        win.cancelAnimationFrame(animationId);
      }
      animationId = win.requestAnimationFrame(function() {
        element && element.focus();
        animationId = void 0;
      });
    }
  }
}
function getFocusableByIndexPath(parent, path) {
  var element = parent;
  for (var _i = 0, path_1 = path; _i < path_1.length; _i++) {
    var index = path_1[_i];
    var nextChild = element.children[Math.min(index, element.children.length - 1)];
    if (!nextChild) {
      break;
    }
    element = nextChild;
  }
  element = isElementTabbable(element) && isElementVisible(element) ? element : getNextElement(parent, element, true) || getPreviousElement(parent, element);
  return element;
}
function getElementIndexPath(fromElement, toElement) {
  var path = [];
  while (toElement && fromElement && toElement !== fromElement) {
    var parent_1 = getParent(toElement, true);
    if (parent_1 === null) {
      return [];
    }
    path.unshift(Array.prototype.indexOf.call(parent_1.children, toElement));
    toElement = parent_1;
  }
  return path;
}

// node_modules/@fluentui/utilities/lib/dom/getRect.js
function getRect(element, win) {
  var theWin = (win !== null && win !== void 0 ? win : !element || element && element.hasOwnProperty("devicePixelRatio")) ? getWindow() : getWindow(element);
  var rect;
  if (element) {
    if (element === theWin) {
      rect = {
        left: 0,
        top: 0,
        width: theWin.innerWidth,
        height: theWin.innerHeight,
        right: theWin.innerWidth,
        bottom: theWin.innerHeight
      };
    } else if (element.getBoundingClientRect) {
      rect = element.getBoundingClientRect();
    }
  }
  return rect;
}

// node_modules/@fluentui/utilities/lib/dom/on.js
function on(element, eventName, callback, options) {
  element.addEventListener(eventName, callback, options);
  return function() {
    return element.removeEventListener(eventName, callback, options);
  };
}

// node_modules/@fluentui/utilities/lib/object.js
function shallowCompare(a, b) {
  if (!a || !b) {
    return !a && !b;
  }
  for (var propName in a) {
    if (a.hasOwnProperty(propName)) {
      if (!b.hasOwnProperty(propName) || b[propName] !== a[propName]) {
        return false;
      }
    }
  }
  for (var propName in b) {
    if (b.hasOwnProperty(propName)) {
      if (!a.hasOwnProperty(propName)) {
        return false;
      }
    }
  }
  return true;
}
function assign(target) {
  var args = [];
  for (var _i = 1; _i < arguments.length; _i++) {
    args[_i - 1] = arguments[_i];
  }
  return filteredAssign.apply(this, [null, target].concat(args));
}
function filteredAssign(isAllowed, target) {
  var args = [];
  for (var _i = 2; _i < arguments.length; _i++) {
    args[_i - 2] = arguments[_i];
  }
  target = target || {};
  for (var _a7 = 0, args_1 = args; _a7 < args_1.length; _a7++) {
    var sourceObject = args_1[_a7];
    if (sourceObject) {
      for (var propName in sourceObject) {
        if (sourceObject.hasOwnProperty(propName) && (!isAllowed || isAllowed(propName))) {
          target[propName] = sourceObject[propName];
        }
      }
    }
  }
  return target;
}

// node_modules/@fluentui/utilities/lib/EventGroup.js
var EventGroup = (
  /** @class */
  function() {
    function EventGroup2(parent) {
      this._id = EventGroup2._uniqueId++;
      this._parent = parent;
      this._eventRecords = [];
    }
    EventGroup2.raise = function(target, eventName, eventArgs, bubbleEvent, doc) {
      var retVal2;
      var theDoc = doc !== null && doc !== void 0 ? doc : getDocument();
      if (EventGroup2._isElement(target)) {
        if (typeof theDoc !== "undefined" && theDoc.createEvent) {
          var ev = theDoc.createEvent("HTMLEvents");
          ev.initEvent(eventName, bubbleEvent || false, true);
          assign(ev, eventArgs);
          retVal2 = target.dispatchEvent(ev);
        } else if (typeof theDoc !== "undefined" && theDoc.createEventObject) {
          var evObj = theDoc.createEventObject(eventArgs);
          target.fireEvent("on" + eventName, evObj);
        }
      } else {
        while (target && retVal2 !== false) {
          var events = target.__events__;
          var eventRecords = events ? events[eventName] : null;
          if (eventRecords) {
            for (var id in eventRecords) {
              if (eventRecords.hasOwnProperty(id)) {
                var eventRecordList = eventRecords[id];
                for (var listIndex = 0; retVal2 !== false && listIndex < eventRecordList.length; listIndex++) {
                  var record = eventRecordList[listIndex];
                  if (record.objectCallback) {
                    retVal2 = record.objectCallback.call(record.parent, eventArgs);
                  }
                }
              }
            }
          }
          target = bubbleEvent ? target.parent : null;
        }
      }
      return retVal2;
    };
    EventGroup2.isObserved = function(target, eventName) {
      var events = target && target.__events__;
      return !!events && !!events[eventName];
    };
    EventGroup2.isDeclared = function(target, eventName) {
      var declaredEvents = target && target.__declaredEvents;
      return !!declaredEvents && !!declaredEvents[eventName];
    };
    EventGroup2.stopPropagation = function(event) {
      if (event.stopPropagation) {
        event.stopPropagation();
      } else {
        event.cancelBubble = true;
      }
    };
    EventGroup2._isElement = function(target) {
      return !!target && (!!target.addEventListener || typeof HTMLElement !== "undefined" && target instanceof HTMLElement);
    };
    EventGroup2.prototype.dispose = function() {
      if (!this._isDisposed) {
        this._isDisposed = true;
        this.off();
        this._parent = null;
      }
    };
    EventGroup2.prototype.onAll = function(target, events, useCapture) {
      for (var eventName in events) {
        if (events.hasOwnProperty(eventName)) {
          this.on(target, eventName, events[eventName], useCapture);
        }
      }
    };
    EventGroup2.prototype.on = function(target, eventName, callback, options) {
      var _this = this;
      if (eventName.indexOf(",") > -1) {
        var events = eventName.split(/[ ,]+/);
        for (var i = 0; i < events.length; i++) {
          this.on(target, events[i], callback, options);
        }
      } else {
        var parent_1 = this._parent;
        var eventRecord = {
          target,
          eventName,
          parent: parent_1,
          callback,
          options
        };
        var events = target.__events__ = target.__events__ || {};
        events[eventName] = events[eventName] || {
          count: 0
        };
        events[eventName][this._id] = events[eventName][this._id] || [];
        events[eventName][this._id].push(eventRecord);
        events[eventName].count++;
        if (EventGroup2._isElement(target)) {
          var processElementEvent = function() {
            var args = [];
            for (var _i = 0; _i < arguments.length; _i++) {
              args[_i] = arguments[_i];
            }
            if (_this._isDisposed) {
              return;
            }
            var result;
            try {
              result = callback.apply(parent_1, args);
              if (result === false && args[0]) {
                var e = args[0];
                if (e.preventDefault) {
                  e.preventDefault();
                }
                if (e.stopPropagation) {
                  e.stopPropagation();
                }
                e.cancelBubble = true;
              }
            } catch (e2) {
            }
            return result;
          };
          eventRecord.elementCallback = processElementEvent;
          if (target.addEventListener) {
            target.addEventListener(eventName, processElementEvent, options);
          } else if (target.attachEvent) {
            target.attachEvent("on" + eventName, processElementEvent);
          }
        } else {
          var processObjectEvent = function() {
            var args = [];
            for (var _i = 0; _i < arguments.length; _i++) {
              args[_i] = arguments[_i];
            }
            if (_this._isDisposed) {
              return;
            }
            return callback.apply(parent_1, args);
          };
          eventRecord.objectCallback = processObjectEvent;
        }
        this._eventRecords.push(eventRecord);
      }
    };
    EventGroup2.prototype.off = function(target, eventName, callback, options) {
      for (var i = 0; i < this._eventRecords.length; i++) {
        var eventRecord = this._eventRecords[i];
        if ((!target || target === eventRecord.target) && (!eventName || eventName === eventRecord.eventName) && (!callback || callback === eventRecord.callback) && (typeof options !== "boolean" || options === eventRecord.options)) {
          var events = eventRecord.target.__events__;
          var targetArrayLookup = events[eventRecord.eventName];
          var targetArray = targetArrayLookup ? targetArrayLookup[this._id] : null;
          if (targetArray) {
            if (targetArray.length === 1 || !callback) {
              targetArrayLookup.count -= targetArray.length;
              delete events[eventRecord.eventName][this._id];
            } else {
              targetArrayLookup.count--;
              targetArray.splice(targetArray.indexOf(eventRecord), 1);
            }
            if (!targetArrayLookup.count) {
              delete events[eventRecord.eventName];
            }
          }
          if (eventRecord.elementCallback) {
            if (eventRecord.target.removeEventListener) {
              eventRecord.target.removeEventListener(eventRecord.eventName, eventRecord.elementCallback, eventRecord.options);
            } else if (eventRecord.target.detachEvent) {
              eventRecord.target.detachEvent("on" + eventRecord.eventName, eventRecord.elementCallback);
            }
          }
          this._eventRecords.splice(i--, 1);
        }
      }
    };
    EventGroup2.prototype.raise = function(eventName, eventArgs, bubbleEvent) {
      return EventGroup2.raise(this._parent, eventName, eventArgs, bubbleEvent);
    };
    EventGroup2.prototype.declare = function(event) {
      var declaredEvents = this._parent.__declaredEvents = this._parent.__declaredEvents || {};
      if (typeof event === "string") {
        declaredEvents[event] = true;
      } else {
        for (var i = 0; i < event.length; i++) {
          declaredEvents[event[i]] = true;
        }
      }
    };
    EventGroup2._uniqueId = 0;
    return EventGroup2;
  }()
);

// node_modules/tslib/tslib.es6.mjs
var extendStatics = function(d, b) {
  extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
    d2.__proto__ = b2;
  } || function(d2, b2) {
    for (var p in b2)
      if (Object.prototype.hasOwnProperty.call(b2, p))
        d2[p] = b2[p];
  };
  return extendStatics(d, b);
};
function __extends(d, b) {
  if (typeof b !== "function" && b !== null)
    throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
  extendStatics(d, b);
  function __() {
    this.constructor = d;
  }
  d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
}
var __assign = function() {
  __assign = Object.assign || function __assign3(t) {
    for (var s, i = 1, n = arguments.length; i < n; i++) {
      s = arguments[i];
      for (var p in s)
        if (Object.prototype.hasOwnProperty.call(s, p))
          t[p] = s[p];
    }
    return t;
  };
  return __assign.apply(this, arguments);
};
function __rest(s, e) {
  var t = {};
  for (var p in s)
    if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
      t[p] = s[p];
  if (s != null && typeof Object.getOwnPropertySymbols === "function")
    for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
      if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
        t[p[i]] = s[p[i]];
    }
  return t;
}
function __decorate(decorators, target, key, desc) {
  var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
    r = Reflect.decorate(decorators, target, key, desc);
  else
    for (var i = decorators.length - 1; i >= 0; i--)
      if (d = decorators[i])
        r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
  return c > 3 && r && Object.defineProperty(target, key, r), r;
}
function __spreadArray(to, from, pack) {
  if (pack || arguments.length === 2)
    for (var i = 0, l = from.length, ar; i < l; i++) {
      if (ar || !(i in from)) {
        if (!ar)
          ar = Array.prototype.slice.call(from, 0, i);
        ar[i] = from[i];
      }
    }
  return to.concat(ar || Array.prototype.slice.call(from));
}

// node_modules/@fluentui/merge-styles/lib/Stylesheet.js
var InjectionMode = {
  /**
   * Avoids style injection, use getRules() to read the styles.
   */
  none: 0,
  /**
   * Inserts rules using the insertRule api.
   */
  insertNode: 1,
  /**
   * Appends rules using appendChild.
   */
  appendChild: 2
};
var STYLESHEET_SETTING = "__stylesheet__";
var REUSE_STYLE_NODE = typeof navigator !== "undefined" && /rv:11.0/.test(navigator.userAgent);
var _global = {};
try {
  _global = window || {};
} catch (_a7) {
}
var _stylesheet;
var Stylesheet = (
  /** @class */
  function() {
    function Stylesheet2(config, serializedStylesheet) {
      var _a7, _b3, _c3, _d3, _e2, _f;
      this._rules = [];
      this._preservedRules = [];
      this._counter = 0;
      this._keyToClassName = {};
      this._onInsertRuleCallbacks = [];
      this._onResetCallbacks = [];
      this._classNameToArgs = {};
      this._config = __assign({
        // If there is no document we won't have an element to inject into.
        injectionMode: typeof document === "undefined" ? InjectionMode.none : InjectionMode.insertNode,
        defaultPrefix: "css",
        namespace: void 0,
        cspSettings: void 0
      }, config);
      this._classNameToArgs = (_a7 = serializedStylesheet === null || serializedStylesheet === void 0 ? void 0 : serializedStylesheet.classNameToArgs) !== null && _a7 !== void 0 ? _a7 : this._classNameToArgs;
      this._counter = (_b3 = serializedStylesheet === null || serializedStylesheet === void 0 ? void 0 : serializedStylesheet.counter) !== null && _b3 !== void 0 ? _b3 : this._counter;
      this._keyToClassName = (_d3 = (_c3 = this._config.classNameCache) !== null && _c3 !== void 0 ? _c3 : serializedStylesheet === null || serializedStylesheet === void 0 ? void 0 : serializedStylesheet.keyToClassName) !== null && _d3 !== void 0 ? _d3 : this._keyToClassName;
      this._preservedRules = (_e2 = serializedStylesheet === null || serializedStylesheet === void 0 ? void 0 : serializedStylesheet.preservedRules) !== null && _e2 !== void 0 ? _e2 : this._preservedRules;
      this._rules = (_f = serializedStylesheet === null || serializedStylesheet === void 0 ? void 0 : serializedStylesheet.rules) !== null && _f !== void 0 ? _f : this._rules;
    }
    Stylesheet2.getInstance = function() {
      _stylesheet = _global[STYLESHEET_SETTING];
      if (!_stylesheet || _stylesheet._lastStyleElement && _stylesheet._lastStyleElement.ownerDocument !== document) {
        var fabricConfig = (_global === null || _global === void 0 ? void 0 : _global.FabricConfig) || {};
        var stylesheet3 = new Stylesheet2(fabricConfig.mergeStyles, fabricConfig.serializedStylesheet);
        _stylesheet = stylesheet3;
        _global[STYLESHEET_SETTING] = stylesheet3;
      }
      return _stylesheet;
    };
    Stylesheet2.prototype.serialize = function() {
      return JSON.stringify({
        classNameToArgs: this._classNameToArgs,
        counter: this._counter,
        keyToClassName: this._keyToClassName,
        preservedRules: this._preservedRules,
        rules: this._rules
      });
    };
    Stylesheet2.prototype.setConfig = function(config) {
      this._config = __assign(__assign({}, this._config), config);
    };
    Stylesheet2.prototype.onReset = function(callback) {
      var _this = this;
      this._onResetCallbacks.push(callback);
      return function() {
        _this._onResetCallbacks = _this._onResetCallbacks.filter(function(cb) {
          return cb !== callback;
        });
      };
    };
    Stylesheet2.prototype.onInsertRule = function(callback) {
      var _this = this;
      this._onInsertRuleCallbacks.push(callback);
      return function() {
        _this._onInsertRuleCallbacks = _this._onInsertRuleCallbacks.filter(function(cb) {
          return cb !== callback;
        });
      };
    };
    Stylesheet2.prototype.getClassName = function(displayName) {
      var namespace = this._config.namespace;
      var prefix = displayName || this._config.defaultPrefix;
      return "".concat(namespace ? namespace + "-" : "").concat(prefix, "-").concat(this._counter++);
    };
    Stylesheet2.prototype.cacheClassName = function(className, key, args, rules2) {
      this._keyToClassName[key] = className;
      this._classNameToArgs[className] = {
        args,
        rules: rules2
      };
    };
    Stylesheet2.prototype.classNameFromKey = function(key) {
      return this._keyToClassName[key];
    };
    Stylesheet2.prototype.getClassNameCache = function() {
      return this._keyToClassName;
    };
    Stylesheet2.prototype.argsFromClassName = function(className) {
      var entry = this._classNameToArgs[className];
      return entry && entry.args;
    };
    Stylesheet2.prototype.insertedRulesFromClassName = function(className) {
      var entry = this._classNameToArgs[className];
      return entry && entry.rules;
    };
    Stylesheet2.prototype.insertRule = function(rule, preserve) {
      var injectionMode = this._config.injectionMode;
      var element = injectionMode !== InjectionMode.none ? this._getStyleElement() : void 0;
      if (preserve) {
        this._preservedRules.push(rule);
      }
      if (element) {
        switch (injectionMode) {
          case InjectionMode.insertNode:
            var sheet = element.sheet;
            try {
              sheet.insertRule(rule, sheet.cssRules.length);
            } catch (e) {
            }
            break;
          case InjectionMode.appendChild:
            element.appendChild(document.createTextNode(rule));
            break;
        }
      } else {
        this._rules.push(rule);
      }
      if (this._config.onInsertRule) {
        this._config.onInsertRule(rule);
      }
      this._onInsertRuleCallbacks.forEach(function(callback) {
        return callback();
      });
    };
    Stylesheet2.prototype.getRules = function(includePreservedRules) {
      return (includePreservedRules ? this._preservedRules.join("") : "") + this._rules.join("");
    };
    Stylesheet2.prototype.reset = function() {
      this._rules = [];
      this._counter = 0;
      this._classNameToArgs = {};
      this._keyToClassName = {};
      this._onResetCallbacks.forEach(function(callback) {
        return callback();
      });
    };
    Stylesheet2.prototype.resetKeys = function() {
      this._keyToClassName = {};
    };
    Stylesheet2.prototype._getStyleElement = function() {
      var _this = this;
      if (!this._styleElement && typeof document !== "undefined") {
        this._styleElement = this._createStyleElement();
        if (!REUSE_STYLE_NODE) {
          window.requestAnimationFrame(function() {
            _this._styleElement = void 0;
          });
        }
      }
      return this._styleElement;
    };
    Stylesheet2.prototype._createStyleElement = function() {
      var head = document.head;
      var styleElement = document.createElement("style");
      var nodeToInsertBefore = null;
      styleElement.setAttribute("data-merge-styles", "true");
      var cspSettings = this._config.cspSettings;
      if (cspSettings) {
        if (cspSettings.nonce) {
          styleElement.setAttribute("nonce", cspSettings.nonce);
        }
      }
      if (this._lastStyleElement) {
        nodeToInsertBefore = this._lastStyleElement.nextElementSibling;
      } else {
        var placeholderStyleTag = this._findPlaceholderStyleTag();
        if (placeholderStyleTag) {
          nodeToInsertBefore = placeholderStyleTag.nextElementSibling;
        } else {
          nodeToInsertBefore = head.childNodes[0];
        }
      }
      head.insertBefore(styleElement, head.contains(nodeToInsertBefore) ? nodeToInsertBefore : null);
      this._lastStyleElement = styleElement;
      return styleElement;
    };
    Stylesheet2.prototype._findPlaceholderStyleTag = function() {
      var head = document.head;
      if (head) {
        return head.querySelector("style[data-merge-styles]");
      }
      return null;
    };
    return Stylesheet2;
  }()
);

// node_modules/@fluentui/merge-styles/lib/extractStyleParts.js
function extractStyleParts() {
  var args = [];
  for (var _i = 0; _i < arguments.length; _i++) {
    args[_i] = arguments[_i];
  }
  var classes = [];
  var objects = [];
  var stylesheet3 = Stylesheet.getInstance();
  function _processArgs(argsList) {
    for (var _i2 = 0, argsList_1 = argsList; _i2 < argsList_1.length; _i2++) {
      var arg = argsList_1[_i2];
      if (arg) {
        if (typeof arg === "string") {
          if (arg.indexOf(" ") >= 0) {
            _processArgs(arg.split(" "));
          } else {
            var translatedArgs = stylesheet3.argsFromClassName(arg);
            if (translatedArgs) {
              _processArgs(translatedArgs);
            } else {
              if (classes.indexOf(arg) === -1) {
                classes.push(arg);
              }
            }
          }
        } else if (Array.isArray(arg)) {
          _processArgs(arg);
        } else if (typeof arg === "object") {
          objects.push(arg);
        }
      }
    }
  }
  _processArgs(args);
  return {
    classes,
    objects
  };
}

// node_modules/@fluentui/merge-styles/lib/StyleOptionsState.js
function setRTL(isRTL) {
  if (_rtl !== isRTL) {
    _rtl = isRTL;
  }
}
function getRTL() {
  if (_rtl === void 0) {
    _rtl = // eslint-disable-next-line no-restricted-globals
    typeof document !== "undefined" && // eslint-disable-next-line no-restricted-globals
    !!document.documentElement && // eslint-disable-next-line no-restricted-globals
    document.documentElement.getAttribute("dir") === "rtl";
  }
  return _rtl;
}
var _rtl;
_rtl = getRTL();
function getStyleOptions() {
  return {
    rtl: getRTL()
  };
}

// node_modules/@fluentui/merge-styles/lib/transforms/kebabRules.js
var rules = {};
function kebabRules(rulePairs, index) {
  var rule = rulePairs[index];
  if (rule.charAt(0) !== "-") {
    rulePairs[index] = rules[rule] = rules[rule] || rule.replace(/([A-Z])/g, "-$1").toLowerCase();
  }
}

// node_modules/@fluentui/merge-styles/lib/getVendorSettings.js
var _vendorSettings;
function getVendorSettings() {
  var _a7;
  if (!_vendorSettings) {
    var doc = typeof document !== "undefined" ? document : void 0;
    var nav = typeof navigator !== "undefined" ? navigator : void 0;
    var userAgent = (_a7 = nav === null || nav === void 0 ? void 0 : nav.userAgent) === null || _a7 === void 0 ? void 0 : _a7.toLowerCase();
    if (!doc) {
      _vendorSettings = {
        isWebkit: true,
        isMoz: true,
        isOpera: true,
        isMs: true
      };
    } else {
      _vendorSettings = {
        isWebkit: !!(doc && "WebkitAppearance" in doc.documentElement.style),
        isMoz: !!(userAgent && userAgent.indexOf("firefox") > -1),
        isOpera: !!(userAgent && userAgent.indexOf("opera") > -1),
        isMs: !!(nav && (/rv:11.0/i.test(nav.userAgent) || /Edge\/\d./i.test(navigator.userAgent)))
      };
    }
  }
  return _vendorSettings;
}

// node_modules/@fluentui/merge-styles/lib/transforms/prefixRules.js
var autoPrefixNames = {
  "user-select": 1
};
function prefixRules(rulePairs, index) {
  var vendorSettings = getVendorSettings();
  var name = rulePairs[index];
  if (autoPrefixNames[name]) {
    var value = rulePairs[index + 1];
    if (autoPrefixNames[name]) {
      if (vendorSettings.isWebkit) {
        rulePairs.push("-webkit-" + name, value);
      }
      if (vendorSettings.isMoz) {
        rulePairs.push("-moz-" + name, value);
      }
      if (vendorSettings.isMs) {
        rulePairs.push("-ms-" + name, value);
      }
      if (vendorSettings.isOpera) {
        rulePairs.push("-o-" + name, value);
      }
    }
  }
}

// node_modules/@fluentui/merge-styles/lib/transforms/provideUnits.js
var NON_PIXEL_NUMBER_PROPS = [
  "column-count",
  "font-weight",
  "flex",
  "flex-grow",
  "flex-shrink",
  "fill-opacity",
  "opacity",
  "order",
  "z-index",
  "zoom"
];
function provideUnits(rulePairs, index) {
  var name = rulePairs[index];
  var value = rulePairs[index + 1];
  if (typeof value === "number") {
    var isNonPixelProp = NON_PIXEL_NUMBER_PROPS.indexOf(name) > -1;
    var isVariableOrPrefixed = name.indexOf("--") > -1;
    var unit = isNonPixelProp || isVariableOrPrefixed ? "" : "px";
    rulePairs[index + 1] = "".concat(value).concat(unit);
  }
}

// node_modules/@fluentui/merge-styles/lib/transforms/rtlifyRules.js
var _a;
var LEFT = "left";
var RIGHT = "right";
var NO_FLIP = "@noflip";
var NAME_REPLACEMENTS = (_a = {}, _a[LEFT] = RIGHT, _a[RIGHT] = LEFT, _a);
var VALUE_REPLACEMENTS = {
  "w-resize": "e-resize",
  "sw-resize": "se-resize",
  "nw-resize": "ne-resize"
};
function rtlifyRules(options, rulePairs, index) {
  if (options.rtl) {
    var name_1 = rulePairs[index];
    if (!name_1) {
      return;
    }
    var value = rulePairs[index + 1];
    if (typeof value === "string" && value.indexOf(NO_FLIP) >= 0) {
      rulePairs[index + 1] = value.replace(/\s*(?:\/\*\s*)?\@noflip\b(?:\s*\*\/)?\s*?/g, "");
    } else if (name_1.indexOf(LEFT) >= 0) {
      rulePairs[index] = name_1.replace(LEFT, RIGHT);
    } else if (name_1.indexOf(RIGHT) >= 0) {
      rulePairs[index] = name_1.replace(RIGHT, LEFT);
    } else if (String(value).indexOf(LEFT) >= 0) {
      rulePairs[index + 1] = value.replace(LEFT, RIGHT);
    } else if (String(value).indexOf(RIGHT) >= 0) {
      rulePairs[index + 1] = value.replace(RIGHT, LEFT);
    } else if (NAME_REPLACEMENTS[name_1]) {
      rulePairs[index] = NAME_REPLACEMENTS[name_1];
    } else if (VALUE_REPLACEMENTS[value]) {
      rulePairs[index + 1] = VALUE_REPLACEMENTS[value];
    } else {
      switch (name_1) {
        case "margin":
        case "padding":
          rulePairs[index + 1] = flipQuad(value);
          break;
        case "box-shadow":
          rulePairs[index + 1] = negateNum(value, 0);
          break;
      }
    }
  }
}
function negateNum(value, partIndex) {
  var parts = value.split(" ");
  var numberVal = parseInt(parts[partIndex], 10);
  parts[0] = parts[0].replace(String(numberVal), String(numberVal * -1));
  return parts.join(" ");
}
function flipQuad(value) {
  if (typeof value === "string") {
    var parts = value.split(" ");
    if (parts.length === 4) {
      return "".concat(parts[0], " ").concat(parts[3], " ").concat(parts[2], " ").concat(parts[1]);
    }
  }
  return value;
}

// node_modules/@fluentui/merge-styles/lib/tokenizeWithParentheses.js
function tokenizeWithParentheses(value) {
  var parts = [];
  var partStart = 0;
  var parens = 0;
  for (var i = 0; i < value.length; i++) {
    switch (value[i]) {
      case "(":
        parens++;
        break;
      case ")":
        if (parens) {
          parens--;
        }
        break;
      case "	":
      case " ":
        if (!parens) {
          if (i > partStart) {
            parts.push(value.substring(partStart, i));
          }
          partStart = i + 1;
        }
        break;
    }
  }
  if (partStart < value.length) {
    parts.push(value.substring(partStart));
  }
  return parts;
}

// node_modules/@fluentui/merge-styles/lib/styleToClassName.js
var DISPLAY_NAME = "displayName";
function getDisplayName(rules2) {
  var rootStyle = rules2 && rules2["&"];
  return rootStyle ? rootStyle.displayName : void 0;
}
var globalSelectorRegExp = /\:global\((.+?)\)/g;
function expandCommaSeparatedGlobals(selectorWithGlobals) {
  if (!globalSelectorRegExp.test(selectorWithGlobals)) {
    return selectorWithGlobals;
  }
  var replacementInfo = [];
  var findGlobal = /\:global\((.+?)\)/g;
  var match = null;
  while (match = findGlobal.exec(selectorWithGlobals)) {
    if (match[1].indexOf(",") > -1) {
      replacementInfo.push([
        match.index,
        match.index + match[0].length,
        // Wrap each of the found selectors in :global()
        match[1].split(",").map(function(v) {
          return ":global(".concat(v.trim(), ")");
        }).join(", ")
      ]);
    }
  }
  return replacementInfo.reverse().reduce(function(selector, _a7) {
    var matchIndex = _a7[0], matchEndIndex = _a7[1], replacement = _a7[2];
    var prefix = selector.slice(0, matchIndex);
    var suffix = selector.slice(matchEndIndex);
    return prefix + replacement + suffix;
  }, selectorWithGlobals);
}
function expandSelector(newSelector, currentSelector) {
  if (newSelector.indexOf(":global(") >= 0) {
    return newSelector.replace(globalSelectorRegExp, "$1");
  } else if (newSelector.indexOf(":") === 0) {
    return currentSelector + newSelector;
  } else if (newSelector.indexOf("&") < 0) {
    return currentSelector + " " + newSelector;
  }
  return newSelector;
}
function extractSelector(currentSelector, rules2, selector, value) {
  if (rules2 === void 0) {
    rules2 = { __order: [] };
  }
  if (selector.indexOf("@") === 0) {
    selector = selector + "{" + currentSelector;
    extractRules([value], rules2, selector);
  } else if (selector.indexOf(",") > -1) {
    expandCommaSeparatedGlobals(selector).split(",").map(function(s) {
      return s.trim();
    }).forEach(function(separatedSelector) {
      return extractRules([value], rules2, expandSelector(separatedSelector, currentSelector));
    });
  } else {
    extractRules([value], rules2, expandSelector(selector, currentSelector));
  }
}
function extractRules(args, rules2, currentSelector) {
  if (rules2 === void 0) {
    rules2 = { __order: [] };
  }
  if (currentSelector === void 0) {
    currentSelector = "&";
  }
  var stylesheet3 = Stylesheet.getInstance();
  var currentRules = rules2[currentSelector];
  if (!currentRules) {
    currentRules = {};
    rules2[currentSelector] = currentRules;
    rules2.__order.push(currentSelector);
  }
  for (var _i = 0, args_1 = args; _i < args_1.length; _i++) {
    var arg = args_1[_i];
    if (typeof arg === "string") {
      var expandedRules = stylesheet3.argsFromClassName(arg);
      if (expandedRules) {
        extractRules(expandedRules, rules2, currentSelector);
      }
    } else if (Array.isArray(arg)) {
      extractRules(arg, rules2, currentSelector);
    } else {
      for (var prop in arg) {
        if (arg.hasOwnProperty(prop)) {
          var propValue = arg[prop];
          if (prop === "selectors") {
            var selectors = arg.selectors;
            for (var newSelector in selectors) {
              if (selectors.hasOwnProperty(newSelector)) {
                extractSelector(currentSelector, rules2, newSelector, selectors[newSelector]);
              }
            }
          } else if (typeof propValue === "object") {
            if (propValue !== null) {
              extractSelector(currentSelector, rules2, prop, propValue);
            }
          } else {
            if (propValue !== void 0) {
              if (prop === "margin" || prop === "padding") {
                expandQuads(currentRules, prop, propValue);
              } else {
                currentRules[prop] = propValue;
              }
            }
          }
        }
      }
    }
  }
  return rules2;
}
function expandQuads(currentRules, name, value) {
  var parts = typeof value === "string" ? tokenizeWithParentheses(value) : [value];
  if (parts.length === 0) {
    parts.push(value);
  }
  if (parts[parts.length - 1] === "!important") {
    parts = parts.slice(0, -1).map(function(p) {
      return p + " !important";
    });
  }
  currentRules[name + "Top"] = parts[0];
  currentRules[name + "Right"] = parts[1] || parts[0];
  currentRules[name + "Bottom"] = parts[2] || parts[0];
  currentRules[name + "Left"] = parts[3] || parts[1] || parts[0];
}
function getKeyForRules(options, rules2) {
  var serialized = [options.rtl ? "rtl" : "ltr"];
  var hasProps = false;
  for (var _i = 0, _a7 = rules2.__order; _i < _a7.length; _i++) {
    var selector = _a7[_i];
    serialized.push(selector);
    var rulesForSelector = rules2[selector];
    for (var propName in rulesForSelector) {
      if (rulesForSelector.hasOwnProperty(propName) && rulesForSelector[propName] !== void 0) {
        hasProps = true;
        serialized.push(propName, rulesForSelector[propName]);
      }
    }
  }
  return hasProps ? serialized.join("") : void 0;
}
function repeatString(target, count) {
  if (count <= 0) {
    return "";
  }
  if (count === 1) {
    return target;
  }
  return target + repeatString(target, count - 1);
}
function serializeRuleEntries(options, ruleEntries) {
  if (!ruleEntries) {
    return "";
  }
  var allEntries = [];
  for (var entry in ruleEntries) {
    if (ruleEntries.hasOwnProperty(entry) && entry !== DISPLAY_NAME && ruleEntries[entry] !== void 0) {
      allEntries.push(entry, ruleEntries[entry]);
    }
  }
  for (var i = 0; i < allEntries.length; i += 2) {
    kebabRules(allEntries, i);
    provideUnits(allEntries, i);
    rtlifyRules(options, allEntries, i);
    prefixRules(allEntries, i);
  }
  for (var i = 1; i < allEntries.length; i += 4) {
    allEntries.splice(i, 1, ":", allEntries[i], ";");
  }
  return allEntries.join("");
}
function styleToRegistration(options) {
  var args = [];
  for (var _i = 1; _i < arguments.length; _i++) {
    args[_i - 1] = arguments[_i];
  }
  var rules2 = extractRules(args);
  var key = getKeyForRules(options, rules2);
  if (key) {
    var stylesheet3 = Stylesheet.getInstance();
    var registration = {
      className: stylesheet3.classNameFromKey(key),
      key,
      args
    };
    if (!registration.className) {
      registration.className = stylesheet3.getClassName(getDisplayName(rules2));
      var rulesToInsert = [];
      for (var _a7 = 0, _b3 = rules2.__order; _a7 < _b3.length; _a7++) {
        var selector = _b3[_a7];
        rulesToInsert.push(selector, serializeRuleEntries(options, rules2[selector]));
      }
      registration.rulesToInsert = rulesToInsert;
    }
    return registration;
  }
  return void 0;
}
function applyRegistration(registration, specificityMultiplier) {
  if (specificityMultiplier === void 0) {
    specificityMultiplier = 1;
  }
  var stylesheet3 = Stylesheet.getInstance();
  var className = registration.className, key = registration.key, args = registration.args, rulesToInsert = registration.rulesToInsert;
  if (rulesToInsert) {
    for (var i = 0; i < rulesToInsert.length; i += 2) {
      var rules2 = rulesToInsert[i + 1];
      if (rules2) {
        var selector = rulesToInsert[i];
        selector = selector.replace(/&/g, repeatString(".".concat(registration.className), specificityMultiplier));
        var processedRule = "".concat(selector, "{").concat(rules2, "}").concat(selector.indexOf("@") === 0 ? "}" : "");
        stylesheet3.insertRule(processedRule);
      }
    }
    stylesheet3.cacheClassName(className, key, args, rulesToInsert);
  }
}
function styleToClassName(options) {
  var args = [];
  for (var _i = 1; _i < arguments.length; _i++) {
    args[_i - 1] = arguments[_i];
  }
  var registration = styleToRegistration.apply(void 0, __spreadArray([options], args, false));
  if (registration) {
    applyRegistration(registration, options.specificityMultiplier);
    return registration.className;
  }
  return "";
}

// node_modules/@fluentui/merge-styles/lib/mergeStyles.js
function mergeStyles() {
  var args = [];
  for (var _i = 0; _i < arguments.length; _i++) {
    args[_i] = arguments[_i];
  }
  return mergeCss(args, getStyleOptions());
}
function mergeCss(args, options) {
  var styleArgs = args instanceof Array ? args : [args];
  var _a7 = extractStyleParts(styleArgs), classes = _a7.classes, objects = _a7.objects;
  if (objects.length) {
    classes.push(styleToClassName(options || {}, objects));
  }
  return classes.join(" ");
}

// node_modules/@fluentui/merge-styles/lib/concatStyleSets.js
function concatStyleSets() {
  var styleSets = [];
  for (var _i = 0; _i < arguments.length; _i++) {
    styleSets[_i] = arguments[_i];
  }
  if (styleSets && styleSets.length === 1 && styleSets[0] && !styleSets[0].subComponentStyles) {
    return styleSets[0];
  }
  var mergedSet = {};
  var workingSubcomponentStyles = {};
  for (var _a7 = 0, styleSets_1 = styleSets; _a7 < styleSets_1.length; _a7++) {
    var currentSet = styleSets_1[_a7];
    if (currentSet) {
      for (var prop in currentSet) {
        if (currentSet.hasOwnProperty(prop)) {
          if (prop === "subComponentStyles" && currentSet.subComponentStyles !== void 0) {
            var currentComponentStyles = currentSet.subComponentStyles;
            for (var subCompProp in currentComponentStyles) {
              if (currentComponentStyles.hasOwnProperty(subCompProp)) {
                if (workingSubcomponentStyles.hasOwnProperty(subCompProp)) {
                  workingSubcomponentStyles[subCompProp].push(currentComponentStyles[subCompProp]);
                } else {
                  workingSubcomponentStyles[subCompProp] = [currentComponentStyles[subCompProp]];
                }
              }
            }
            continue;
          }
          var mergedValue = mergedSet[prop];
          var currentValue = currentSet[prop];
          if (mergedValue === void 0) {
            mergedSet[prop] = currentValue;
          } else {
            mergedSet[prop] = __spreadArray(__spreadArray([], Array.isArray(mergedValue) ? mergedValue : [mergedValue], true), Array.isArray(currentValue) ? currentValue : [currentValue], true);
          }
        }
      }
    }
  }
  if (Object.keys(workingSubcomponentStyles).length > 0) {
    mergedSet.subComponentStyles = {};
    var mergedSubStyles = mergedSet.subComponentStyles;
    var _loop_1 = function(subCompProp2) {
      if (workingSubcomponentStyles.hasOwnProperty(subCompProp2)) {
        var workingSet_1 = workingSubcomponentStyles[subCompProp2];
        mergedSubStyles[subCompProp2] = function(styleProps) {
          return concatStyleSets.apply(void 0, workingSet_1.map(function(styleFunctionOrObject) {
            return typeof styleFunctionOrObject === "function" ? styleFunctionOrObject(styleProps) : styleFunctionOrObject;
          }));
        };
      }
    };
    for (var subCompProp in workingSubcomponentStyles) {
      _loop_1(subCompProp);
    }
  }
  return mergedSet;
}

// node_modules/@fluentui/merge-styles/lib/mergeStyleSets.js
function mergeStyleSets() {
  var styleSets = [];
  for (var _i = 0; _i < arguments.length; _i++) {
    styleSets[_i] = arguments[_i];
  }
  return mergeCssSets(styleSets, getStyleOptions());
}
function mergeCssSets(styleSets, options) {
  var classNameSet = { subComponentStyles: {} };
  var styleSet = styleSets[0];
  if (!styleSet && styleSets.length <= 1) {
    return { subComponentStyles: {} };
  }
  var concatenatedStyleSet = concatStyleSets.apply(void 0, styleSets);
  var registrations = [];
  for (var styleSetArea in concatenatedStyleSet) {
    if (concatenatedStyleSet.hasOwnProperty(styleSetArea)) {
      if (styleSetArea === "subComponentStyles") {
        classNameSet.subComponentStyles = concatenatedStyleSet.subComponentStyles || {};
        continue;
      }
      var styles = concatenatedStyleSet[styleSetArea];
      var _a7 = extractStyleParts(styles), classes = _a7.classes, objects = _a7.objects;
      if (objects === null || objects === void 0 ? void 0 : objects.length) {
        var registration = styleToRegistration(options || {}, { displayName: styleSetArea }, objects);
        if (registration) {
          registrations.push(registration);
          classNameSet[styleSetArea] = classes.concat([registration.className]).join(" ");
        }
      } else {
        classNameSet[styleSetArea] = classes.join(" ");
      }
    }
  }
  for (var _i = 0, registrations_1 = registrations; _i < registrations_1.length; _i++) {
    var registration = registrations_1[_i];
    if (registration) {
      applyRegistration(registration, options === null || options === void 0 ? void 0 : options.specificityMultiplier);
    }
  }
  return classNameSet;
}

// node_modules/@fluentui/merge-styles/lib/concatStyleSetsWithProps.js
function concatStyleSetsWithProps(styleProps) {
  var allStyles = [];
  for (var _i = 1; _i < arguments.length; _i++) {
    allStyles[_i - 1] = arguments[_i];
  }
  var result = [];
  for (var _a7 = 0, allStyles_1 = allStyles; _a7 < allStyles_1.length; _a7++) {
    var styles = allStyles_1[_a7];
    if (styles) {
      result.push(typeof styles === "function" ? styles(styleProps) : styles);
    }
  }
  if (result.length === 1) {
    return result[0];
  } else if (result.length) {
    return concatStyleSets.apply(void 0, result);
  }
  return {};
}

// node_modules/@fluentui/merge-styles/lib/fontFace.js
function fontFace(font) {
  var stylesheet3 = Stylesheet.getInstance();
  var rule = serializeRuleEntries(getStyleOptions(), font);
  var className = stylesheet3.classNameFromKey(rule);
  if (className) {
    return;
  }
  var name = stylesheet3.getClassName();
  stylesheet3.insertRule("@font-face{".concat(rule, "}"), true);
  stylesheet3.cacheClassName(name, rule, [], ["font-face", rule]);
}

// node_modules/@fluentui/merge-styles/lib/keyframes.js
function keyframes(timeline) {
  var stylesheet3 = Stylesheet.getInstance();
  var rulesArray = [];
  for (var prop in timeline) {
    if (timeline.hasOwnProperty(prop)) {
      rulesArray.push(prop, "{", serializeRuleEntries(getStyleOptions(), timeline[prop]), "}");
    }
  }
  var rules2 = rulesArray.join("");
  var className = stylesheet3.classNameFromKey(rules2);
  if (className) {
    return className;
  }
  var name = stylesheet3.getClassName();
  stylesheet3.insertRule("@keyframes ".concat(name, "{").concat(rules2, "}"), true);
  stylesheet3.cacheClassName(name, rules2, [], ["keyframes", rules2]);
  return name;
}

// node_modules/@fluentui/merge-styles/lib/version.js
setVersion("@fluentui/merge-styles", "8.5.15");

// node_modules/@fluentui/utilities/lib/scroll.js
var _scrollbarWidth;
var _bodyScrollDisabledCount = 0;
var DisabledScrollClassName = mergeStyles({
  overflow: "hidden !important"
});
var DATA_IS_SCROLLABLE_ATTRIBUTE = "data-is-scrollable";
var allowScrollOnElement = function(element, events) {
  var window2 = getWindow(element);
  if (!element || !window2) {
    return;
  }
  var _previousClientY = 0;
  var _element = null;
  var computedStyles = window2.getComputedStyle(element);
  var _saveClientY = function(event) {
    if (event.targetTouches.length === 1) {
      _previousClientY = event.targetTouches[0].clientY;
    }
  };
  var _preventOverscrolling = function(event) {
    if (event.targetTouches.length !== 1) {
      return;
    }
    event.stopPropagation();
    if (!_element) {
      return;
    }
    var clientY = event.targetTouches[0].clientY - _previousClientY;
    var scrollableParent = findScrollableParent(event.target);
    if (scrollableParent && _element !== scrollableParent) {
      _element = scrollableParent;
      computedStyles = window2.getComputedStyle(_element);
    }
    var scrollTop = _element.scrollTop;
    var isColumnReverse = (computedStyles === null || computedStyles === void 0 ? void 0 : computedStyles.flexDirection) === "column-reverse";
    if (scrollTop === 0 && (isColumnReverse ? clientY < 0 : clientY > 0)) {
      event.preventDefault();
    }
    if (_element.scrollHeight - Math.abs(Math.ceil(scrollTop)) <= _element.clientHeight && (isColumnReverse ? clientY > 0 : clientY < 0)) {
      event.preventDefault();
    }
  };
  events.on(element, "touchstart", _saveClientY, { passive: false });
  events.on(element, "touchmove", _preventOverscrolling, { passive: false });
  _element = element;
};
var allowOverscrollOnElement = function(element, events) {
  if (!element) {
    return;
  }
  var _allowElementScroll = function(event) {
    event.stopPropagation();
  };
  events.on(element, "touchmove", _allowElementScroll, { passive: false });
};
var _disableIosBodyScroll = function(event) {
  event.preventDefault();
};
function disableBodyScroll() {
  var doc = getDocument();
  if (doc && doc.body && !_bodyScrollDisabledCount) {
    doc.body.classList.add(DisabledScrollClassName);
    doc.body.addEventListener("touchmove", _disableIosBodyScroll, { passive: false, capture: false });
  }
  _bodyScrollDisabledCount++;
}
function enableBodyScroll() {
  if (_bodyScrollDisabledCount > 0) {
    var doc = getDocument();
    if (doc && doc.body && _bodyScrollDisabledCount === 1) {
      doc.body.classList.remove(DisabledScrollClassName);
      doc.body.removeEventListener("touchmove", _disableIosBodyScroll);
    }
    _bodyScrollDisabledCount--;
  }
}
function getScrollbarWidth(doc) {
  if (_scrollbarWidth === void 0) {
    var theDoc = doc !== null && doc !== void 0 ? doc : getDocument();
    var scrollDiv = theDoc.createElement("div");
    scrollDiv.style.setProperty("width", "100px");
    scrollDiv.style.setProperty("height", "100px");
    scrollDiv.style.setProperty("overflow", "scroll");
    scrollDiv.style.setProperty("position", "absolute");
    scrollDiv.style.setProperty("top", "-9999px");
    theDoc.body.appendChild(scrollDiv);
    _scrollbarWidth = scrollDiv.offsetWidth - scrollDiv.clientWidth;
    theDoc.body.removeChild(scrollDiv);
  }
  return _scrollbarWidth;
}
function findScrollableParent(startingElement) {
  var el = startingElement;
  var doc = getDocument(startingElement);
  while (el && el !== doc.body) {
    if (el.getAttribute(DATA_IS_SCROLLABLE_ATTRIBUTE) === "true") {
      return el;
    }
    el = el.parentElement;
  }
  el = startingElement;
  while (el && el !== doc.body) {
    if (el.getAttribute(DATA_IS_SCROLLABLE_ATTRIBUTE) !== "false") {
      var computedStyles = getComputedStyle(el);
      var overflowY = computedStyles ? computedStyles.getPropertyValue("overflow-y") : "";
      if (overflowY && (overflowY === "scroll" || overflowY === "auto")) {
        return el;
      }
    }
    el = el.parentElement;
  }
  if (!el || el === doc.body) {
    el = getWindow(startingElement);
  }
  return el;
}

// node_modules/@fluentui/utilities/lib/AutoScroll.js
var SCROLL_ITERATION_DELAY = 16;
var SCROLL_GUTTER = 100;
var MAX_SCROLL_VELOCITY = 15;
var AutoScroll = (
  /** @class */
  function() {
    function AutoScroll2(element, win) {
      var theWin = win !== null && win !== void 0 ? win : getWindow(element);
      this._events = new EventGroup(this);
      this._scrollableParent = findScrollableParent(element);
      this._incrementScroll = this._incrementScroll.bind(this);
      this._scrollRect = getRect(this._scrollableParent, theWin);
      if (this._scrollableParent === theWin) {
        this._scrollableParent = theWin.document.body;
      }
      if (this._scrollableParent) {
        this._events.on(theWin, "mousemove", this._onMouseMove, true);
        this._events.on(theWin, "touchmove", this._onTouchMove, true);
      }
    }
    AutoScroll2.prototype.dispose = function() {
      this._events.dispose();
      this._stopScroll();
    };
    AutoScroll2.prototype._onMouseMove = function(ev) {
      this._computeScrollVelocity(ev);
    };
    AutoScroll2.prototype._onTouchMove = function(ev) {
      if (ev.touches.length > 0) {
        this._computeScrollVelocity(ev);
      }
    };
    AutoScroll2.prototype._computeScrollVelocity = function(ev) {
      if (!this._scrollRect) {
        return;
      }
      var clientX;
      var clientY;
      if ("clientX" in ev) {
        clientX = ev.clientX;
        clientY = ev.clientY;
      } else {
        clientX = ev.touches[0].clientX;
        clientY = ev.touches[0].clientY;
      }
      var scrollRectTop = this._scrollRect.top;
      var scrollRectLeft = this._scrollRect.left;
      var scrollClientBottom = scrollRectTop + this._scrollRect.height - SCROLL_GUTTER;
      var scrollClientRight = scrollRectLeft + this._scrollRect.width - SCROLL_GUTTER;
      var scrollRect;
      var clientDirection;
      var scrollClient;
      if (clientY < scrollRectTop + SCROLL_GUTTER || clientY > scrollClientBottom) {
        clientDirection = clientY;
        scrollRect = scrollRectTop;
        scrollClient = scrollClientBottom;
        this._isVerticalScroll = true;
      } else {
        clientDirection = clientX;
        scrollRect = scrollRectLeft;
        scrollClient = scrollClientRight;
        this._isVerticalScroll = false;
      }
      if (clientDirection < scrollRect + SCROLL_GUTTER) {
        this._scrollVelocity = Math.max(-MAX_SCROLL_VELOCITY, -MAX_SCROLL_VELOCITY * ((SCROLL_GUTTER - (clientDirection - scrollRect)) / SCROLL_GUTTER));
      } else if (clientDirection > scrollClient) {
        this._scrollVelocity = Math.min(MAX_SCROLL_VELOCITY, MAX_SCROLL_VELOCITY * ((clientDirection - scrollClient) / SCROLL_GUTTER));
      } else {
        this._scrollVelocity = 0;
      }
      if (this._scrollVelocity) {
        this._startScroll();
      } else {
        this._stopScroll();
      }
    };
    AutoScroll2.prototype._startScroll = function() {
      if (!this._timeoutId) {
        this._incrementScroll();
      }
    };
    AutoScroll2.prototype._incrementScroll = function() {
      if (this._scrollableParent) {
        if (this._isVerticalScroll) {
          this._scrollableParent.scrollTop += Math.round(this._scrollVelocity);
        } else {
          this._scrollableParent.scrollLeft += Math.round(this._scrollVelocity);
        }
      }
      this._timeoutId = setTimeout(this._incrementScroll, SCROLL_ITERATION_DELAY);
    };
    AutoScroll2.prototype._stopScroll = function() {
      if (this._timeoutId) {
        clearTimeout(this._timeoutId);
        delete this._timeoutId;
      }
    };
    return AutoScroll2;
  }()
);

// node_modules/@fluentui/utilities/lib/BaseComponent.js
var React = __toESM(require_react());

// node_modules/@fluentui/utilities/lib/warn/warn.js
var _warningCallback = void 0;
function warn(message) {
  if (_warningCallback && true) {
    _warningCallback(message);
  } else if (console && console.warn) {
    console.warn(message);
  }
}

// node_modules/@fluentui/utilities/lib/warn/warnConditionallyRequiredProps.js
function warnConditionallyRequiredProps(componentName, props, requiredProps, conditionalPropName, condition) {
  if (condition === true && true) {
    for (var _i = 0, requiredProps_1 = requiredProps; _i < requiredProps_1.length; _i++) {
      var requiredPropName = requiredProps_1[_i];
      if (!(requiredPropName in props)) {
        warn("".concat(componentName, " property '").concat(requiredPropName, "' is required when '").concat(conditionalPropName, "' is used.'"));
      }
    }
  }
}

// node_modules/@fluentui/utilities/lib/warn/warnMutuallyExclusive.js
function warnMutuallyExclusive(componentName, props, exclusiveMap) {
  if (true) {
    for (var propName in exclusiveMap) {
      if (props && props[propName] !== void 0) {
        var propInExclusiveMapValue = exclusiveMap[propName];
        if (propInExclusiveMapValue && props[propInExclusiveMapValue] !== void 0) {
          warn("".concat(componentName, " property '").concat(propName, "' is mutually exclusive with '").concat(exclusiveMap[propName], "'. ") + "Use one or the other.");
        }
      }
    }
  }
}

// node_modules/@fluentui/utilities/lib/warn/warnDeprecations.js
function warnDeprecations(componentName, props, deprecationMap) {
  if (true) {
    for (var propName in deprecationMap) {
      if (props && propName in props) {
        var deprecationMessage = "".concat(componentName, " property '").concat(propName, "' was used but has been deprecated.");
        var replacementPropName = deprecationMap[propName];
        if (replacementPropName) {
          deprecationMessage += " Use '".concat(replacementPropName, "' instead.");
        }
        warn(deprecationMessage);
      }
    }
  }
}

// node_modules/@fluentui/utilities/lib/BaseComponent.js
var BaseComponent = (
  /** @class */
  function(_super) {
    __extends(BaseComponent2, _super);
    function BaseComponent2(props, context) {
      var _this = _super.call(this, props, context) || this;
      _makeAllSafe(_this, BaseComponent2.prototype, [
        "componentDidMount",
        "shouldComponentUpdate",
        "getSnapshotBeforeUpdate",
        "render",
        "componentDidUpdate",
        "componentWillUnmount"
      ]);
      return _this;
    }
    BaseComponent2.prototype.componentDidUpdate = function(prevProps, prevState) {
      this._updateComponentRef(prevProps, this.props);
    };
    BaseComponent2.prototype.componentDidMount = function() {
      this._setComponentRef(this.props.componentRef, this);
    };
    BaseComponent2.prototype.componentWillUnmount = function() {
      this._setComponentRef(this.props.componentRef, null);
      if (this.__disposables) {
        for (var i = 0, len = this._disposables.length; i < len; i++) {
          var disposable = this.__disposables[i];
          if (disposable.dispose) {
            disposable.dispose();
          }
        }
        this.__disposables = null;
      }
    };
    Object.defineProperty(BaseComponent2.prototype, "className", {
      /**
       * Gets the object's class name.
       */
      get: function() {
        if (!this.__className) {
          var funcNameRegex = /function (.{1,})\(/;
          var results = funcNameRegex.exec(this.constructor.toString());
          this.__className = results && results.length > 1 ? results[1] : "";
        }
        return this.__className;
      },
      enumerable: false,
      configurable: true
    });
    Object.defineProperty(BaseComponent2.prototype, "_disposables", {
      /**
       * Allows subclasses to push things to this._disposables to be auto disposed.
       */
      get: function() {
        if (!this.__disposables) {
          this.__disposables = [];
        }
        return this.__disposables;
      },
      enumerable: false,
      configurable: true
    });
    Object.defineProperty(BaseComponent2.prototype, "_async", {
      /**
       * Gets the async instance associated with the component, created on demand. The async instance gives
       * subclasses a way to execute setTimeout/setInterval async calls safely, where the callbacks
       * will be cleared/ignored automatically after unmounting. The helpers within the async object also
       * preserve the this pointer so that you don't need to "bind" the callbacks.
       */
      get: function() {
        if (!this.__async) {
          this.__async = new Async(this);
          this._disposables.push(this.__async);
        }
        return this.__async;
      },
      enumerable: false,
      configurable: true
    });
    Object.defineProperty(BaseComponent2.prototype, "_events", {
      /**
       * Gets the event group instance assocaited with the component, created on demand. The event instance
       * provides on/off methods for listening to DOM (or regular javascript object) events. The event callbacks
       * will be automatically disconnected after unmounting. The helpers within the events object also
       * preserve the this reference so that you don't need to "bind" the callbacks.
       */
      get: function() {
        if (!this.__events) {
          this.__events = new EventGroup(this);
          this._disposables.push(this.__events);
        }
        return this.__events;
      },
      enumerable: false,
      configurable: true
    });
    BaseComponent2.prototype._resolveRef = function(refName) {
      var _this = this;
      if (!this.__resolves) {
        this.__resolves = {};
      }
      if (!this.__resolves[refName]) {
        this.__resolves[refName] = function(ref) {
          return _this[refName] = ref;
        };
      }
      return this.__resolves[refName];
    };
    BaseComponent2.prototype._updateComponentRef = function(currentProps, newProps) {
      if (newProps === void 0) {
        newProps = {};
      }
      if (currentProps && newProps && currentProps.componentRef !== newProps.componentRef) {
        this._setComponentRef(currentProps.componentRef, null);
        this._setComponentRef(newProps.componentRef, this);
      }
    };
    BaseComponent2.prototype._warnDeprecations = function(deprecationMap) {
      warnDeprecations(this.className, this.props, deprecationMap);
    };
    BaseComponent2.prototype._warnMutuallyExclusive = function(mutuallyExclusiveMap) {
      warnMutuallyExclusive(this.className, this.props, mutuallyExclusiveMap);
    };
    BaseComponent2.prototype._warnConditionallyRequiredProps = function(requiredProps, conditionalPropName, condition) {
      warnConditionallyRequiredProps(this.className, this.props, requiredProps, conditionalPropName, condition);
    };
    BaseComponent2.prototype._setComponentRef = function(ref, value) {
      if (!this._skipComponentRefResolution && ref) {
        if (typeof ref === "function") {
          ref(value);
        }
        if (typeof ref === "object") {
          ref.current = value;
        }
      }
    };
    return BaseComponent2;
  }(React.Component)
);
function _makeAllSafe(obj, prototype, methodNames) {
  for (var i = 0, len = methodNames.length; i < len; i++) {
    _makeSafe(obj, prototype, methodNames[i]);
  }
}
function _makeSafe(obj, prototype, methodName) {
  var classMethod = obj[methodName];
  var prototypeMethod = prototype[methodName];
  if (classMethod || prototypeMethod) {
    obj[methodName] = function() {
      var args = [];
      for (var _i = 0; _i < arguments.length; _i++) {
        args[_i] = arguments[_i];
      }
      var retVal2;
      if (prototypeMethod) {
        retVal2 = prototypeMethod.apply(this, args);
      }
      if (classMethod !== prototypeMethod) {
        retVal2 = classMethod.apply(this, args);
      }
      return retVal2;
    };
  }
}
function nullRender() {
  return null;
}

// node_modules/@fluentui/utilities/lib/DelayedRender.js
var React2 = __toESM(require_react());
var DelayedRender = (
  /** @class */
  function(_super) {
    __extends(DelayedRender2, _super);
    function DelayedRender2(props) {
      var _this = _super.call(this, props) || this;
      _this.state = {
        isRendered: getWindow() === void 0
      };
      return _this;
    }
    DelayedRender2.prototype.componentDidMount = function() {
      var _this = this;
      var delay = this.props.delay;
      this._timeoutId = window.setTimeout(function() {
        _this.setState({
          isRendered: true
        });
      }, delay);
    };
    DelayedRender2.prototype.componentWillUnmount = function() {
      if (this._timeoutId) {
        clearTimeout(this._timeoutId);
      }
    };
    DelayedRender2.prototype.render = function() {
      return this.state.isRendered ? React2.Children.only(this.props.children) : null;
    };
    DelayedRender2.defaultProps = {
      delay: 0
    };
    return DelayedRender2;
  }(React2.Component)
);

// node_modules/@fluentui/utilities/lib/FabricPerformance.js
var now = function() {
  return typeof performance !== "undefined" && !!performance.now ? performance.now() : Date.now();
};
var RESET_INTERVAL = 3 * 60 * 1e3;
var FabricPerformance = (
  /** @class */
  function() {
    function FabricPerformance2() {
    }
    FabricPerformance2.measure = function(name, func) {
      if (FabricPerformance2._timeoutId) {
        FabricPerformance2.setPeriodicReset();
      }
      var start = now();
      func();
      var end = now();
      var measurement = FabricPerformance2.summary[name] || {
        totalDuration: 0,
        count: 0,
        all: []
      };
      var duration = end - start;
      measurement.totalDuration += duration;
      measurement.count++;
      measurement.all.push({
        duration,
        timeStamp: end
      });
      FabricPerformance2.summary[name] = measurement;
    };
    FabricPerformance2.reset = function() {
      FabricPerformance2.summary = {};
      clearTimeout(FabricPerformance2._timeoutId);
      FabricPerformance2._timeoutId = NaN;
    };
    FabricPerformance2.setPeriodicReset = function() {
      FabricPerformance2._timeoutId = setTimeout(function() {
        return FabricPerformance2.reset();
      }, RESET_INTERVAL);
    };
    FabricPerformance2.summary = {};
    return FabricPerformance2;
  }()
);

// node_modules/@fluentui/utilities/lib/GlobalSettings.js
var GLOBAL_SETTINGS_PROP_NAME = "__globalSettings__";
var CALLBACK_STATE_PROP_NAME = "__callbacks__";
var _counter = 0;
var GlobalSettings = (
  /** @class */
  function() {
    function GlobalSettings2() {
    }
    GlobalSettings2.getValue = function(key, defaultValue) {
      var globalSettings = _getGlobalSettings();
      if (globalSettings[key] === void 0) {
        globalSettings[key] = typeof defaultValue === "function" ? defaultValue() : defaultValue;
      }
      return globalSettings[key];
    };
    GlobalSettings2.setValue = function(key, value) {
      var globalSettings = _getGlobalSettings();
      var callbacks = globalSettings[CALLBACK_STATE_PROP_NAME];
      var oldValue = globalSettings[key];
      if (value !== oldValue) {
        globalSettings[key] = value;
        var changeDescription = {
          oldValue,
          value,
          key
        };
        for (var id in callbacks) {
          if (callbacks.hasOwnProperty(id)) {
            callbacks[id](changeDescription);
          }
        }
      }
      return value;
    };
    GlobalSettings2.addChangeListener = function(cb) {
      var id = cb.__id__;
      var callbacks = _getCallbacks();
      if (!id) {
        id = cb.__id__ = String(_counter++);
      }
      callbacks[id] = cb;
    };
    GlobalSettings2.removeChangeListener = function(cb) {
      var callbacks = _getCallbacks();
      delete callbacks[cb.__id__];
    };
    return GlobalSettings2;
  }()
);
function _getGlobalSettings() {
  var _a7;
  var win = getWindow();
  var globalObj = win || {};
  if (!globalObj[GLOBAL_SETTINGS_PROP_NAME]) {
    globalObj[GLOBAL_SETTINGS_PROP_NAME] = (_a7 = {}, _a7[CALLBACK_STATE_PROP_NAME] = {}, _a7);
  }
  return globalObj[GLOBAL_SETTINGS_PROP_NAME];
}
function _getCallbacks() {
  var globalSettings = _getGlobalSettings();
  return globalSettings[CALLBACK_STATE_PROP_NAME];
}

// node_modules/@fluentui/utilities/lib/KeyCodes.js
var KeyCodes = {
  backspace: 8,
  tab: 9,
  enter: 13,
  shift: 16,
  ctrl: 17,
  alt: 18,
  pauseBreak: 19,
  capslock: 20,
  escape: 27,
  space: 32,
  pageUp: 33,
  pageDown: 34,
  end: 35,
  home: 36,
  left: 37,
  up: 38,
  right: 39,
  down: 40,
  insert: 45,
  del: 46,
  zero: 48,
  one: 49,
  two: 50,
  three: 51,
  four: 52,
  five: 53,
  six: 54,
  seven: 55,
  eight: 56,
  nine: 57,
  colon: 58,
  a: 65,
  b: 66,
  c: 67,
  d: 68,
  e: 69,
  f: 70,
  g: 71,
  h: 72,
  i: 73,
  j: 74,
  k: 75,
  l: 76,
  m: 77,
  n: 78,
  o: 79,
  p: 80,
  q: 81,
  r: 82,
  s: 83,
  t: 84,
  u: 85,
  v: 86,
  w: 87,
  x: 88,
  y: 89,
  z: 90,
  leftWindow: 91,
  rightWindow: 92,
  select: 93,
  /* eslint-disable @typescript-eslint/naming-convention */
  zero_numpad: 96,
  one_numpad: 97,
  two_numpad: 98,
  three_numpad: 99,
  four_numpad: 100,
  five_numpad: 101,
  six_numpad: 102,
  seven_numpad: 103,
  eight_numpad: 104,
  nine_numpad: 105,
  /* eslint-enable @typescript-eslint/naming-convention */
  multiply: 106,
  add: 107,
  subtract: 109,
  decimalPoint: 110,
  divide: 111,
  f1: 112,
  f2: 113,
  f3: 114,
  f4: 115,
  f5: 116,
  f6: 117,
  f7: 118,
  f8: 119,
  f9: 120,
  f10: 121,
  f11: 122,
  f12: 123,
  numlock: 144,
  scrollLock: 145,
  semicolon: 186,
  equalSign: 187,
  comma: 188,
  dash: 189,
  period: 190,
  forwardSlash: 191,
  graveAccent: 192,
  openBracket: 219,
  backSlash: 220,
  closeBracket: 221,
  singleQuote: 222
};

// node_modules/@fluentui/utilities/lib/Rectangle.js
var Rectangle = (
  /** @class */
  function() {
    function Rectangle2(left, right, top, bottom) {
      if (left === void 0) {
        left = 0;
      }
      if (right === void 0) {
        right = 0;
      }
      if (top === void 0) {
        top = 0;
      }
      if (bottom === void 0) {
        bottom = 0;
      }
      this.top = top;
      this.bottom = bottom;
      this.left = left;
      this.right = right;
    }
    Object.defineProperty(Rectangle2.prototype, "width", {
      /**
       * Calculated automatically by subtracting the right from left
       */
      get: function() {
        return this.right - this.left;
      },
      enumerable: false,
      configurable: true
    });
    Object.defineProperty(Rectangle2.prototype, "height", {
      /**
       * Calculated automatically by subtracting the bottom from top.
       */
      get: function() {
        return this.bottom - this.top;
      },
      enumerable: false,
      configurable: true
    });
    Rectangle2.prototype.equals = function(rect) {
      return parseFloat(this.top.toFixed(4)) === parseFloat(rect.top.toFixed(4)) && parseFloat(this.bottom.toFixed(4)) === parseFloat(rect.bottom.toFixed(4)) && parseFloat(this.left.toFixed(4)) === parseFloat(rect.left.toFixed(4)) && parseFloat(this.right.toFixed(4)) === parseFloat(rect.right.toFixed(4));
    };
    return Rectangle2;
  }()
);

// node_modules/@fluentui/utilities/lib/appendFunction.js
function appendFunction(parent) {
  var functions = [];
  for (var _i = 1; _i < arguments.length; _i++) {
    functions[_i - 1] = arguments[_i];
  }
  if (functions.length < 2) {
    return functions[0];
  }
  return function() {
    var args = [];
    for (var _i2 = 0; _i2 < arguments.length; _i2++) {
      args[_i2] = arguments[_i2];
    }
    functions.forEach(function(f) {
      return f && f.apply(parent, args);
    });
  };
}

// node_modules/@fluentui/utilities/lib/aria.js
function mergeAriaAttributeValues() {
  var ariaAttributes = [];
  for (var _i = 0; _i < arguments.length; _i++) {
    ariaAttributes[_i] = arguments[_i];
  }
  var mergedAttribute = ariaAttributes.filter(function(arg) {
    return arg;
  }).join(" ").trim();
  return mergedAttribute === "" ? void 0 : mergedAttribute;
}

// node_modules/@fluentui/utilities/lib/array.js
function findIndex(array, cb, fromIndex) {
  if (fromIndex === void 0) {
    fromIndex = 0;
  }
  var index = -1;
  for (var i = fromIndex; array && i < array.length; i++) {
    if (cb(array[i], i)) {
      index = i;
      break;
    }
  }
  return index;
}
function addElementAtIndex(array, index, itemToAdd) {
  var copy = array.slice();
  copy.splice(index, 0, itemToAdd);
  return copy;
}
function arraysEqual(array1, array2) {
  if (array1.length !== array2.length) {
    return false;
  }
  for (var i = 0; i < array1.length; i++) {
    if (array1[i] !== array2[i]) {
      return false;
    }
  }
  return true;
}

// node_modules/@fluentui/utilities/lib/asAsync.js
var React3 = __toESM(require_react());

// node_modules/@fluentui/utilities/lib/sessionStorage.js
function getItem(key) {
  var result = null;
  try {
    var win = getWindow();
    result = win ? win.sessionStorage.getItem(key) : null;
  } catch (e) {
  }
  return result;
}
function setItem(key, data) {
  var _a7;
  try {
    (_a7 = getWindow()) === null || _a7 === void 0 ? void 0 : _a7.sessionStorage.setItem(key, data);
  } catch (e) {
  }
}

// node_modules/@fluentui/utilities/lib/rtl.js
var RTL_LOCAL_STORAGE_KEY = "isRTL";
var _isRTL;
function getRTL2(theme) {
  if (theme === void 0) {
    theme = {};
  }
  if (theme.rtl !== void 0) {
    return theme.rtl;
  }
  if (_isRTL === void 0) {
    var savedRTL = getItem(RTL_LOCAL_STORAGE_KEY);
    if (savedRTL !== null) {
      _isRTL = savedRTL === "1";
      setRTL2(_isRTL);
    }
    var doc = getDocument();
    if (_isRTL === void 0 && doc) {
      _isRTL = (doc.body && doc.body.getAttribute("dir") || doc.documentElement.getAttribute("dir")) === "rtl";
      setRTL(_isRTL);
    }
  }
  return !!_isRTL;
}
function setRTL2(isRTL, persistSetting) {
  if (persistSetting === void 0) {
    persistSetting = false;
  }
  var doc = getDocument();
  if (doc) {
    doc.documentElement.setAttribute("dir", isRTL ? "rtl" : "ltr");
  }
  if (persistSetting) {
    setItem(RTL_LOCAL_STORAGE_KEY, isRTL ? "1" : "0");
  }
  _isRTL = isRTL;
  setRTL(_isRTL);
}

// node_modules/@fluentui/utilities/lib/classNamesFunction.js
var MAX_CACHE_COUNT = 50;
var DEFAULT_SPECIFICITY_MULTIPLIER = 5;
var _memoizedClassNames = 0;
var stylesheet = Stylesheet.getInstance();
if (stylesheet && stylesheet.onReset) {
  stylesheet.onReset(function() {
    return _memoizedClassNames++;
  });
}
var retVal = "__retval__";
function classNamesFunction(options) {
  if (options === void 0) {
    options = {};
  }
  var map = /* @__PURE__ */ new Map();
  var styleCalcCount = 0;
  var getClassNamesCount = 0;
  var currentMemoizedClassNames = _memoizedClassNames;
  var getClassNames13 = function(styleFunctionOrObject, styleProps) {
    var _a7;
    if (styleProps === void 0) {
      styleProps = {};
    }
    if (options.useStaticStyles && typeof styleFunctionOrObject === "function" && styleFunctionOrObject.__noStyleOverride__) {
      return styleFunctionOrObject(styleProps);
    }
    getClassNamesCount++;
    var current = map;
    var theme = styleProps.theme;
    var rtl = theme && theme.rtl !== void 0 ? theme.rtl : getRTL2();
    var disableCaching = options.disableCaching;
    if (currentMemoizedClassNames !== _memoizedClassNames) {
      currentMemoizedClassNames = _memoizedClassNames;
      map = /* @__PURE__ */ new Map();
      styleCalcCount = 0;
    }
    if (!options.disableCaching) {
      current = _traverseMap(map, styleFunctionOrObject);
      current = _traverseMap(current, styleProps);
    }
    if (disableCaching || !current[retVal]) {
      if (styleFunctionOrObject === void 0) {
        current[retVal] = {};
      } else {
        current[retVal] = mergeCssSets([
          typeof styleFunctionOrObject === "function" ? styleFunctionOrObject(styleProps) : styleFunctionOrObject
        ], { rtl: !!rtl, specificityMultiplier: options.useStaticStyles ? DEFAULT_SPECIFICITY_MULTIPLIER : void 0 });
      }
      if (!disableCaching) {
        styleCalcCount++;
      }
    }
    if (styleCalcCount > (options.cacheSize || MAX_CACHE_COUNT)) {
      var win = getWindow();
      if ((_a7 = win === null || win === void 0 ? void 0 : win.FabricConfig) === null || _a7 === void 0 ? void 0 : _a7.enableClassNameCacheFullWarning) {
        console.warn("Styles are being recalculated too frequently. Cache miss rate is ".concat(styleCalcCount, "/").concat(getClassNamesCount, "."));
        console.trace();
      }
      map.clear();
      styleCalcCount = 0;
      options.disableCaching = true;
    }
    return current[retVal];
  };
  return getClassNames13;
}
function _traverseEdge(current, value) {
  value = _normalizeValue(value);
  if (!current.has(value)) {
    current.set(value, /* @__PURE__ */ new Map());
  }
  return current.get(value);
}
function _traverseMap(current, inputs) {
  if (typeof inputs === "function") {
    var cachedInputsFromStyled = inputs.__cachedInputs__;
    if (cachedInputsFromStyled) {
      for (var _i = 0, _a7 = inputs.__cachedInputs__; _i < _a7.length; _i++) {
        var input = _a7[_i];
        current = _traverseEdge(current, input);
      }
    } else {
      current = _traverseEdge(current, inputs);
    }
  } else if (typeof inputs === "object") {
    for (var propName in inputs) {
      if (inputs.hasOwnProperty(propName)) {
        current = _traverseEdge(current, inputs[propName]);
      }
    }
  }
  return current;
}
function _normalizeValue(value) {
  switch (value) {
    case void 0:
      return "__undefined__";
    case null:
      return "__null__";
    default:
      return value;
  }
}

// node_modules/@fluentui/utilities/lib/componentAs/composeComponentAs.js
var React4 = __toESM(require_react());

// node_modules/@fluentui/utilities/lib/memoize.js
var _initializedStylesheetResets = false;
var _resetCounter = 0;
var _emptyObject = { empty: true };
var _dictionary = {};
var _weakMap = typeof WeakMap === "undefined" ? null : WeakMap;
function resetMemoizations() {
  _resetCounter++;
}
function memoizeFunction(cb, maxCacheSize, ignoreNullOrUndefinedResult) {
  if (maxCacheSize === void 0) {
    maxCacheSize = 100;
  }
  if (ignoreNullOrUndefinedResult === void 0) {
    ignoreNullOrUndefinedResult = false;
  }
  if (!_weakMap) {
    return cb;
  }
  if (!_initializedStylesheetResets) {
    var stylesheet3 = Stylesheet.getInstance();
    if (stylesheet3 && stylesheet3.onReset) {
      Stylesheet.getInstance().onReset(resetMemoizations);
    }
    _initializedStylesheetResets = true;
  }
  var rootNode;
  var cacheSize = 0;
  var localResetCounter = _resetCounter;
  return function memoizedFunction() {
    var args = [];
    for (var _i = 0; _i < arguments.length; _i++) {
      args[_i] = arguments[_i];
    }
    var currentNode = rootNode;
    if (rootNode === void 0 || localResetCounter !== _resetCounter || maxCacheSize > 0 && cacheSize > maxCacheSize) {
      rootNode = _createNode();
      cacheSize = 0;
      localResetCounter = _resetCounter;
    }
    currentNode = rootNode;
    for (var i = 0; i < args.length; i++) {
      var arg = _normalizeArg(args[i]);
      if (!currentNode.map.has(arg)) {
        currentNode.map.set(arg, _createNode());
      }
      currentNode = currentNode.map.get(arg);
    }
    if (!currentNode.hasOwnProperty("value")) {
      currentNode.value = cb.apply(void 0, args);
      cacheSize++;
    }
    if (ignoreNullOrUndefinedResult && (currentNode.value === null || currentNode.value === void 0)) {
      currentNode.value = cb.apply(void 0, args);
    }
    return currentNode.value;
  };
}
function createMemoizer(getValue) {
  if (!_weakMap) {
    return getValue;
  }
  var cache = new _weakMap();
  function memoizedGetValue(input) {
    if (!input || typeof input !== "function" && typeof input !== "object") {
      return getValue(input);
    }
    if (cache.has(input)) {
      return cache.get(input);
    }
    var value = getValue(input);
    cache.set(input, value);
    return value;
  }
  return memoizedGetValue;
}
function _normalizeArg(val) {
  if (!val) {
    return _emptyObject;
  } else if (typeof val === "object" || typeof val === "function") {
    return val;
  } else if (!_dictionary[val]) {
    _dictionary[val] = { val };
  }
  return _dictionary[val];
}
function _createNode() {
  return {
    map: _weakMap ? new _weakMap() : null
  };
}

// node_modules/@fluentui/utilities/lib/componentAs/composeComponentAs.js
function createComposedComponent(outer) {
  var Outer = outer;
  var outerMemoizer = createMemoizer(function(inner) {
    if (outer === inner) {
      throw new Error("Attempted to compose a component with itself.");
    }
    var Inner = inner;
    var innerMemoizer = createMemoizer(function(defaultRender) {
      var InnerWithDefaultRender = function(innerProps) {
        return React4.createElement(Inner, __assign({}, innerProps, { defaultRender }));
      };
      return InnerWithDefaultRender;
    });
    var OuterWithDefaultRender = function(outerProps) {
      var defaultRender = outerProps.defaultRender;
      return React4.createElement(Outer, __assign({}, outerProps, { defaultRender: defaultRender ? innerMemoizer(defaultRender) : Inner }));
    };
    return OuterWithDefaultRender;
  });
  return outerMemoizer;
}
var componentAsMemoizer = createMemoizer(createComposedComponent);
function composeComponentAs(outer, inner) {
  return componentAsMemoizer(outer)(inner);
}

// node_modules/@fluentui/utilities/lib/controlled.js
function isControlled(props, valueProp) {
  return props[valueProp] !== void 0 && props[valueProp] !== null;
}

// node_modules/@fluentui/utilities/lib/css.js
function css() {
  var args = [];
  for (var _i = 0; _i < arguments.length; _i++) {
    args[_i] = arguments[_i];
  }
  var classes = [];
  for (var _a7 = 0, args_1 = args; _a7 < args_1.length; _a7++) {
    var arg = args_1[_a7];
    if (arg) {
      if (typeof arg === "string") {
        classes.push(arg);
      } else if (arg.hasOwnProperty("toString") && typeof arg.toString === "function") {
        classes.push(arg.toString());
      } else {
        for (var key in arg) {
          if (arg[key]) {
            classes.push(key);
          }
        }
      }
    }
  }
  return classes.join(" ");
}

// node_modules/@fluentui/utilities/lib/customizations/Customizations.js
var CustomizationsGlobalKey = "customizations";
var NO_CUSTOMIZATIONS = { settings: {}, scopedSettings: {}, inCustomizerContext: false };
var _allSettings = GlobalSettings.getValue(CustomizationsGlobalKey, {
  settings: {},
  scopedSettings: {},
  inCustomizerContext: false
});
var _events = [];
var Customizations = (
  /** @class */
  function() {
    function Customizations2() {
    }
    Customizations2.reset = function() {
      _allSettings.settings = {};
      _allSettings.scopedSettings = {};
    };
    Customizations2.applySettings = function(settings) {
      _allSettings.settings = __assign(__assign({}, _allSettings.settings), settings);
      Customizations2._raiseChange();
    };
    Customizations2.applyScopedSettings = function(scopeName, settings) {
      _allSettings.scopedSettings[scopeName] = __assign(__assign({}, _allSettings.scopedSettings[scopeName]), settings);
      Customizations2._raiseChange();
    };
    Customizations2.getSettings = function(properties, scopeName, localSettings) {
      if (localSettings === void 0) {
        localSettings = NO_CUSTOMIZATIONS;
      }
      var settings = {};
      var localScopedSettings = scopeName && localSettings.scopedSettings[scopeName] || {};
      var globalScopedSettings = scopeName && _allSettings.scopedSettings[scopeName] || {};
      for (var _i = 0, properties_1 = properties; _i < properties_1.length; _i++) {
        var property = properties_1[_i];
        settings[property] = localScopedSettings[property] || localSettings.settings[property] || globalScopedSettings[property] || _allSettings.settings[property];
      }
      return settings;
    };
    Customizations2.applyBatchedUpdates = function(code, suppressUpdate) {
      Customizations2._suppressUpdates = true;
      try {
        code();
      } catch (_a7) {
      }
      Customizations2._suppressUpdates = false;
      if (!suppressUpdate) {
        Customizations2._raiseChange();
      }
    };
    Customizations2.observe = function(onChange) {
      _events.push(onChange);
    };
    Customizations2.unobserve = function(onChange) {
      _events = _events.filter(function(cb) {
        return cb !== onChange;
      });
    };
    Customizations2._raiseChange = function() {
      if (!Customizations2._suppressUpdates) {
        _events.forEach(function(cb) {
          return cb();
        });
      }
    };
    return Customizations2;
  }()
);

// node_modules/@fluentui/utilities/lib/customizations/Customizer.js
var React6 = __toESM(require_react());

// node_modules/@fluentui/utilities/lib/customizations/CustomizerContext.js
var React5 = __toESM(require_react());
var CustomizerContext = React5.createContext({
  customizations: {
    inCustomizerContext: false,
    settings: {},
    scopedSettings: {}
  }
});

// node_modules/@fluentui/utilities/lib/customizations/mergeSettings.js
function mergeSettings(oldSettings, newSettings) {
  if (oldSettings === void 0) {
    oldSettings = {};
  }
  var mergeSettingsWith = _isSettingsFunction(newSettings) ? newSettings : _settingsMergeWith(newSettings);
  return mergeSettingsWith(oldSettings);
}
function mergeScopedSettings(oldSettings, newSettings) {
  if (oldSettings === void 0) {
    oldSettings = {};
  }
  var mergeSettingsWith = _isSettingsFunction(newSettings) ? newSettings : _scopedSettingsMergeWith(newSettings);
  return mergeSettingsWith(oldSettings);
}
function _isSettingsFunction(settings) {
  return typeof settings === "function";
}
function _settingsMergeWith(newSettings) {
  return function(settings) {
    return newSettings ? __assign(__assign({}, settings), newSettings) : settings;
  };
}
function _scopedSettingsMergeWith(scopedSettingsFromProps) {
  if (scopedSettingsFromProps === void 0) {
    scopedSettingsFromProps = {};
  }
  return function(oldScopedSettings) {
    var newScopedSettings = __assign({}, oldScopedSettings);
    for (var scopeName in scopedSettingsFromProps) {
      if (scopedSettingsFromProps.hasOwnProperty(scopeName)) {
        newScopedSettings[scopeName] = __assign(__assign({}, oldScopedSettings[scopeName]), scopedSettingsFromProps[scopeName]);
      }
    }
    return newScopedSettings;
  };
}

// node_modules/@fluentui/utilities/lib/customizations/mergeCustomizations.js
function mergeCustomizations(props, parentContext) {
  var _a7 = (parentContext || {}).customizations, customizations = _a7 === void 0 ? { settings: {}, scopedSettings: {} } : _a7;
  return {
    customizations: {
      settings: mergeSettings(customizations.settings, props.settings),
      scopedSettings: mergeScopedSettings(customizations.scopedSettings, props.scopedSettings),
      inCustomizerContext: true
    }
  };
}

// node_modules/@fluentui/utilities/lib/customizations/Customizer.js
var Customizer = (
  /** @class */
  function(_super) {
    __extends(Customizer2, _super);
    function Customizer2() {
      var _this = _super !== null && _super.apply(this, arguments) || this;
      _this._onCustomizationChange = function() {
        return _this.forceUpdate();
      };
      return _this;
    }
    Customizer2.prototype.componentDidMount = function() {
      Customizations.observe(this._onCustomizationChange);
    };
    Customizer2.prototype.componentWillUnmount = function() {
      Customizations.unobserve(this._onCustomizationChange);
    };
    Customizer2.prototype.render = function() {
      var _this = this;
      var contextTransform = this.props.contextTransform;
      return React6.createElement(CustomizerContext.Consumer, null, function(parentContext) {
        var newContext = mergeCustomizations(_this.props, parentContext);
        if (contextTransform) {
          newContext = contextTransform(newContext);
        }
        return React6.createElement(CustomizerContext.Provider, { value: newContext }, _this.props.children);
      });
    };
    return Customizer2;
  }(React6.Component)
);

// node_modules/@fluentui/utilities/lib/customizations/customizable.js
var React7 = __toESM(require_react());

// node_modules/@fluentui/utilities/lib/hoistStatics.js
function hoistStatics(source, dest) {
  for (var name_1 in source) {
    if (source.hasOwnProperty(name_1)) {
      dest[name_1] = source[name_1];
    }
  }
  return dest;
}

// node_modules/@fluentui/utilities/lib/customizations/customizable.js
function customizable(scope, fields, concatStyles) {
  return function customizableFactory(ComposedComponent) {
    var _a7;
    var resultClass = (_a7 = /** @class */
    function(_super) {
      __extends(ComponentWithInjectedProps, _super);
      function ComponentWithInjectedProps(props) {
        var _this = _super.call(this, props) || this;
        _this._styleCache = {};
        _this._onSettingChanged = _this._onSettingChanged.bind(_this);
        return _this;
      }
      ComponentWithInjectedProps.prototype.componentDidMount = function() {
        Customizations.observe(this._onSettingChanged);
      };
      ComponentWithInjectedProps.prototype.componentWillUnmount = function() {
        Customizations.unobserve(this._onSettingChanged);
      };
      ComponentWithInjectedProps.prototype.render = function() {
        var _this = this;
        return React7.createElement(CustomizerContext.Consumer, null, function(context) {
          var defaultProps = Customizations.getSettings(fields, scope, context.customizations);
          var componentProps = _this.props;
          if (defaultProps.styles && typeof defaultProps.styles === "function") {
            defaultProps.styles = defaultProps.styles(__assign(__assign({}, defaultProps), componentProps));
          }
          if (concatStyles && defaultProps.styles) {
            if (_this._styleCache.default !== defaultProps.styles || _this._styleCache.component !== componentProps.styles) {
              var mergedStyles = concatStyleSets(defaultProps.styles, componentProps.styles);
              _this._styleCache.default = defaultProps.styles;
              _this._styleCache.component = componentProps.styles;
              _this._styleCache.merged = mergedStyles;
            }
            return React7.createElement(ComposedComponent, __assign({}, defaultProps, componentProps, { styles: _this._styleCache.merged }));
          }
          return React7.createElement(ComposedComponent, __assign({}, defaultProps, componentProps));
        });
      };
      ComponentWithInjectedProps.prototype._onSettingChanged = function() {
        this.forceUpdate();
      };
      return ComponentWithInjectedProps;
    }(React7.Component), _a7.displayName = "Customized" + scope, _a7);
    return hoistStatics(ComposedComponent, resultClass);
  };
}

// node_modules/@fluentui/utilities/lib/customizations/useCustomizationSettings.js
var React8 = __toESM(require_react());
function useCustomizationSettings(properties, scopeName) {
  var forceUpdate = useForceUpdate();
  var customizations = React8.useContext(CustomizerContext).customizations;
  var inCustomizerContext = customizations.inCustomizerContext;
  React8.useEffect(function() {
    if (!inCustomizerContext) {
      Customizations.observe(forceUpdate);
    }
    return function() {
      if (!inCustomizerContext) {
        Customizations.unobserve(forceUpdate);
      }
    };
  }, [inCustomizerContext]);
  return Customizations.getSettings(properties, scopeName, customizations);
}
function useForceUpdate() {
  var _a7 = React8.useState(0), setValue = _a7[1];
  return function() {
    return setValue(function(value) {
      return ++value;
    });
  };
}

// node_modules/@fluentui/utilities/lib/extendComponent.js
function extendComponent(parent, methods) {
  for (var name_1 in methods) {
    if (methods.hasOwnProperty(name_1)) {
      parent[name_1] = appendFunction(parent, parent[name_1], methods[name_1]);
    }
  }
}

// node_modules/@fluentui/utilities/lib/getId.js
var CURRENT_ID_PROPERTY = "__currentId__";
var DEFAULT_ID_STRING = "id__";
var _global2 = getWindow() || {};
if (_global2[CURRENT_ID_PROPERTY] === void 0) {
  _global2[CURRENT_ID_PROPERTY] = 0;
}
var _initializedStylesheetResets2 = false;
function getId(prefix) {
  if (!_initializedStylesheetResets2) {
    var stylesheet3 = Stylesheet.getInstance();
    if (stylesheet3 && stylesheet3.onReset) {
      stylesheet3.onReset(resetIds);
    }
    _initializedStylesheetResets2 = true;
  }
  var index = _global2[CURRENT_ID_PROPERTY]++;
  return (prefix === void 0 ? DEFAULT_ID_STRING : prefix) + index;
}
function resetIds(counter) {
  if (counter === void 0) {
    counter = 0;
  }
  _global2[CURRENT_ID_PROPERTY] = counter;
}

// node_modules/@fluentui/utilities/lib/properties.js
var toObjectMap = function() {
  var items = [];
  for (var _i = 0; _i < arguments.length; _i++) {
    items[_i] = arguments[_i];
  }
  var result = {};
  for (var _a7 = 0, items_1 = items; _a7 < items_1.length; _a7++) {
    var item = items_1[_a7];
    var keys = Array.isArray(item) ? item : Object.keys(item);
    for (var _b3 = 0, keys_1 = keys; _b3 < keys_1.length; _b3++) {
      var key = keys_1[_b3];
      result[key] = 1;
    }
  }
  return result;
};
var baseElementEvents = toObjectMap([
  "onCopy",
  "onCut",
  "onPaste",
  "onCompositionEnd",
  "onCompositionStart",
  "onCompositionUpdate",
  "onFocus",
  "onFocusCapture",
  "onBlur",
  "onBlurCapture",
  "onChange",
  "onInput",
  "onSubmit",
  "onLoad",
  "onError",
  "onKeyDown",
  "onKeyDownCapture",
  "onKeyPress",
  "onKeyUp",
  "onAbort",
  "onCanPlay",
  "onCanPlayThrough",
  "onDurationChange",
  "onEmptied",
  "onEncrypted",
  "onEnded",
  "onLoadedData",
  "onLoadedMetadata",
  "onLoadStart",
  "onPause",
  "onPlay",
  "onPlaying",
  "onProgress",
  "onRateChange",
  "onSeeked",
  "onSeeking",
  "onStalled",
  "onSuspend",
  "onTimeUpdate",
  "onVolumeChange",
  "onWaiting",
  "onClick",
  "onClickCapture",
  "onContextMenu",
  "onDoubleClick",
  "onDrag",
  "onDragEnd",
  "onDragEnter",
  "onDragExit",
  "onDragLeave",
  "onDragOver",
  "onDragStart",
  "onDrop",
  "onMouseDown",
  "onMouseDownCapture",
  "onMouseEnter",
  "onMouseLeave",
  "onMouseMove",
  "onMouseOut",
  "onMouseOver",
  "onMouseUp",
  "onMouseUpCapture",
  "onSelect",
  "onTouchCancel",
  "onTouchEnd",
  "onTouchMove",
  "onTouchStart",
  "onScroll",
  "onWheel",
  "onPointerCancel",
  "onPointerDown",
  "onPointerEnter",
  "onPointerLeave",
  "onPointerMove",
  "onPointerOut",
  "onPointerOver",
  "onPointerUp",
  "onGotPointerCapture",
  "onLostPointerCapture"
]);
var baseElementProperties = toObjectMap([
  "accessKey",
  "children",
  "className",
  "contentEditable",
  "dir",
  "draggable",
  "hidden",
  "htmlFor",
  "id",
  "lang",
  "ref",
  "role",
  "style",
  "tabIndex",
  "title",
  "translate",
  "spellCheck",
  "name"
  // global
]);
var htmlElementProperties = toObjectMap(baseElementProperties, baseElementEvents);
var labelProperties = toObjectMap(htmlElementProperties, [
  "form"
  // button, fieldset, input, label, meter, object, output, select, textarea
]);
var audioProperties = toObjectMap(htmlElementProperties, [
  "height",
  "loop",
  "muted",
  "preload",
  "src",
  "width"
  // canvas, embed, iframe, img, input, object, video
]);
var videoProperties = toObjectMap(audioProperties, [
  "poster"
  // video
]);
var olProperties = toObjectMap(htmlElementProperties, [
  "start"
  // ol
]);
var liProperties = toObjectMap(htmlElementProperties, [
  "value"
  // button, input, li, option, meter, progress, param
]);
var anchorProperties = toObjectMap(htmlElementProperties, [
  "download",
  "href",
  "hrefLang",
  "media",
  "rel",
  "target",
  "type"
  // a, button, input, link, menu, object, script, source, style
]);
var buttonProperties = toObjectMap(htmlElementProperties, [
  "autoFocus",
  "disabled",
  "form",
  "formAction",
  "formEncType",
  "formMethod",
  "formNoValidate",
  "formTarget",
  "type",
  "value"
  // button, input, li, option, meter, progress, param,
]);
var inputProperties = toObjectMap(buttonProperties, [
  "accept",
  "alt",
  "autoCapitalize",
  "autoComplete",
  "checked",
  "dirname",
  "form",
  "height",
  "inputMode",
  "list",
  "max",
  "maxLength",
  "min",
  "minLength",
  "multiple",
  "pattern",
  "placeholder",
  "readOnly",
  "required",
  "src",
  "step",
  "size",
  "type",
  "value",
  "width"
  // canvas, embed, iframe, img, input, object, video
]);
var textAreaProperties = toObjectMap(buttonProperties, [
  "autoCapitalize",
  "cols",
  "dirname",
  "form",
  "maxLength",
  "minLength",
  "placeholder",
  "readOnly",
  "required",
  "rows",
  "wrap"
  // textarea
]);
var selectProperties = toObjectMap(buttonProperties, [
  "form",
  "multiple",
  "required"
  // input, select, textarea
]);
var optionProperties = toObjectMap(htmlElementProperties, [
  "selected",
  "value"
  // button, input, li, option, meter, progress, param
]);
var tableProperties = toObjectMap(htmlElementProperties, [
  "cellPadding",
  "cellSpacing"
  // table
]);
var thProperties = toObjectMap(htmlElementProperties, [
  "rowSpan",
  "scope"
  // th
]);
var tdProperties = toObjectMap(htmlElementProperties, [
  "colSpan",
  "headers",
  "rowSpan",
  "scope"
  // th
]);
var colGroupProperties = toObjectMap(htmlElementProperties, [
  "span"
  // col, colgroup
]);
var colProperties = toObjectMap(htmlElementProperties, [
  "span"
  // col, colgroup
]);
var formProperties = toObjectMap(htmlElementProperties, [
  "acceptCharset",
  "action",
  "encType",
  "encType",
  "method",
  "noValidate",
  "target"
  // form
]);
var iframeProperties = toObjectMap(htmlElementProperties, [
  "allow",
  "allowFullScreen",
  "allowPaymentRequest",
  "allowTransparency",
  "csp",
  "height",
  "importance",
  "referrerPolicy",
  "sandbox",
  "src",
  "srcDoc",
  "width"
  // canvas, embed, iframe, img, input, object, video,
]);
var imgProperties = toObjectMap(htmlElementProperties, [
  "alt",
  "crossOrigin",
  "height",
  "src",
  "srcSet",
  "useMap",
  "width"
  // canvas, embed, iframe, img, input, object, video
]);
var divProperties = htmlElementProperties;
function getNativeProps(props, allowedPropNames, excludedPropNames) {
  var isArray = Array.isArray(allowedPropNames);
  var result = {};
  var keys = Object.keys(props);
  for (var _i = 0, keys_2 = keys; _i < keys_2.length; _i++) {
    var key = keys_2[_i];
    var isNativeProp = !isArray && allowedPropNames[key] || isArray && allowedPropNames.indexOf(key) >= 0 || key.indexOf("data-") === 0 || key.indexOf("aria-") === 0;
    if (isNativeProp && (!excludedPropNames || (excludedPropNames === null || excludedPropNames === void 0 ? void 0 : excludedPropNames.indexOf(key)) === -1)) {
      result[key] = props[key];
    }
  }
  return result;
}

// node_modules/@fluentui/utilities/lib/hoist.js
var REACT_LIFECYCLE_EXCLUSIONS = [
  "setState",
  "render",
  "componentWillMount",
  "UNSAFE_componentWillMount",
  "componentDidMount",
  "componentWillReceiveProps",
  "UNSAFE_componentWillReceiveProps",
  "shouldComponentUpdate",
  "componentWillUpdate",
  "getSnapshotBeforeUpdate",
  "UNSAFE_componentWillUpdate",
  "componentDidUpdate",
  "componentWillUnmount"
];
function hoistMethods(destination, source, exclusions) {
  if (exclusions === void 0) {
    exclusions = REACT_LIFECYCLE_EXCLUSIONS;
  }
  var hoisted = [];
  var _loop_1 = function(methodName2) {
    if (typeof source[methodName2] === "function" && destination[methodName2] === void 0 && (!exclusions || exclusions.indexOf(methodName2) === -1)) {
      hoisted.push(methodName2);
      destination[methodName2] = function() {
        var args = [];
        for (var _i = 0; _i < arguments.length; _i++) {
          args[_i] = arguments[_i];
        }
        source[methodName2].apply(source, args);
      };
    }
  };
  for (var methodName in source) {
    _loop_1(methodName);
  }
  return hoisted;
}
function unhoistMethods(source, methodNames) {
  methodNames.forEach(function(methodName) {
    return delete source[methodName];
  });
}

// node_modules/@fluentui/utilities/lib/initializeComponentRef.js
function initializeComponentRef(obj) {
  extendComponent(obj, {
    componentDidMount: _onMount,
    componentDidUpdate: _onUpdate,
    componentWillUnmount: _onUnmount
  });
}
function _onMount() {
  _setComponentRef(this.props.componentRef, this);
}
function _onUpdate(prevProps) {
  if (prevProps.componentRef !== this.props.componentRef) {
    _setComponentRef(prevProps.componentRef, null);
    _setComponentRef(this.props.componentRef, this);
  }
}
function _onUnmount() {
  _setComponentRef(this.props.componentRef, null);
}
function _setComponentRef(componentRef, value) {
  if (componentRef) {
    if (typeof componentRef === "object") {
      componentRef.current = value;
    } else if (typeof componentRef === "function") {
      componentRef(value);
    }
  }
}

// node_modules/@fluentui/utilities/lib/keyboard.js
var _a2;
var DirectionalKeyCodes = (_a2 = {}, _a2[KeyCodes.up] = 1, _a2[KeyCodes.down] = 1, _a2[KeyCodes.left] = 1, _a2[KeyCodes.right] = 1, _a2[KeyCodes.home] = 1, _a2[KeyCodes.end] = 1, _a2[KeyCodes.tab] = 1, _a2[KeyCodes.pageUp] = 1, _a2[KeyCodes.pageDown] = 1, _a2);
function isDirectionalKeyCode(which) {
  return !!DirectionalKeyCodes[which];
}

// node_modules/@fluentui/utilities/lib/setFocusVisibility.js
var IsFocusVisibleClassName = "ms-Fabric--isFocusVisible";
var IsFocusHiddenClassName = "ms-Fabric--isFocusHidden";
function updateClassList(el, enabled) {
  if (el) {
    el.classList.add(enabled ? IsFocusVisibleClassName : IsFocusHiddenClassName);
    el.classList.remove(enabled ? IsFocusHiddenClassName : IsFocusVisibleClassName);
  }
}
function setFocusVisibility(enabled, target, registeredProviders) {
  var _a7;
  if (registeredProviders) {
    registeredProviders.forEach(function(ref) {
      return updateClassList(ref.current, enabled);
    });
  } else {
    updateClassList((_a7 = getWindow(target)) === null || _a7 === void 0 ? void 0 : _a7.document.body, enabled);
  }
}

// node_modules/@fluentui/utilities/lib/FocusRectsProvider.js
var React10 = __toESM(require_react());

// node_modules/@fluentui/utilities/lib/useFocusRects.js
var React9 = __toESM(require_react());
var mountCounters = /* @__PURE__ */ new WeakMap();
var callbackMap = /* @__PURE__ */ new WeakMap();
function setMountCounters(key, delta) {
  var newValue;
  var currValue = mountCounters.get(key);
  if (currValue) {
    newValue = currValue + delta;
  } else {
    newValue = 1;
  }
  mountCounters.set(key, newValue);
  return newValue;
}
function setCallbackMap(context) {
  var callbacks = callbackMap.get(context);
  if (callbacks) {
    return callbacks;
  }
  var onMouseDown = function(ev) {
    return _onMouseDown(ev, context.registeredProviders);
  };
  var onPointerDown = function(ev) {
    return _onPointerDown(ev, context.registeredProviders);
  };
  var onKeyDown = function(ev) {
    return _onKeyDown(ev, context.registeredProviders);
  };
  var onKeyUp = function(ev) {
    return _onKeyUp(ev, context.registeredProviders);
  };
  callbacks = { onMouseDown, onPointerDown, onKeyDown, onKeyUp };
  callbackMap.set(context, callbacks);
  return callbacks;
}
var FocusRectsContext = React9.createContext(void 0);
function useFocusRects(rootRef) {
  var context = React9.useContext(FocusRectsContext);
  React9.useEffect(function() {
    var _a7, _b3, _c3, _d3;
    var win = getWindow(rootRef === null || rootRef === void 0 ? void 0 : rootRef.current);
    if (!win || ((_a7 = win.FabricConfig) === null || _a7 === void 0 ? void 0 : _a7.disableFocusRects) === true) {
      return void 0;
    }
    var el = win;
    var onMouseDown;
    var onPointerDown;
    var onKeyDown;
    var onKeyUp;
    if (((_b3 = context === null || context === void 0 ? void 0 : context.providerRef) === null || _b3 === void 0 ? void 0 : _b3.current) && ((_d3 = (_c3 = context === null || context === void 0 ? void 0 : context.providerRef) === null || _c3 === void 0 ? void 0 : _c3.current) === null || _d3 === void 0 ? void 0 : _d3.addEventListener)) {
      el = context.providerRef.current;
      var callbacks = (
        /*@__NOINLINE__*/
        setCallbackMap(context)
      );
      onMouseDown = callbacks.onMouseDown;
      onPointerDown = callbacks.onPointerDown;
      onKeyDown = callbacks.onKeyDown;
      onKeyUp = callbacks.onKeyUp;
    } else {
      onMouseDown = _onMouseDown;
      onPointerDown = _onPointerDown;
      onKeyDown = _onKeyDown;
      onKeyUp = _onKeyUp;
    }
    var count = setMountCounters(el, 1);
    if (count <= 1) {
      el.addEventListener("mousedown", onMouseDown, true);
      el.addEventListener("pointerdown", onPointerDown, true);
      el.addEventListener("keydown", onKeyDown, true);
      el.addEventListener("keyup", onKeyUp, true);
    }
    return function() {
      var _a8;
      if (!win || ((_a8 = win.FabricConfig) === null || _a8 === void 0 ? void 0 : _a8.disableFocusRects) === true) {
        return;
      }
      count = setMountCounters(el, -1);
      if (count === 0) {
        el.removeEventListener("mousedown", onMouseDown, true);
        el.removeEventListener("pointerdown", onPointerDown, true);
        el.removeEventListener("keydown", onKeyDown, true);
        el.removeEventListener("keyup", onKeyUp, true);
      }
    };
  }, [context, rootRef]);
}
var FocusRects = function(props) {
  useFocusRects(props.rootRef);
  return null;
};
function _onMouseDown(ev, registeredProviders) {
  setFocusVisibility(false, ev.target, registeredProviders);
}
function _onPointerDown(ev, registeredProviders) {
  if (ev.pointerType !== "mouse") {
    setFocusVisibility(false, ev.target, registeredProviders);
  }
}
function _onKeyDown(ev, registeredProviders) {
  if (isDirectionalKeyCode(ev.which)) {
    setFocusVisibility(true, ev.target, registeredProviders);
  }
}
function _onKeyUp(ev, registeredProviders) {
  if (isDirectionalKeyCode(ev.which)) {
    setFocusVisibility(true, ev.target, registeredProviders);
  }
}

// node_modules/@fluentui/utilities/lib/FocusRectsProvider.js
var FocusRectsProvider = function(props) {
  var providerRef = props.providerRef, layerRoot = props.layerRoot;
  var registeredProviders = React10.useState([])[0];
  var parentContext = React10.useContext(FocusRectsContext);
  var inheritParentContext = parentContext !== void 0 && !layerRoot;
  var context = React10.useMemo(function() {
    return inheritParentContext ? void 0 : {
      providerRef,
      registeredProviders,
      registerProvider: function(ref) {
        registeredProviders.push(ref);
        parentContext === null || parentContext === void 0 ? void 0 : parentContext.registerProvider(ref);
      },
      unregisterProvider: function(ref) {
        parentContext === null || parentContext === void 0 ? void 0 : parentContext.unregisterProvider(ref);
        var i = registeredProviders.indexOf(ref);
        if (i >= 0) {
          registeredProviders.splice(i, 1);
        }
      }
    };
  }, [providerRef, registeredProviders, parentContext, inheritParentContext]);
  React10.useEffect(function() {
    if (context) {
      context.registerProvider(context.providerRef);
      return function() {
        return context.unregisterProvider(context.providerRef);
      };
    }
  }, [context]);
  if (context) {
    return React10.createElement(FocusRectsContext.Provider, { value: context }, props.children);
  } else {
    return React10.createElement(React10.Fragment, null, props.children);
  }
};

// node_modules/@fluentui/utilities/lib/localStorage.js
function getItem2(key) {
  var result = null;
  try {
    var win = getWindow();
    result = win ? win.localStorage.getItem(key) : null;
  } catch (e) {
  }
  return result;
}

// node_modules/@fluentui/utilities/lib/language.js
var _language;
var STORAGE_KEY = "language";
function getLanguage(persistenceType) {
  if (persistenceType === void 0) {
    persistenceType = "sessionStorage";
  }
  if (_language === void 0) {
    var doc = getDocument();
    var savedLanguage = persistenceType === "localStorage" ? getItem2(STORAGE_KEY) : persistenceType === "sessionStorage" ? getItem(STORAGE_KEY) : void 0;
    if (savedLanguage) {
      _language = savedLanguage;
    }
    if (_language === void 0 && doc) {
      _language = doc.documentElement.getAttribute("lang");
    }
    if (_language === void 0) {
      _language = "en";
    }
  }
  return _language;
}

// node_modules/@fluentui/utilities/lib/merge.js
function merge(target) {
  var args = [];
  for (var _i = 1; _i < arguments.length; _i++) {
    args[_i - 1] = arguments[_i];
  }
  for (var _a7 = 0, args_1 = args; _a7 < args_1.length; _a7++) {
    var arg = args_1[_a7];
    _merge(target || {}, arg);
  }
  return target;
}
function _merge(target, source, circularReferences) {
  if (circularReferences === void 0) {
    circularReferences = [];
  }
  circularReferences.push(source);
  for (var name_1 in source) {
    if (source.hasOwnProperty(name_1)) {
      if (name_1 !== "__proto__" && name_1 !== "constructor" && name_1 !== "prototype") {
        var value = source[name_1];
        if (typeof value === "object" && value !== null && !Array.isArray(value)) {
          var isCircularReference = circularReferences.indexOf(value) > -1;
          target[name_1] = isCircularReference ? value : _merge(target[name_1] || {}, value, circularReferences);
        } else {
          target[name_1] = value;
        }
      }
    }
  }
  circularReferences.pop();
  return target;
}

// node_modules/@fluentui/utilities/lib/mobileDetector.js
var isIOS = function() {
  if (!window || !window.navigator || !window.navigator.userAgent) {
    return false;
  }
  return /iPad|iPhone|iPod/i.test(window.navigator.userAgent);
};

// node_modules/@fluentui/utilities/lib/modalize.js
var tagsToIgnore = ["TEMPLATE", "STYLE", "SCRIPT"];
function modalize(target) {
  var targetDocument = getDocument(target);
  if (!targetDocument) {
    return function() {
      return void 0;
    };
  }
  var affectedNodes = [];
  while (target !== targetDocument.body && target.parentElement) {
    for (var _i = 0, _a7 = target.parentElement.children; _i < _a7.length; _i++) {
      var sibling = _a7[_i];
      var ariaHidden = sibling.getAttribute("aria-hidden");
      if (sibling !== target && (ariaHidden === null || ariaHidden === void 0 ? void 0 : ariaHidden.toLowerCase()) !== "true" && tagsToIgnore.indexOf(sibling.tagName) === -1) {
        affectedNodes.push([sibling, ariaHidden]);
      }
    }
    target = target.parentElement;
  }
  affectedNodes.forEach(function(_a8) {
    var node = _a8[0];
    node.setAttribute("aria-hidden", "true");
  });
  return function() {
    unmodalize(affectedNodes);
    affectedNodes = [];
  };
}
function unmodalize(affectedNodes) {
  affectedNodes.forEach(function(_a7) {
    var node = _a7[0], originalValue = _a7[1];
    if (originalValue) {
      node.setAttribute("aria-hidden", originalValue);
    } else {
      node.removeAttribute("aria-hidden");
    }
  });
}

// node_modules/@fluentui/utilities/lib/osDetector.js
var isMacResult;
function isMac(reset) {
  var _a7;
  if (typeof isMacResult === "undefined" || reset) {
    var win = getWindow();
    var userAgent = (_a7 = win === null || win === void 0 ? void 0 : win.navigator) === null || _a7 === void 0 ? void 0 : _a7.userAgent;
    isMacResult = !!userAgent && userAgent.indexOf("Macintosh") !== -1;
  }
  return !!isMacResult;
}

// node_modules/@fluentui/utilities/lib/renderFunction/composeRenderFunction.js
function createComposedRenderFunction(outer) {
  var outerMemoizer = createMemoizer(function(inner) {
    var innerMemoizer = createMemoizer(function(defaultRender) {
      return function(innerProps) {
        return inner(innerProps, defaultRender);
      };
    });
    return function(outerProps, defaultRender) {
      return outer(outerProps, defaultRender ? innerMemoizer(defaultRender) : inner);
    };
  });
  return outerMemoizer;
}
var memoizer = createMemoizer(createComposedRenderFunction);
function composeRenderFunction(outer, inner) {
  return memoizer(outer)(inner);
}

// node_modules/@fluentui/utilities/lib/safeRequestAnimationFrame.js
var safeRequestAnimationFrame = function(component) {
  var activeTimeouts;
  return function(cb) {
    if (!activeTimeouts) {
      activeTimeouts = /* @__PURE__ */ new Set();
      extendComponent(component, {
        componentWillUnmount: function() {
          activeTimeouts.forEach(function(id) {
            return cancelAnimationFrame(id);
          });
        }
      });
    }
    var timeoutId = requestAnimationFrame(function() {
      activeTimeouts.delete(timeoutId);
      cb();
    });
    activeTimeouts.add(timeoutId);
  };
};

// node_modules/@fluentui/utilities/lib/selection/Selection.types.js
var SELECTION_CHANGE = "change";
var SELECTION_ITEMS_CHANGE = "items-change";
var SelectionMode;
(function(SelectionMode2) {
  SelectionMode2[SelectionMode2["none"] = 0] = "none";
  SelectionMode2[SelectionMode2["single"] = 1] = "single";
  SelectionMode2[SelectionMode2["multiple"] = 2] = "multiple";
})(SelectionMode || (SelectionMode = {}));
var SelectionDirection;
(function(SelectionDirection2) {
  SelectionDirection2[SelectionDirection2["horizontal"] = 0] = "horizontal";
  SelectionDirection2[SelectionDirection2["vertical"] = 1] = "vertical";
})(SelectionDirection || (SelectionDirection = {}));

// node_modules/@fluentui/utilities/lib/selection/Selection.js
var Selection = (
  /** @class */
  function() {
    function Selection2() {
      var options = [];
      for (var _i = 0; _i < arguments.length; _i++) {
        options[_i] = arguments[_i];
      }
      var _a7 = options[0] || {}, onSelectionChanged = _a7.onSelectionChanged, onItemsChanged = _a7.onItemsChanged, getKey = _a7.getKey, _b3 = _a7.canSelectItem, canSelectItem = _b3 === void 0 ? function() {
        return true;
      } : _b3, items = _a7.items, _c3 = _a7.selectionMode, selectionMode = _c3 === void 0 ? SelectionMode.multiple : _c3;
      this.mode = selectionMode;
      this._getKey = getKey || defaultGetKey;
      this._changeEventSuppressionCount = 0;
      this._exemptedCount = 0;
      this._anchoredIndex = 0;
      this._unselectableCount = 0;
      this._onSelectionChanged = onSelectionChanged;
      this._onItemsChanged = onItemsChanged;
      this._canSelectItem = canSelectItem;
      this._keyToIndexMap = {};
      this._isModal = false;
      this.setItems(items || [], true);
      this.count = this.getSelectedCount();
    }
    Selection2.prototype.canSelectItem = function(item, index) {
      if (typeof index === "number" && index < 0) {
        return false;
      }
      return this._canSelectItem(item, index);
    };
    Selection2.prototype.getKey = function(item, index) {
      var key = this._getKey(item, index);
      return typeof key === "number" || key ? "".concat(key) : "";
    };
    Selection2.prototype.setChangeEvents = function(isEnabled, suppressChange) {
      this._changeEventSuppressionCount += isEnabled ? -1 : 1;
      if (this._changeEventSuppressionCount === 0 && this._hasChanged) {
        this._hasChanged = false;
        if (!suppressChange) {
          this._change();
        }
      }
    };
    Selection2.prototype.isModal = function() {
      return this._isModal;
    };
    Selection2.prototype.setModal = function(isModal) {
      if (this._isModal !== isModal) {
        this.setChangeEvents(false);
        this._isModal = isModal;
        if (!isModal) {
          this.setAllSelected(false);
        }
        this._change();
        this.setChangeEvents(true);
      }
    };
    Selection2.prototype.setItems = function(items, shouldClear) {
      if (shouldClear === void 0) {
        shouldClear = true;
      }
      var newKeyToIndexMap = {};
      var newUnselectableIndices = {};
      var hasSelectionChanged = false;
      this.setChangeEvents(false);
      this._unselectableCount = 0;
      var haveItemsChanged = false;
      for (var i = 0; i < items.length; i++) {
        var item = items[i];
        if (item) {
          var key = this.getKey(item, i);
          if (key) {
            if (!haveItemsChanged && (!(key in this._keyToIndexMap) || this._keyToIndexMap[key] !== i)) {
              haveItemsChanged = true;
            }
            newKeyToIndexMap[key] = i;
          }
        }
        newUnselectableIndices[i] = item && !this.canSelectItem(item);
        if (newUnselectableIndices[i]) {
          this._unselectableCount++;
        }
      }
      if (shouldClear || items.length === 0) {
        this._setAllSelected(false, true);
      }
      var newExemptedIndicies = {};
      var newExemptedCount = 0;
      for (var indexProperty in this._exemptedIndices) {
        if (this._exemptedIndices.hasOwnProperty(indexProperty)) {
          var index = Number(indexProperty);
          var item = this._items[index];
          var exemptKey = item ? this.getKey(item, Number(index)) : void 0;
          var newIndex = exemptKey ? newKeyToIndexMap[exemptKey] : index;
          if (newIndex === void 0) {
            hasSelectionChanged = true;
          } else {
            newExemptedIndicies[newIndex] = true;
            newExemptedCount++;
            hasSelectionChanged = hasSelectionChanged || newIndex !== index;
          }
        }
      }
      if (this._items && this._exemptedCount === 0 && items.length !== this._items.length && this._isAllSelected) {
        hasSelectionChanged = true;
      }
      if (!haveItemsChanged) {
        for (var _i = 0, _a7 = Object.keys(this._keyToIndexMap); _i < _a7.length; _i++) {
          var key = _a7[_i];
          if (!(key in newKeyToIndexMap)) {
            haveItemsChanged = true;
            break;
          }
        }
      }
      this._exemptedIndices = newExemptedIndicies;
      this._exemptedCount = newExemptedCount;
      this._keyToIndexMap = newKeyToIndexMap;
      this._unselectableIndices = newUnselectableIndices;
      this._items = items;
      this._selectedItems = null;
      if (hasSelectionChanged) {
        this._updateCount();
      }
      if (haveItemsChanged) {
        EventGroup.raise(this, SELECTION_ITEMS_CHANGE);
        if (this._onItemsChanged) {
          this._onItemsChanged();
        }
      }
      if (hasSelectionChanged) {
        this._change();
      }
      this.setChangeEvents(true);
    };
    Selection2.prototype.getItems = function() {
      return this._items;
    };
    Selection2.prototype.getSelection = function() {
      if (!this._selectedItems) {
        this._selectedItems = [];
        var items = this._items;
        if (items) {
          for (var i = 0; i < items.length; i++) {
            if (this.isIndexSelected(i)) {
              this._selectedItems.push(items[i]);
            }
          }
        }
      }
      return this._selectedItems;
    };
    Selection2.prototype.getSelectedCount = function() {
      return this._isAllSelected ? this._items.length - this._exemptedCount - this._unselectableCount : this._exemptedCount;
    };
    Selection2.prototype.getSelectedIndices = function() {
      if (!this._selectedIndices) {
        this._selectedIndices = [];
        var items = this._items;
        if (items) {
          for (var i = 0; i < items.length; i++) {
            if (this.isIndexSelected(i)) {
              this._selectedIndices.push(i);
            }
          }
        }
      }
      return this._selectedIndices;
    };
    Selection2.prototype.getItemIndex = function(key) {
      var index = this._keyToIndexMap[key];
      return index !== null && index !== void 0 ? index : -1;
    };
    Selection2.prototype.isRangeSelected = function(fromIndex, count) {
      if (count === 0) {
        return false;
      }
      var endIndex = fromIndex + count;
      for (var i = fromIndex; i < endIndex; i++) {
        if (!this.isIndexSelected(i)) {
          return false;
        }
      }
      return true;
    };
    Selection2.prototype.isAllSelected = function() {
      var selectableCount = this._items.length - this._unselectableCount;
      if (this.mode === SelectionMode.single) {
        selectableCount = Math.min(selectableCount, 1);
      }
      return this.count > 0 && this._isAllSelected && this._exemptedCount === 0 || !this._isAllSelected && this._exemptedCount === selectableCount && selectableCount > 0;
    };
    Selection2.prototype.isKeySelected = function(key) {
      var index = this._keyToIndexMap[key];
      return this.isIndexSelected(index);
    };
    Selection2.prototype.isIndexSelected = function(index) {
      return !!(this.count > 0 && this._isAllSelected && !this._exemptedIndices[index] && !this._unselectableIndices[index] || !this._isAllSelected && this._exemptedIndices[index]);
    };
    Selection2.prototype.setAllSelected = function(isAllSelected) {
      if (isAllSelected && this.mode !== SelectionMode.multiple) {
        return;
      }
      var selectableCount = this._items ? this._items.length - this._unselectableCount : 0;
      this.setChangeEvents(false);
      if (selectableCount > 0 && (this._exemptedCount > 0 || isAllSelected !== this._isAllSelected)) {
        this._exemptedIndices = {};
        if (isAllSelected !== this._isAllSelected || this._exemptedCount > 0) {
          this._exemptedCount = 0;
          this._isAllSelected = isAllSelected;
          this._change();
        }
        this._updateCount();
      }
      this.setChangeEvents(true);
    };
    Selection2.prototype.setKeySelected = function(key, isSelected, shouldAnchor) {
      var index = this._keyToIndexMap[key];
      if (index >= 0) {
        this.setIndexSelected(index, isSelected, shouldAnchor);
      }
    };
    Selection2.prototype.setIndexSelected = function(index, isSelected, shouldAnchor) {
      if (this.mode === SelectionMode.none) {
        return;
      }
      index = Math.min(Math.max(0, index), this._items.length - 1);
      if (index < 0 || index >= this._items.length) {
        return;
      }
      this.setChangeEvents(false);
      var isExempt = this._exemptedIndices[index];
      var canSelect = !this._unselectableIndices[index];
      if (canSelect) {
        if (isSelected && this.mode === SelectionMode.single) {
          this._setAllSelected(false, true);
        }
        if (isExempt && (isSelected && this._isAllSelected || !isSelected && !this._isAllSelected)) {
          delete this._exemptedIndices[index];
          this._exemptedCount--;
        }
        if (!isExempt && (isSelected && !this._isAllSelected || !isSelected && this._isAllSelected)) {
          this._exemptedIndices[index] = true;
          this._exemptedCount++;
        }
        if (shouldAnchor) {
          this._anchoredIndex = index;
        }
      }
      this._updateCount();
      this.setChangeEvents(true);
    };
    Selection2.prototype.setRangeSelected = function(fromIndex, count, isSelected, shouldAnchor) {
      if (this.mode === SelectionMode.none) {
        return;
      }
      fromIndex = Math.min(Math.max(0, fromIndex), this._items.length - 1);
      count = Math.min(Math.max(0, count), this._items.length - fromIndex);
      if (fromIndex < 0 || fromIndex >= this._items.length || count === 0) {
        return;
      }
      this.setChangeEvents(false);
      var anchorIndex = this._anchoredIndex || 0;
      var startIndex = fromIndex;
      var endIndex = fromIndex + count - 1;
      var newAnchorIndex = anchorIndex >= endIndex ? startIndex : endIndex;
      for (; startIndex <= endIndex; startIndex++) {
        this.setIndexSelected(startIndex, isSelected, shouldAnchor ? startIndex === newAnchorIndex : false);
      }
      this.setChangeEvents(true);
    };
    Selection2.prototype.selectToKey = function(key, clearSelection) {
      this.selectToIndex(this._keyToIndexMap[key], clearSelection);
    };
    Selection2.prototype.selectToRange = function(fromIndex, count, clearSelection) {
      if (this.mode === SelectionMode.none) {
        return;
      }
      if (this.mode === SelectionMode.single) {
        if (count === 1) {
          this.setIndexSelected(fromIndex, true, true);
        }
        return;
      }
      var anchorIndex = this._anchoredIndex || 0;
      var startIndex = Math.min(fromIndex, anchorIndex);
      var endIndex = Math.max(fromIndex + count - 1, anchorIndex);
      this.setChangeEvents(false);
      if (clearSelection) {
        this._setAllSelected(false, true);
      }
      for (; startIndex <= endIndex; startIndex++) {
        this.setIndexSelected(startIndex, true, false);
      }
      this.setChangeEvents(true);
    };
    Selection2.prototype.selectToIndex = function(index, clearSelection) {
      if (this.mode === SelectionMode.none) {
        return;
      }
      if (this.mode === SelectionMode.single) {
        this.setIndexSelected(index, true, true);
        return;
      }
      var anchorIndex = this._anchoredIndex || 0;
      var startIndex = Math.min(index, anchorIndex);
      var endIndex = Math.max(index, anchorIndex);
      this.setChangeEvents(false);
      if (clearSelection) {
        this._setAllSelected(false, true);
      }
      for (; startIndex <= endIndex; startIndex++) {
        this.setIndexSelected(startIndex, true, false);
      }
      this.setChangeEvents(true);
    };
    Selection2.prototype.toggleAllSelected = function() {
      this.setAllSelected(!this.isAllSelected());
    };
    Selection2.prototype.toggleKeySelected = function(key) {
      this.setKeySelected(key, !this.isKeySelected(key), true);
    };
    Selection2.prototype.toggleIndexSelected = function(index) {
      this.setIndexSelected(index, !this.isIndexSelected(index), true);
    };
    Selection2.prototype.toggleRangeSelected = function(fromIndex, count) {
      if (this.mode === SelectionMode.none) {
        return;
      }
      var isRangeSelected = this.isRangeSelected(fromIndex, count);
      var endIndex = fromIndex + count;
      if (this.mode === SelectionMode.single && count > 1) {
        return;
      }
      this.setChangeEvents(false);
      for (var i = fromIndex; i < endIndex; i++) {
        this.setIndexSelected(i, !isRangeSelected, false);
      }
      this.setChangeEvents(true);
    };
    Selection2.prototype._updateCount = function(preserveModalState) {
      if (preserveModalState === void 0) {
        preserveModalState = false;
      }
      var count = this.getSelectedCount();
      if (count !== this.count) {
        this.count = count;
        this._change();
      }
      if (!this.count && !preserveModalState) {
        this.setModal(false);
      }
    };
    Selection2.prototype._setAllSelected = function(isAllSelected, preserveModalState) {
      if (preserveModalState === void 0) {
        preserveModalState = false;
      }
      if (isAllSelected && this.mode !== SelectionMode.multiple) {
        return;
      }
      var selectableCount = this._items ? this._items.length - this._unselectableCount : 0;
      this.setChangeEvents(false);
      if (selectableCount > 0 && (this._exemptedCount > 0 || isAllSelected !== this._isAllSelected)) {
        this._exemptedIndices = {};
        if (isAllSelected !== this._isAllSelected || this._exemptedCount > 0) {
          this._exemptedCount = 0;
          this._isAllSelected = isAllSelected;
          this._change();
        }
        this._updateCount(preserveModalState);
      }
      this.setChangeEvents(true);
    };
    Selection2.prototype._change = function() {
      if (this._changeEventSuppressionCount === 0) {
        this._selectedItems = null;
        this._selectedIndices = void 0;
        EventGroup.raise(this, SELECTION_CHANGE);
        if (this._onSelectionChanged) {
          this._onSelectionChanged();
        }
      } else {
        this._hasChanged = true;
      }
    };
    return Selection2;
  }()
);
function defaultGetKey(item, index) {
  var _a7 = (item || {}).key, key = _a7 === void 0 ? "".concat(index) : _a7;
  return key;
}

// node_modules/@fluentui/utilities/lib/styled.js
var React11 = __toESM(require_react());
var DefaultFields = ["theme", "styles"];
function styled(Component24, baseStyles, getProps, customizable2, pure) {
  customizable2 = customizable2 || { scope: "", fields: void 0 };
  var scope = customizable2.scope, _a7 = customizable2.fields, fields = _a7 === void 0 ? DefaultFields : _a7;
  var Wrapped = React11.forwardRef(function(props, forwardedRef) {
    var styles = React11.useRef();
    var settings = useCustomizationSettings(fields, scope);
    var customizedStyles = settings.styles, dir = settings.dir, rest = __rest(settings, ["styles", "dir"]);
    var additionalProps = getProps ? getProps(props) : void 0;
    var cache = styles.current && styles.current.__cachedInputs__ || [];
    var propStyles = props.styles;
    if (!styles.current || customizedStyles !== cache[1] || propStyles !== cache[2]) {
      var concatenatedStyles = function(styleProps) {
        return concatStyleSetsWithProps(styleProps, baseStyles, customizedStyles, propStyles);
      };
      concatenatedStyles.__cachedInputs__ = [
        baseStyles,
        customizedStyles,
        propStyles
      ];
      concatenatedStyles.__noStyleOverride__ = !customizedStyles && !propStyles;
      styles.current = concatenatedStyles;
    }
    return React11.createElement(Component24, __assign({ ref: forwardedRef }, rest, additionalProps, props, { styles: styles.current }));
  });
  Wrapped.displayName = "Styled".concat(Component24.displayName || Component24.name);
  var pureComponent = pure ? React11.memo(Wrapped) : Wrapped;
  if (Wrapped.displayName) {
    pureComponent.displayName = Wrapped.displayName;
  }
  return pureComponent;
}

// node_modules/@fluentui/utilities/lib/warn/warnControlledUsage.js
var warningsMap;
if (true) {
  warningsMap = {
    valueOnChange: {},
    valueDefaultValue: {},
    controlledToUncontrolled: {},
    uncontrolledToControlled: {}
  };
}
function warnControlledUsage(params) {
  if (true) {
    var componentId = params.componentId, componentName = params.componentName, defaultValueProp = params.defaultValueProp, props = params.props, oldProps = params.oldProps, onChangeProp = params.onChangeProp, readOnlyProp = params.readOnlyProp, valueProp = params.valueProp;
    var oldIsControlled = oldProps ? isControlled(oldProps, valueProp) : void 0;
    var newIsControlled = isControlled(props, valueProp);
    if (newIsControlled) {
      var hasOnChange = !!props[onChangeProp];
      var isReadOnly = !!(readOnlyProp && props[readOnlyProp]);
      if (!(hasOnChange || isReadOnly) && !warningsMap.valueOnChange[componentId]) {
        warningsMap.valueOnChange[componentId] = true;
        warn("Warning: You provided a '".concat(String(valueProp), "' prop to a ").concat(String(componentName), " without an '").concat(String(onChangeProp), "' handler. ") + "This will render a read-only field. If the field should be mutable use '".concat(String(defaultValueProp), "'. ") + "Otherwise, set '".concat(String(onChangeProp), "'").concat(readOnlyProp ? " or '".concat(String(readOnlyProp), "'") : "", "."));
      }
      var defaultValue = props[defaultValueProp];
      if (defaultValue !== void 0 && defaultValue !== null && !warningsMap.valueDefaultValue[componentId]) {
        warningsMap.valueDefaultValue[componentId] = true;
        warn("Warning: You provided both '".concat(String(valueProp), "' and '").concat(String(defaultValueProp), "' to a ").concat(componentName, ". ") + "Form fields must be either controlled or uncontrolled (specify either the '".concat(String(valueProp), "' prop, ") + "or the '".concat(String(defaultValueProp), "' prop, but not both). Decide between using a controlled or uncontrolled ") + "".concat(componentName, " and remove one of these props. More info: https://fb.me/react-controlled-components"));
      }
    }
    if (oldProps && newIsControlled !== oldIsControlled) {
      var oldType = oldIsControlled ? "a controlled" : "an uncontrolled";
      var newType = oldIsControlled ? "uncontrolled" : "controlled";
      var warnMap = oldIsControlled ? warningsMap.controlledToUncontrolled : warningsMap.uncontrolledToControlled;
      if (!warnMap[componentId]) {
        warnMap[componentId] = true;
        warn("Warning: A component is changing ".concat(oldType, " ").concat(componentName, " to be ").concat(newType, ". ") + "".concat(componentName, "s should not switch from controlled to uncontrolled (or vice versa). ") + "Decide between using controlled or uncontrolled for the lifetime of the component. More info: https://fb.me/react-controlled-components");
      }
    }
  }
}

// node_modules/@fluentui/utilities/lib/getPropsWithDefaults.js
function getPropsWithDefaults(defaultProps, propsWithoutDefaults) {
  var props = __assign({}, propsWithoutDefaults);
  for (var _i = 0, _a7 = Object.keys(defaultProps); _i < _a7.length; _i++) {
    var key = _a7[_i];
    if (props[key] === void 0) {
      props[key] = defaultProps[key];
    }
  }
  return props;
}

// node_modules/@fluentui/utilities/lib/createMergedRef.js
var createResolver = function(local) {
  return function(newValue) {
    for (var _i = 0, _a7 = local.refs; _i < _a7.length; _i++) {
      var ref = _a7[_i];
      if (typeof ref === "function") {
        ref(newValue);
      } else if (ref) {
        ref.current = newValue;
      }
    }
  };
};
var createMergedRef = function(value) {
  var local = {
    refs: []
  };
  return function() {
    var newRefs = [];
    for (var _i = 0; _i < arguments.length; _i++) {
      newRefs[_i] = arguments[_i];
    }
    if (!local.resolver || !arraysEqual(local.refs, newRefs)) {
      local.resolver = createResolver(local);
    }
    local.refs = newRefs;
    return local.resolver;
  };
};

// node_modules/@fluentui/utilities/lib/useIsomorphicLayoutEffect.js
var React12 = __toESM(require_react());
var useIsomorphicLayoutEffect = canUseDOM() ? React12.useLayoutEffect : React12.useEffect;

// node_modules/@fluentui/utilities/lib/version.js
setVersion("@fluentui/utilities", "8.13.24");

// node_modules/@fluentui/react/lib/components/Dropdown/Dropdown.base.js
var React73 = __toESM(require_react());

// node_modules/@fluentui/react/lib/components/Callout/Callout.js
var React38 = __toESM(require_react());

// node_modules/@fluentui/react/lib/components/Callout/CalloutContent.base.js
var React33 = __toESM(require_react());

// node_modules/@fluentui/react/lib/common/DirectionalHint.js
var DirectionalHint = {
  /**
   * Appear above the target element, with the left edges of the callout and target aligning.
   */
  topLeftEdge: 0,
  /**
   * Appear above the target element, with the centers of the callout and target aligning.
   */
  topCenter: 1,
  /**
   * Appear above the target element, with the right edges of the callout and target aligning.
   */
  topRightEdge: 2,
  /**
   * Appear above the target element, aligning with the target element such that the callout tends toward
   * the center of the screen.
   */
  topAutoEdge: 3,
  /**
   * Appear below the target element, with the left edges of the callout and target aligning.
   */
  bottomLeftEdge: 4,
  /**
   * Appear below the target element, with the centers of the callout and target aligning.
   */
  bottomCenter: 5,
  /**
   * Appear below the target element, with the right edges of the callout and target aligning.
   */
  bottomRightEdge: 6,
  /**
   * Appear below the target element, aligning with the target element such that the callout tends toward
   * the center of the screen.
   */
  bottomAutoEdge: 7,
  /**
   * Appear to the left of the target element, with the top edges of the callout and target aligning.
   */
  leftTopEdge: 8,
  /**
   * Appear to the left of the target element, with the centers of the callout and target aligning.
   */
  leftCenter: 9,
  /**
   * Appear to the left of the target element, with the bottom edges of the callout and target aligning.
   */
  leftBottomEdge: 10,
  /**
   * Appear to the right of the target element, with the top edges of the callout and target aligning.
   */
  rightTopEdge: 11,
  /**
   * Appear to the right of the target element, with the centers of the callout and target aligning.
   */
  rightCenter: 12,
  /**
   * Appear to the right of the target element, with the bottom edges of the callout and target aligning.
   */
  rightBottomEdge: 13
};

// node_modules/@fluentui/react/lib/utilities/positioning/positioning.types.js
var RectangleEdge;
(function(RectangleEdge2) {
  RectangleEdge2[RectangleEdge2["top"] = 1] = "top";
  RectangleEdge2[RectangleEdge2["bottom"] = -1] = "bottom";
  RectangleEdge2[RectangleEdge2["left"] = 2] = "left";
  RectangleEdge2[RectangleEdge2["right"] = -2] = "right";
})(RectangleEdge || (RectangleEdge = {}));
var Position;
(function(Position2) {
  Position2[Position2["top"] = 0] = "top";
  Position2[Position2["bottom"] = 1] = "bottom";
  Position2[Position2["start"] = 2] = "start";
  Position2[Position2["end"] = 3] = "end";
})(Position || (Position = {}));

// node_modules/@fluentui/react/lib/utilities/positioning/positioning.js
var _a3;
function _createPositionData(targetEdge, alignmentEdge, isAuto) {
  return {
    targetEdge,
    alignmentEdge,
    isAuto
  };
}
var DirectionalDictionary = (_a3 = {}, _a3[DirectionalHint.topLeftEdge] = _createPositionData(RectangleEdge.top, RectangleEdge.left), _a3[DirectionalHint.topCenter] = _createPositionData(RectangleEdge.top), _a3[DirectionalHint.topRightEdge] = _createPositionData(RectangleEdge.top, RectangleEdge.right), _a3[DirectionalHint.topAutoEdge] = _createPositionData(RectangleEdge.top, void 0, true), _a3[DirectionalHint.bottomLeftEdge] = _createPositionData(RectangleEdge.bottom, RectangleEdge.left), _a3[DirectionalHint.bottomCenter] = _createPositionData(RectangleEdge.bottom), _a3[DirectionalHint.bottomRightEdge] = _createPositionData(RectangleEdge.bottom, RectangleEdge.right), _a3[DirectionalHint.bottomAutoEdge] = _createPositionData(RectangleEdge.bottom, void 0, true), _a3[DirectionalHint.leftTopEdge] = _createPositionData(RectangleEdge.left, RectangleEdge.top), _a3[DirectionalHint.leftCenter] = _createPositionData(RectangleEdge.left), _a3[DirectionalHint.leftBottomEdge] = _createPositionData(RectangleEdge.left, RectangleEdge.bottom), _a3[DirectionalHint.rightTopEdge] = _createPositionData(RectangleEdge.right, RectangleEdge.top), _a3[DirectionalHint.rightCenter] = _createPositionData(RectangleEdge.right), _a3[DirectionalHint.rightBottomEdge] = _createPositionData(RectangleEdge.right, RectangleEdge.bottom), _a3);
function _isRectangleWithinBounds(rect, boundingRect) {
  if (rect.top < boundingRect.top) {
    return false;
  }
  if (rect.bottom > boundingRect.bottom) {
    return false;
  }
  if (rect.left < boundingRect.left) {
    return false;
  }
  if (rect.right > boundingRect.right) {
    return false;
  }
  return true;
}
function _getOutOfBoundsEdges(rect, boundingRect) {
  var outOfBounds = [];
  if (rect.top < boundingRect.top) {
    outOfBounds.push(RectangleEdge.top);
  }
  if (rect.bottom > boundingRect.bottom) {
    outOfBounds.push(RectangleEdge.bottom);
  }
  if (rect.left < boundingRect.left) {
    outOfBounds.push(RectangleEdge.left);
  }
  if (rect.right > boundingRect.right) {
    outOfBounds.push(RectangleEdge.right);
  }
  return outOfBounds;
}
function _getEdgeValue(rect, edge) {
  return rect[RectangleEdge[edge]];
}
function _setEdgeValue(rect, edge, value) {
  rect[RectangleEdge[edge]] = value;
  return rect;
}
function _getCenterValue(rect, edge) {
  var edges = _getFlankingEdges(edge);
  return (_getEdgeValue(rect, edges.positiveEdge) + _getEdgeValue(rect, edges.negativeEdge)) / 2;
}
function _getRelativeEdgeValue(edge, value) {
  if (edge > 0) {
    return value;
  } else {
    return value * -1;
  }
}
function _getRelativeRectEdgeValue(edge, rect) {
  return _getRelativeEdgeValue(edge, _getEdgeValue(rect, edge));
}
function _getRelativeEdgeDifference(rect, hostRect, edge) {
  var edgeDifference = _getEdgeValue(rect, edge) - _getEdgeValue(hostRect, edge);
  return _getRelativeEdgeValue(edge, edgeDifference);
}
function _moveEdge(rect, edge, newValue, maintainSize) {
  if (maintainSize === void 0) {
    maintainSize = true;
  }
  var difference = _getEdgeValue(rect, edge) - newValue;
  var returnRect = _setEdgeValue(rect, edge, newValue);
  if (maintainSize) {
    returnRect = _setEdgeValue(rect, edge * -1, _getEdgeValue(rect, edge * -1) - difference);
  }
  return returnRect;
}
function _alignEdges(rect, target, edge, gap) {
  if (gap === void 0) {
    gap = 0;
  }
  return _moveEdge(rect, edge, _getEdgeValue(target, edge) + _getRelativeEdgeValue(edge, gap));
}
function _alignOppositeEdges(rect, target, targetEdge, gap) {
  if (gap === void 0) {
    gap = 0;
  }
  var oppositeEdge = targetEdge * -1;
  var adjustedGap = _getRelativeEdgeValue(oppositeEdge, gap);
  return _moveEdge(rect, targetEdge * -1, _getEdgeValue(target, targetEdge) + adjustedGap);
}
function _isEdgeInBounds(rect, bounds, edge) {
  var adjustedRectValue = _getRelativeRectEdgeValue(edge, rect);
  return adjustedRectValue > _getRelativeRectEdgeValue(edge, bounds);
}
function _getOutOfBoundsDegree(rect, bounds) {
  var breakingEdges = _getOutOfBoundsEdges(rect, bounds);
  var total = 0;
  for (var _i = 0, breakingEdges_1 = breakingEdges; _i < breakingEdges_1.length; _i++) {
    var edge = breakingEdges_1[_i];
    total += Math.pow(_getRelativeEdgeDifference(rect, bounds, edge), 2);
  }
  return total;
}
function _canScrollResizeToFitEdge(target, bounding, targetEdge, minimumScrollResizeHeight) {
  if (minimumScrollResizeHeight === void 0) {
    minimumScrollResizeHeight = 200;
  }
  if (targetEdge !== RectangleEdge.bottom && targetEdge !== RectangleEdge.top) {
    return false;
  }
  return _getRelativeEdgeDifference(target, bounding, targetEdge) >= minimumScrollResizeHeight;
}
function _flipToFit(rect, target, bounding, positionData, shouldScroll, minimumScrollResizeHeight, gap) {
  if (shouldScroll === void 0) {
    shouldScroll = false;
  }
  if (gap === void 0) {
    gap = 0;
  }
  var directions = [
    RectangleEdge.left,
    RectangleEdge.right,
    RectangleEdge.bottom,
    RectangleEdge.top
  ];
  if (getRTL2()) {
    directions[0] *= -1;
    directions[1] *= -1;
  }
  var currentEstimate = rect;
  var currentEdge = positionData.targetEdge;
  var currentAlignment = positionData.alignmentEdge;
  var oobDegree;
  var bestEdge = currentEdge;
  var bestAlignment = currentAlignment;
  for (var i = 0; i < 4; i++) {
    if (_isEdgeInBounds(currentEstimate, bounding, currentEdge)) {
      return {
        elementRectangle: currentEstimate,
        targetEdge: currentEdge,
        alignmentEdge: currentAlignment
      };
    } else if (shouldScroll && _canScrollResizeToFitEdge(target, bounding, currentEdge, minimumScrollResizeHeight)) {
      switch (currentEdge) {
        case RectangleEdge.bottom:
          currentEstimate.bottom = bounding.bottom;
          break;
        case RectangleEdge.top:
          currentEstimate.top = bounding.top;
          break;
      }
      return {
        elementRectangle: currentEstimate,
        targetEdge: currentEdge,
        alignmentEdge: currentAlignment,
        forcedInBounds: true
      };
    } else {
      var currentOOBDegree = _getOutOfBoundsDegree(currentEstimate, bounding);
      if (!oobDegree || currentOOBDegree < oobDegree) {
        oobDegree = currentOOBDegree;
        bestEdge = currentEdge;
        bestAlignment = currentAlignment;
      }
      directions.splice(directions.indexOf(currentEdge), 1);
      if (directions.length > 0) {
        if (directions.indexOf(currentEdge * -1) > -1) {
          currentEdge = currentEdge * -1;
        } else {
          currentAlignment = currentEdge;
          currentEdge = directions.slice(-1)[0];
        }
        currentEstimate = _estimatePosition(rect, target, { targetEdge: currentEdge, alignmentEdge: currentAlignment }, gap);
      }
    }
  }
  currentEstimate = _estimatePosition(rect, target, { targetEdge: bestEdge, alignmentEdge: bestAlignment }, gap);
  return {
    elementRectangle: currentEstimate,
    targetEdge: bestEdge,
    alignmentEdge: bestAlignment
  };
}
function _flipAlignmentEdge(elementEstimate, target, gap, coverTarget) {
  var alignmentEdge = elementEstimate.alignmentEdge, targetEdge = elementEstimate.targetEdge, elementRectangle = elementEstimate.elementRectangle;
  var oppositeEdge = alignmentEdge * -1;
  var newEstimate = _estimatePosition(elementRectangle, target, { targetEdge, alignmentEdge: oppositeEdge }, gap, coverTarget);
  return {
    elementRectangle: newEstimate,
    targetEdge,
    alignmentEdge: oppositeEdge
  };
}
function _adjustFitWithinBounds(element, target, bounding, positionData, shouldScroll, minimumScrollResizeHeight, gap, directionalHintFixed, coverTarget) {
  if (shouldScroll === void 0) {
    shouldScroll = false;
  }
  if (gap === void 0) {
    gap = 0;
  }
  var alignmentEdge = positionData.alignmentEdge, alignTargetEdge = positionData.alignTargetEdge;
  var elementEstimate = {
    elementRectangle: element,
    targetEdge: positionData.targetEdge,
    alignmentEdge
  };
  if (!directionalHintFixed && !coverTarget) {
    elementEstimate = _flipToFit(element, target, bounding, positionData, shouldScroll, minimumScrollResizeHeight, gap);
  }
  var outOfBounds = _getOutOfBoundsEdges(elementEstimate.elementRectangle, bounding);
  var fixedEdge = directionalHintFixed ? -elementEstimate.targetEdge : void 0;
  if (outOfBounds.length > 0) {
    if (alignTargetEdge) {
      if (elementEstimate.alignmentEdge && outOfBounds.indexOf(elementEstimate.alignmentEdge * -1) > -1) {
        var flippedElementEstimate = _flipAlignmentEdge(elementEstimate, target, gap, coverTarget);
        if (_isRectangleWithinBounds(flippedElementEstimate.elementRectangle, bounding)) {
          return flippedElementEstimate;
        } else {
          elementEstimate = _alignOutOfBoundsEdges(_getOutOfBoundsEdges(flippedElementEstimate.elementRectangle, bounding), elementEstimate, bounding, fixedEdge);
        }
      } else {
        elementEstimate = _alignOutOfBoundsEdges(outOfBounds, elementEstimate, bounding, fixedEdge);
      }
    } else {
      elementEstimate = _alignOutOfBoundsEdges(outOfBounds, elementEstimate, bounding, fixedEdge);
    }
  }
  return elementEstimate;
}
function _alignOutOfBoundsEdges(outOfBoundsEdges, elementEstimate, bounding, preserveEdge) {
  for (var _i = 0, outOfBoundsEdges_1 = outOfBoundsEdges; _i < outOfBoundsEdges_1.length; _i++) {
    var direction = outOfBoundsEdges_1[_i];
    var edgeAttempt = void 0;
    if (preserveEdge && preserveEdge === direction * -1) {
      edgeAttempt = _moveEdge(elementEstimate.elementRectangle, direction, _getEdgeValue(bounding, direction), false);
      elementEstimate.forcedInBounds = true;
    } else {
      edgeAttempt = _alignEdges(elementEstimate.elementRectangle, bounding, direction);
      var inBounds = _isEdgeInBounds(edgeAttempt, bounding, direction * -1);
      if (!inBounds) {
        edgeAttempt = _moveEdge(edgeAttempt, direction * -1, _getEdgeValue(bounding, direction * -1), false);
        elementEstimate.forcedInBounds = true;
      }
    }
    elementEstimate.elementRectangle = edgeAttempt;
  }
  return elementEstimate;
}
function _centerEdgeToPoint(rect, edge, point) {
  var positiveEdge = _getFlankingEdges(edge).positiveEdge;
  var elementMiddle = _getCenterValue(rect, edge);
  var distanceToMiddle = elementMiddle - _getEdgeValue(rect, positiveEdge);
  return _moveEdge(rect, positiveEdge, point - distanceToMiddle);
}
function _estimatePosition(elementToPosition, target, positionData, gap, coverTarget) {
  if (gap === void 0) {
    gap = 0;
  }
  var estimatedElementPosition = new Rectangle(elementToPosition.left, elementToPosition.right, elementToPosition.top, elementToPosition.bottom);
  var alignmentEdge = positionData.alignmentEdge, targetEdge = positionData.targetEdge;
  var elementEdge = coverTarget ? targetEdge : targetEdge * -1;
  estimatedElementPosition = coverTarget ? _alignEdges(estimatedElementPosition, target, targetEdge, gap) : _alignOppositeEdges(estimatedElementPosition, target, targetEdge, gap);
  if (!alignmentEdge) {
    var targetMiddlePoint = _getCenterValue(target, targetEdge);
    estimatedElementPosition = _centerEdgeToPoint(estimatedElementPosition, elementEdge, targetMiddlePoint);
  } else {
    estimatedElementPosition = _alignEdges(estimatedElementPosition, target, alignmentEdge);
  }
  return estimatedElementPosition;
}
function _getFlankingEdges(edge) {
  if (edge === RectangleEdge.top || edge === RectangleEdge.bottom) {
    return {
      positiveEdge: RectangleEdge.left,
      negativeEdge: RectangleEdge.right
    };
  } else {
    return {
      positiveEdge: RectangleEdge.top,
      negativeEdge: RectangleEdge.bottom
    };
  }
}
function _finalizeReturnEdge(elementRectangle, returnEdge, bounds) {
  if (bounds && Math.abs(_getRelativeEdgeDifference(elementRectangle, bounds, returnEdge)) > Math.abs(_getRelativeEdgeDifference(elementRectangle, bounds, returnEdge * -1))) {
    return returnEdge * -1;
  }
  return returnEdge;
}
function _isEdgeOnBounds(elementRectangle, edge, bounds) {
  return bounds !== void 0 && _getEdgeValue(elementRectangle, edge) === _getEdgeValue(bounds, edge);
}
function _finalizeElementPosition(elementRectangle, hostElement, targetEdge, bounds, alignmentEdge, coverTarget, doNotFinalizeReturnEdge, forceWithinBounds) {
  var returnValue = {};
  var hostRect = _getRectangleFromElement(hostElement);
  var elementEdge = coverTarget ? targetEdge : targetEdge * -1;
  var returnEdge = alignmentEdge ? alignmentEdge : _getFlankingEdges(targetEdge).positiveEdge;
  if (!doNotFinalizeReturnEdge || _isEdgeOnBounds(elementRectangle, getOppositeEdge(returnEdge), bounds)) {
    returnEdge = _finalizeReturnEdge(elementRectangle, returnEdge, bounds);
  }
  returnValue[RectangleEdge[elementEdge]] = _getRelativeEdgeDifference(elementRectangle, hostRect, elementEdge);
  returnValue[RectangleEdge[returnEdge]] = _getRelativeEdgeDifference(elementRectangle, hostRect, returnEdge);
  if (forceWithinBounds) {
    returnValue[RectangleEdge[elementEdge * -1]] = _getRelativeEdgeDifference(elementRectangle, hostRect, elementEdge * -1);
    returnValue[RectangleEdge[returnEdge * -1]] = _getRelativeEdgeDifference(elementRectangle, hostRect, returnEdge * -1);
  }
  return returnValue;
}
function _calculateActualBeakWidthInPixels(beakWidth) {
  return Math.sqrt(beakWidth * beakWidth * 2);
}
function _getPositionData(directionalHint, directionalHintForRTL, previousPositions) {
  if (directionalHint === void 0) {
    directionalHint = DirectionalHint.bottomAutoEdge;
  }
  if (previousPositions) {
    return {
      alignmentEdge: previousPositions.alignmentEdge,
      isAuto: previousPositions.isAuto,
      targetEdge: previousPositions.targetEdge
    };
  }
  var positionInformation = __assign({}, DirectionalDictionary[directionalHint]);
  if (getRTL2()) {
    if (positionInformation.alignmentEdge && positionInformation.alignmentEdge % 2 === 0) {
      positionInformation.alignmentEdge = positionInformation.alignmentEdge * -1;
    }
    return directionalHintForRTL !== void 0 ? DirectionalDictionary[directionalHintForRTL] : positionInformation;
  }
  return positionInformation;
}
function _getAlignmentData(positionData, target, boundingRect, coverTarget, alignTargetEdge) {
  if (positionData.isAuto) {
    positionData.alignmentEdge = getClosestEdge(positionData.targetEdge, target, boundingRect);
  }
  positionData.alignTargetEdge = alignTargetEdge;
  return positionData;
}
function getClosestEdge(targetEdge, target, boundingRect) {
  var targetCenter = _getCenterValue(target, targetEdge);
  var boundingCenter = _getCenterValue(boundingRect, targetEdge);
  var _a7 = _getFlankingEdges(targetEdge), positiveEdge = _a7.positiveEdge, negativeEdge = _a7.negativeEdge;
  if (targetCenter <= boundingCenter) {
    return positiveEdge;
  } else {
    return negativeEdge;
  }
}
function _positionElementWithinBounds(elementToPosition, target, bounding, positionData, gap, shouldScroll, minimumScrollResizeHeight, directionalHintFixed, coverTarget) {
  if (shouldScroll === void 0) {
    shouldScroll = false;
  }
  var estimatedElementPosition = _estimatePosition(elementToPosition, target, positionData, gap, coverTarget);
  if (_isRectangleWithinBounds(estimatedElementPosition, bounding)) {
    return {
      elementRectangle: estimatedElementPosition,
      targetEdge: positionData.targetEdge,
      alignmentEdge: positionData.alignmentEdge
    };
  } else {
    return _adjustFitWithinBounds(estimatedElementPosition, target, bounding, positionData, shouldScroll, minimumScrollResizeHeight, gap, directionalHintFixed, coverTarget);
  }
}
function _finalizeBeakPosition(elementPosition, positionedBeak, bounds) {
  var targetEdge = elementPosition.targetEdge * -1;
  var actualElement = new Rectangle(0, elementPosition.elementRectangle.width, 0, elementPosition.elementRectangle.height);
  var returnValue = {};
  var returnEdge = _finalizeReturnEdge(elementPosition.elementRectangle, elementPosition.alignmentEdge ? elementPosition.alignmentEdge : _getFlankingEdges(targetEdge).positiveEdge, bounds);
  var beakEdgeDifference = _getRelativeEdgeDifference(elementPosition.elementRectangle, elementPosition.targetRectangle, targetEdge);
  var showBeak = beakEdgeDifference > Math.abs(_getEdgeValue(positionedBeak, targetEdge));
  returnValue[RectangleEdge[targetEdge]] = _getEdgeValue(positionedBeak, targetEdge);
  returnValue[RectangleEdge[returnEdge]] = _getRelativeEdgeDifference(positionedBeak, actualElement, returnEdge);
  return {
    elementPosition: __assign({}, returnValue),
    closestEdge: getClosestEdge(elementPosition.targetEdge, positionedBeak, actualElement),
    targetEdge,
    hideBeak: !showBeak
  };
}
function _positionBeak(beakWidth, elementPosition) {
  var target = elementPosition.targetRectangle;
  var _a7 = _getFlankingEdges(elementPosition.targetEdge), positiveEdge = _a7.positiveEdge, negativeEdge = _a7.negativeEdge;
  var beakTargetPoint = _getCenterValue(target, elementPosition.targetEdge);
  var elementBounds = new Rectangle(beakWidth / 2, elementPosition.elementRectangle.width - beakWidth / 2, beakWidth / 2, elementPosition.elementRectangle.height - beakWidth / 2);
  var beakPosition = new Rectangle(0, beakWidth, 0, beakWidth);
  beakPosition = _moveEdge(beakPosition, elementPosition.targetEdge * -1, -beakWidth / 2);
  beakPosition = _centerEdgeToPoint(beakPosition, elementPosition.targetEdge * -1, beakTargetPoint - _getRelativeRectEdgeValue(positiveEdge, elementPosition.elementRectangle));
  if (!_isEdgeInBounds(beakPosition, elementBounds, positiveEdge)) {
    beakPosition = _alignEdges(beakPosition, elementBounds, positiveEdge);
  } else if (!_isEdgeInBounds(beakPosition, elementBounds, negativeEdge)) {
    beakPosition = _alignEdges(beakPosition, elementBounds, negativeEdge);
  }
  return beakPosition;
}
function _getRectangleFromElement(element) {
  var clientRect = element.getBoundingClientRect();
  return new Rectangle(clientRect.left, clientRect.right, clientRect.top, clientRect.bottom);
}
function _getRectangleFromIRect(rect) {
  return new Rectangle(rect.left, rect.right, rect.top, rect.bottom);
}
function _getTargetRect(bounds, target) {
  var targetRectangle;
  if (target) {
    if (!!target.preventDefault) {
      var ev = target;
      targetRectangle = new Rectangle(ev.clientX, ev.clientX, ev.clientY, ev.clientY);
    } else if (!!target.getBoundingClientRect) {
      targetRectangle = _getRectangleFromElement(target);
    } else {
      var rectOrPoint = target;
      var left = rectOrPoint.left || rectOrPoint.x;
      var top_1 = rectOrPoint.top || rectOrPoint.y;
      var right = rectOrPoint.right || left;
      var bottom = rectOrPoint.bottom || top_1;
      targetRectangle = new Rectangle(left, right, top_1, bottom);
    }
    if (!_isRectangleWithinBounds(targetRectangle, bounds)) {
      var outOfBounds = _getOutOfBoundsEdges(targetRectangle, bounds);
      for (var _i = 0, outOfBounds_1 = outOfBounds; _i < outOfBounds_1.length; _i++) {
        var direction = outOfBounds_1[_i];
        targetRectangle[RectangleEdge[direction]] = bounds[RectangleEdge[direction]];
      }
    }
  } else {
    targetRectangle = new Rectangle(0, 0, 0, 0);
  }
  return targetRectangle;
}
function _positionElementRelative(props, elementToPosition, boundingRect, previousPositions, shouldScroll, minimumScrollResizeHeight) {
  if (shouldScroll === void 0) {
    shouldScroll = false;
  }
  var gap = props.gapSpace ? props.gapSpace : 0;
  var targetRect = _getTargetRect(boundingRect, props.target);
  var positionData = _getAlignmentData(_getPositionData(props.directionalHint, props.directionalHintForRTL, previousPositions), targetRect, boundingRect, props.coverTarget, props.alignTargetEdge);
  var positionedElement = _positionElementWithinBounds(_getRectangleFromElement(elementToPosition), targetRect, boundingRect, positionData, gap, shouldScroll, minimumScrollResizeHeight, props.directionalHintFixed, props.coverTarget);
  return __assign(__assign({}, positionedElement), { targetRectangle: targetRect });
}
function _finalizePositionData(positionedElement, hostElement, bounds, coverTarget, doNotFinalizeReturnEdge) {
  var finalizedElement = _finalizeElementPosition(positionedElement.elementRectangle, hostElement, positionedElement.targetEdge, bounds, positionedElement.alignmentEdge, coverTarget, doNotFinalizeReturnEdge, positionedElement.forcedInBounds);
  return {
    elementPosition: finalizedElement,
    targetEdge: positionedElement.targetEdge,
    alignmentEdge: positionedElement.alignmentEdge
  };
}
function _calculateGapSpace(isBeakVisible, beakWidth, gapSpace) {
  if (beakWidth === void 0) {
    beakWidth = 0;
  }
  if (gapSpace === void 0) {
    gapSpace = 0;
  }
  return _calculateActualBeakWidthInPixels(isBeakVisible ? beakWidth : 0) / 2 + gapSpace;
}
function _positionCallout(props, hostElement, callout, previousPositions, shouldScroll, minimumScrollResizeHeight, doNotFinalizeReturnEdge, win) {
  if (shouldScroll === void 0) {
    shouldScroll = false;
  }
  var theWin = win !== null && win !== void 0 ? win : getWindow();
  var beakWidth = props.isBeakVisible ? props.beakWidth || 0 : 0;
  var gap = _calculateGapSpace(props.isBeakVisible, props.beakWidth, props.gapSpace);
  var positionProps = props;
  positionProps.gapSpace = gap;
  var boundingRect = props.bounds ? _getRectangleFromIRect(props.bounds) : new Rectangle(0, theWin.innerWidth - getScrollbarWidth(), 0, theWin.innerHeight);
  var positionedElement = _positionElementRelative(positionProps, callout, boundingRect, previousPositions, shouldScroll, minimumScrollResizeHeight);
  var beakPositioned = _positionBeak(beakWidth, positionedElement);
  var finalizedBeakPosition = _finalizeBeakPosition(positionedElement, beakPositioned, boundingRect);
  return __assign(__assign({}, _finalizePositionData(positionedElement, hostElement, boundingRect, props.coverTarget, doNotFinalizeReturnEdge)), { beakPosition: finalizedBeakPosition });
}
function _positionCard(props, hostElement, callout, previousPositions, win) {
  var theWin = win !== null && win !== void 0 ? win : getWindow();
  return _positionCallout(props, hostElement, callout, previousPositions, false, void 0, true, theWin);
}
function _getRectangleFromTarget(target) {
  var _a7, _b3, _c3, _d3;
  var mouseTarget = target;
  var elementTarget = target;
  var rectOrPointTarget = target;
  var targetRect;
  var left = (_a7 = rectOrPointTarget.left) !== null && _a7 !== void 0 ? _a7 : rectOrPointTarget.x;
  var top = (_b3 = rectOrPointTarget.top) !== null && _b3 !== void 0 ? _b3 : rectOrPointTarget.y;
  var right = (_c3 = rectOrPointTarget.right) !== null && _c3 !== void 0 ? _c3 : left;
  var bottom = (_d3 = rectOrPointTarget.bottom) !== null && _d3 !== void 0 ? _d3 : top;
  if (!!mouseTarget.stopPropagation) {
    targetRect = new Rectangle(mouseTarget.clientX, mouseTarget.clientX, mouseTarget.clientY, mouseTarget.clientY);
  } else if (left !== void 0 && top !== void 0) {
    targetRect = new Rectangle(left, right, top, bottom);
  } else {
    targetRect = _getRectangleFromElement(elementTarget);
  }
  return targetRect;
}
function positionCallout(props, hostElement, elementToPosition, previousPositions, shouldScroll, minimumScrollResizeHeight, win) {
  return _positionCallout(props, hostElement, elementToPosition, previousPositions, shouldScroll, minimumScrollResizeHeight, void 0, win);
}
function positionCard(props, hostElement, elementToPosition, previousPositions, win) {
  return _positionCard(props, hostElement, elementToPosition, previousPositions, win);
}
function getOppositeEdge(edge) {
  return edge * -1;
}
function _getBoundsFromTargetWindow(target, targetWindow) {
  var segments = void 0;
  if (targetWindow.getWindowSegments) {
    segments = targetWindow.getWindowSegments();
  }
  if (segments === void 0 || segments.length <= 1) {
    return {
      top: 0,
      left: 0,
      right: targetWindow.innerWidth,
      bottom: targetWindow.innerHeight,
      width: targetWindow.innerWidth,
      height: targetWindow.innerHeight
    };
  }
  var x = 0;
  var y = 0;
  if (target !== null && !!target.getBoundingClientRect) {
    var clientRect = target.getBoundingClientRect();
    x = (clientRect.left + clientRect.right) / 2;
    y = (clientRect.top + clientRect.bottom) / 2;
  } else if (target !== null) {
    x = target.left || target.x;
    y = target.top || target.y;
  }
  var bounds = { top: 0, left: 0, right: 0, bottom: 0, width: 0, height: 0 };
  for (var _i = 0, segments_1 = segments; _i < segments_1.length; _i++) {
    var segment = segments_1[_i];
    if (x && segment.left <= x && segment.right >= x && y && segment.top <= y && segment.bottom >= y) {
      bounds = {
        top: segment.top,
        left: segment.left,
        right: segment.right,
        bottom: segment.bottom,
        width: segment.width,
        height: segment.height
      };
    }
  }
  return bounds;
}
function getBoundsFromTargetWindow(target, targetWindow) {
  return _getBoundsFromTargetWindow(target, targetWindow);
}
function calculateGapSpace(isBeakVisible, beakWidth, gapSpace) {
  return _calculateGapSpace(isBeakVisible, beakWidth, gapSpace);
}
function getRectangleFromTarget(target) {
  return _getRectangleFromTarget(target);
}

// node_modules/@fluentui/react/lib/components/Popup/Popup.js
var React32 = __toESM(require_react());

// node_modules/@fluentui/react-hooks/lib/version.js
setVersion("@fluentui/react-hooks", "8.6.36");

// node_modules/@fluentui/react-hooks/lib/useAsync.js
var React13 = __toESM(require_react());
function useAsync() {
  var asyncRef = React13.useRef();
  if (!asyncRef.current) {
    asyncRef.current = new Async();
  }
  React13.useEffect(function() {
    return function() {
      var _a7;
      (_a7 = asyncRef.current) === null || _a7 === void 0 ? void 0 : _a7.dispose();
      asyncRef.current = void 0;
    };
  }, []);
  return asyncRef.current;
}

// node_modules/@fluentui/react-hooks/lib/useBoolean.js
var React15 = __toESM(require_react());

// node_modules/@fluentui/react-hooks/lib/useConst.js
var React14 = __toESM(require_react());
function useConst(initialValue) {
  var ref = React14.useRef();
  if (ref.current === void 0) {
    ref.current = {
      value: typeof initialValue === "function" ? initialValue() : initialValue
    };
  }
  return ref.current.value;
}

// node_modules/@fluentui/react-hooks/lib/useConstCallback.js
var React16 = __toESM(require_react());

// node_modules/@fluentui/react-hooks/lib/useControllableValue.js
var React17 = __toESM(require_react());
function useControllableValue(controlledValue, defaultUncontrolledValue, onChange) {
  var _a7 = React17.useState(defaultUncontrolledValue), value = _a7[0], setValue = _a7[1];
  var isControlled2 = useConst(controlledValue !== void 0);
  var currentValue = isControlled2 ? controlledValue : value;
  var valueRef = React17.useRef(currentValue);
  var onChangeRef = React17.useRef(onChange);
  React17.useEffect(function() {
    valueRef.current = currentValue;
    onChangeRef.current = onChange;
  });
  var setValueOrCallOnChange = useConst(function() {
    return function(update, ev) {
      var newValue = typeof update === "function" ? update(valueRef.current) : update;
      if (onChangeRef.current) {
        onChangeRef.current(ev, newValue);
      }
      if (!isControlled2) {
        setValue(newValue);
      }
    };
  });
  return [currentValue, setValueOrCallOnChange];
}

// node_modules/@fluentui/react-hooks/lib/useEventCallback.js
var React18 = __toESM(require_react());
function useEventCallback(fn) {
  var callbackRef = React18.useRef(function() {
    throw new Error("Cannot call an event handler while rendering");
  });
  useIsomorphicLayoutEffect(function() {
    callbackRef.current = fn;
  }, [fn]);
  return useConst(function() {
    return function() {
      var args = [];
      for (var _i = 0; _i < arguments.length; _i++) {
        args[_i] = arguments[_i];
      }
      var callback = callbackRef.current;
      return callback.apply(void 0, args);
    };
  });
}

// node_modules/@fluentui/react-hooks/lib/useForceUpdate.js
var React19 = __toESM(require_react());

// node_modules/@fluentui/react-hooks/lib/useId.js
var React20 = __toESM(require_react());
function useId(prefix, providedId) {
  var ref = React20.useRef(providedId);
  if (!ref.current) {
    ref.current = getId(prefix);
  }
  return ref.current;
}

// node_modules/@fluentui/react-hooks/lib/useMergedRefs.js
var React21 = __toESM(require_react());
function useMergedRefs() {
  var refs = [];
  for (var _i = 0; _i < arguments.length; _i++) {
    refs[_i] = arguments[_i];
  }
  var mergedCallback = React21.useCallback(function(value) {
    mergedCallback.current = value;
    for (var _i2 = 0, refs_1 = refs; _i2 < refs_1.length; _i2++) {
      var ref = refs_1[_i2];
      if (typeof ref === "function") {
        ref(value);
      } else if (ref) {
        ref.current = value;
      }
    }
  }, __spreadArray([], refs, true));
  return mergedCallback;
}

// node_modules/@fluentui/react-hooks/lib/useMount.js
var React22 = __toESM(require_react());

// node_modules/@fluentui/react-hooks/lib/useMountSync.js
var React23 = __toESM(require_react());

// node_modules/@fluentui/react-hooks/lib/useOnEvent.js
var React24 = __toESM(require_react());
function useOnEvent(element, eventName, callback, useCapture) {
  var callbackRef = React24.useRef(callback);
  callbackRef.current = callback;
  React24.useEffect(function() {
    var actualElement = element && "current" in element ? element.current : element;
    if (!actualElement || !actualElement.addEventListener) {
      return;
    }
    var dispose = on(actualElement, eventName, function(ev) {
      return callbackRef.current(ev);
    }, useCapture);
    return dispose;
  }, [element, eventName, useCapture]);
}

// node_modules/@fluentui/react-hooks/lib/usePrevious.js
var import_react = __toESM(require_react());
function usePrevious(value) {
  var ref = (0, import_react.useRef)();
  (0, import_react.useEffect)(function() {
    ref.current = value;
  });
  return ref.current;
}

// node_modules/@fluentui/react-hooks/lib/useRefEffect.js
var React25 = __toESM(require_react());

// node_modules/@fluentui/react-hooks/lib/useSetInterval.js
var React26 = __toESM(require_react());

// node_modules/@fluentui/react-hooks/lib/useSetTimeout.js
var React27 = __toESM(require_react());

// node_modules/@fluentui/react-hooks/lib/useTarget.js
var React29 = __toESM(require_react());

// node_modules/@fluentui/react-window-provider/lib/WindowProvider.js
var React28 = __toESM(require_react());
var WindowContext = React28.createContext({
  // eslint-disable-next-line no-restricted-globals
  window: typeof window === "object" ? window : void 0
});
var useWindow = function() {
  return React28.useContext(WindowContext).window;
};
var useDocument = function() {
  var _a7;
  return (_a7 = React28.useContext(WindowContext).window) === null || _a7 === void 0 ? void 0 : _a7.document;
};

// node_modules/@fluentui/react-window-provider/lib/version.js
setVersion("@fluentui/react-window-provider", "2.2.18");

// node_modules/@fluentui/react-hooks/lib/useTarget.js
function useTarget(target, hostElement) {
  var previousTargetProp = React29.useRef();
  var targetRef = React29.useRef(null);
  var targetWindow = useWindow();
  if (!target || target !== previousTargetProp.current || typeof target === "string") {
    var currentElement = hostElement === null || hostElement === void 0 ? void 0 : hostElement.current;
    if (target) {
      if (typeof target === "string") {
        var currentDoc = getDocument(currentElement);
        targetRef.current = currentDoc ? currentDoc.querySelector(target) : null;
      } else if ("stopPropagation" in target) {
        targetRef.current = target;
      } else if ("getBoundingClientRect" in target) {
        targetRef.current = target;
      } else if ("current" in target) {
        targetRef.current = target.current;
      } else {
        targetRef.current = target;
      }
    }
    previousTargetProp.current = target;
  }
  return [targetRef, targetWindow];
}

// node_modules/@fluentui/react-hooks/lib/useUnmount.js
var React30 = __toESM(require_react());
var useUnmount = function(callback) {
  var unmountRef = React30.useRef(callback);
  unmountRef.current = callback;
  React30.useEffect(function() {
    return function() {
      var _a7;
      (_a7 = unmountRef.current) === null || _a7 === void 0 ? void 0 : _a7.call(unmountRef);
    };
  }, []);
};

// node_modules/@fluentui/react-hooks/lib/useWarnings.js
var React31 = __toESM(require_react());
var warningId = 0;
function useWarnings(options) {
  if (true) {
    var name_1 = options.name, props = options.props, _a7 = options.other, other = _a7 === void 0 ? [] : _a7, conditionallyRequired = options.conditionallyRequired, deprecations = options.deprecations, mutuallyExclusive = options.mutuallyExclusive, controlledUsage = options.controlledUsage;
    var hasWarnedRef = React31.useRef(false);
    var componentId = useConst(function() {
      return "useWarnings_".concat(warningId++);
    });
    var oldProps = usePrevious(props);
    if (!hasWarnedRef.current) {
      hasWarnedRef.current = true;
      for (var _i = 0, other_1 = other; _i < other_1.length; _i++) {
        var warning = other_1[_i];
        warn(warning);
      }
      if (conditionallyRequired) {
        for (var _b3 = 0, conditionallyRequired_1 = conditionallyRequired; _b3 < conditionallyRequired_1.length; _b3++) {
          var req = conditionallyRequired_1[_b3];
          warnConditionallyRequiredProps(name_1, props, req.requiredProps, req.conditionalPropName, req.condition);
        }
      }
      deprecations && warnDeprecations(name_1, props, deprecations);
      mutuallyExclusive && warnMutuallyExclusive(name_1, props, mutuallyExclusive);
    }
    controlledUsage && warnControlledUsage(__assign(__assign({}, controlledUsage), { componentId, props, componentName: name_1, oldProps }));
  }
}

// node_modules/@fluentui/react/lib/components/Popup/Popup.js
function useScrollbarAsync(props, root) {
  var async = useAsync();
  var _a7 = React32.useState(false), needsVerticalScrollBarState = _a7[0], setNeedsVerticalScrollBar = _a7[1];
  React32.useEffect(function() {
    async.requestAnimationFrame(function() {
      var _a8;
      if (props.style && props.style.overflowY) {
        return;
      }
      var needsVerticalScrollBar = false;
      if (root && root.current && ((_a8 = root.current) === null || _a8 === void 0 ? void 0 : _a8.firstElementChild)) {
        var rootHeight = root.current.clientHeight;
        var firstChildHeight = root.current.firstElementChild.clientHeight;
        if (rootHeight > 0 && firstChildHeight > rootHeight) {
          needsVerticalScrollBar = firstChildHeight - rootHeight > 1;
        }
      }
      if (needsVerticalScrollBarState !== needsVerticalScrollBar) {
        setNeedsVerticalScrollBar(needsVerticalScrollBar);
      }
    });
    return function() {
      return async.dispose();
    };
  });
  return needsVerticalScrollBarState;
}
function defaultFocusRestorer(options) {
  var originalElement = options.originalElement, containsFocus = options.containsFocus;
  if (originalElement && containsFocus && originalElement !== getWindow()) {
    setTimeout(function() {
      var _a7;
      (_a7 = originalElement.focus) === null || _a7 === void 0 ? void 0 : _a7.call(originalElement);
    }, 0);
  }
}
function useRestoreFocus(props, root) {
  var _a7 = props.onRestoreFocus, onRestoreFocus = _a7 === void 0 ? defaultFocusRestorer : _a7;
  var originalFocusedElement = React32.useRef();
  var containsFocus = React32.useRef(false);
  React32.useEffect(function() {
    originalFocusedElement.current = getDocument().activeElement;
    if (doesElementContainFocus(root.current)) {
      containsFocus.current = true;
    }
    return function() {
      var _a8;
      onRestoreFocus === null || onRestoreFocus === void 0 ? void 0 : onRestoreFocus({
        originalElement: originalFocusedElement.current,
        containsFocus: containsFocus.current,
        documentContainsFocus: ((_a8 = getDocument()) === null || _a8 === void 0 ? void 0 : _a8.hasFocus()) || false
      });
      originalFocusedElement.current = void 0;
    };
  }, []);
  useOnEvent(root, "focus", React32.useCallback(function() {
    containsFocus.current = true;
  }, []), true);
  useOnEvent(root, "blur", React32.useCallback(function(ev) {
    if (root.current && ev.relatedTarget && !root.current.contains(ev.relatedTarget)) {
      containsFocus.current = false;
    }
  }, []), true);
}
function useHideSiblingNodes(props, root) {
  var shouldHideSiblings = String(props["aria-modal"]).toLowerCase() === "true" && props.enableAriaHiddenSiblings;
  React32.useEffect(function() {
    if (!(shouldHideSiblings && root.current)) {
      return;
    }
    var unmodalize2 = modalize(root.current);
    return unmodalize2;
  }, [root, shouldHideSiblings]);
}
var Popup = React32.forwardRef(function(propsWithoutDefaults, forwardedRef) {
  var props = getPropsWithDefaults({ shouldRestoreFocus: true, enableAriaHiddenSiblings: true }, propsWithoutDefaults);
  var root = React32.useRef();
  var mergedRootRef = useMergedRefs(root, forwardedRef);
  useHideSiblingNodes(props, root);
  useRestoreFocus(props, root);
  var role = props.role, className = props.className, ariaLabel = props.ariaLabel, ariaLabelledBy = props.ariaLabelledBy, ariaDescribedBy = props.ariaDescribedBy, style = props.style, children = props.children, onDismiss = props.onDismiss;
  var needsVerticalScrollBar = useScrollbarAsync(props, root);
  var onKeyDown = React32.useCallback(function(ev) {
    switch (ev.which) {
      case KeyCodes.escape:
        if (onDismiss) {
          onDismiss(ev);
          ev.preventDefault();
          ev.stopPropagation();
        }
        break;
    }
  }, [onDismiss]);
  var win = useWindow();
  useOnEvent(win, "keydown", onKeyDown);
  return React32.createElement("div", __assign({ ref: mergedRootRef }, getNativeProps(props, divProperties), { className, role, "aria-label": ariaLabel, "aria-labelledby": ariaLabelledBy, "aria-describedby": ariaDescribedBy, onKeyDown, style: __assign({ overflowY: needsVerticalScrollBar ? "scroll" : void 0, outline: "none" }, style) }), children);
});
Popup.displayName = "Popup";

// node_modules/@fluentui/style-utilities/lib/utilities/buildClassMap.js
function buildClassMap(styles) {
  var classes = {};
  var _loop_1 = function(styleName2) {
    if (styles.hasOwnProperty(styleName2)) {
      var className_1;
      Object.defineProperty(classes, styleName2, {
        get: function() {
          if (className_1 === void 0) {
            className_1 = mergeStyles(styles[styleName2]).toString();
          }
          return className_1;
        },
        enumerable: true,
        configurable: true
      });
    }
  };
  for (var styleName in styles) {
    _loop_1(styleName);
  }
  return classes;
}

// node_modules/@fluentui/style-utilities/lib/utilities/icons.js
var ICON_SETTING_NAME = "icons";
var _iconSettings = GlobalSettings.getValue(ICON_SETTING_NAME, {
  __options: {
    disableWarnings: false,
    warnOnMissingIcons: true
  },
  __remapped: {}
});
var stylesheet2 = Stylesheet.getInstance();
if (stylesheet2 && stylesheet2.onReset) {
  stylesheet2.onReset(function() {
    for (var name_1 in _iconSettings) {
      if (_iconSettings.hasOwnProperty(name_1) && !!_iconSettings[name_1].subset) {
        _iconSettings[name_1].subset.className = void 0;
      }
    }
  });
}
var normalizeIconName = function(name) {
  return name.toLowerCase();
};
function getIcon(name) {
  var icon = void 0;
  var options = _iconSettings.__options;
  name = name ? normalizeIconName(name) : "";
  name = _iconSettings.__remapped[name] || name;
  if (name) {
    icon = _iconSettings[name];
    if (icon) {
      var subset = icon.subset;
      if (subset && subset.fontFace) {
        if (!subset.isRegistered) {
          fontFace(subset.fontFace);
          subset.isRegistered = true;
        }
        if (!subset.className) {
          subset.className = mergeStyles(subset.style, {
            fontFamily: subset.fontFace.fontFamily,
            fontWeight: subset.fontFace.fontWeight || "normal",
            fontStyle: subset.fontFace.fontStyle || "normal"
          });
        }
      }
    } else {
      if (!options.disableWarnings && options.warnOnMissingIcons) {
        warn('The icon "'.concat(name, '" was used but not registered. See https://github.com/microsoft/fluentui/wiki/Using-icons for more information.'));
      }
    }
  }
  return icon;
}

// node_modules/@fluentui/theme/lib/utilities/makeSemanticColors.js
function makeSemanticColors(p, e, s, isInverted, depComments) {
  if (depComments === void 0) {
    depComments = false;
  }
  var semanticColors = __assign({
    primaryButtonBorder: "transparent",
    errorText: !isInverted ? "#a4262c" : "#F1707B",
    messageText: !isInverted ? "#323130" : "#F3F2F1",
    messageLink: !isInverted ? "#005A9E" : "#6CB8F6",
    messageLinkHovered: !isInverted ? "#004578" : "#82C7FF",
    infoIcon: !isInverted ? "#605e5c" : "#C8C6C4",
    errorIcon: !isInverted ? "#A80000" : "#F1707B",
    blockingIcon: !isInverted ? "#FDE7E9" : "#442726",
    warningIcon: !isInverted ? "#797775" : "#C8C6C4",
    severeWarningIcon: !isInverted ? "#D83B01" : "#FCE100",
    successIcon: !isInverted ? "#107C10" : "#92C353",
    infoBackground: !isInverted ? "#f3f2f1" : "#323130",
    errorBackground: !isInverted ? "#FDE7E9" : "#442726",
    blockingBackground: !isInverted ? "#FDE7E9" : "#442726",
    warningBackground: !isInverted ? "#FFF4CE" : "#433519",
    severeWarningBackground: !isInverted ? "#FED9CC" : "#4F2A0F",
    successBackground: !isInverted ? "#DFF6DD" : "#393D1B",
    // deprecated
    warningHighlight: !isInverted ? "#ffb900" : "#fff100",
    successText: !isInverted ? "#107C10" : "#92c353"
  }, s);
  var fullSemanticColors = getSemanticColors(p, e, semanticColors, isInverted);
  return _fixDeprecatedSlots(fullSemanticColors, depComments);
}
function getSemanticColors(p, e, s, isInverted, depComments) {
  if (depComments === void 0) {
    depComments = false;
  }
  var result = {};
  var _a7 = p || {}, white = _a7.white, black = _a7.black, themePrimary = _a7.themePrimary, themeDark = _a7.themeDark, themeDarker = _a7.themeDarker, themeDarkAlt = _a7.themeDarkAlt, themeLighter = _a7.themeLighter, neutralLight = _a7.neutralLight, neutralLighter = _a7.neutralLighter, neutralDark = _a7.neutralDark, neutralQuaternary = _a7.neutralQuaternary, neutralQuaternaryAlt = _a7.neutralQuaternaryAlt, neutralPrimary = _a7.neutralPrimary, neutralSecondary = _a7.neutralSecondary, neutralSecondaryAlt = _a7.neutralSecondaryAlt, neutralTertiary = _a7.neutralTertiary, neutralTertiaryAlt = _a7.neutralTertiaryAlt, neutralLighterAlt = _a7.neutralLighterAlt, accent = _a7.accent;
  if (white) {
    result.bodyBackground = white;
    result.bodyFrameBackground = white;
    result.accentButtonText = white;
    result.buttonBackground = white;
    result.primaryButtonText = white;
    result.primaryButtonTextHovered = white;
    result.primaryButtonTextPressed = white;
    result.inputBackground = white;
    result.inputForegroundChecked = white;
    result.listBackground = white;
    result.menuBackground = white;
    result.cardStandoutBackground = white;
  }
  if (black) {
    result.bodyTextChecked = black;
    result.buttonTextCheckedHovered = black;
  }
  if (themePrimary) {
    result.link = themePrimary;
    result.primaryButtonBackground = themePrimary;
    result.inputBackgroundChecked = themePrimary;
    result.inputIcon = themePrimary;
    result.inputFocusBorderAlt = themePrimary;
    result.menuIcon = themePrimary;
    result.menuHeader = themePrimary;
    result.accentButtonBackground = themePrimary;
  }
  if (themeDark) {
    result.primaryButtonBackgroundPressed = themeDark;
    result.inputBackgroundCheckedHovered = themeDark;
    result.inputIconHovered = themeDark;
  }
  if (themeDarker) {
    result.linkHovered = themeDarker;
  }
  if (themeDarkAlt) {
    result.primaryButtonBackgroundHovered = themeDarkAlt;
  }
  if (themeLighter) {
    result.inputPlaceholderBackgroundChecked = themeLighter;
  }
  if (neutralLight) {
    result.bodyBackgroundChecked = neutralLight;
    result.bodyFrameDivider = neutralLight;
    result.bodyDivider = neutralLight;
    result.variantBorder = neutralLight;
    result.buttonBackgroundCheckedHovered = neutralLight;
    result.buttonBackgroundPressed = neutralLight;
    result.listItemBackgroundChecked = neutralLight;
    result.listHeaderBackgroundPressed = neutralLight;
    result.menuItemBackgroundPressed = neutralLight;
    result.menuItemBackgroundChecked = neutralLight;
  }
  if (neutralLighter) {
    result.bodyBackgroundHovered = neutralLighter;
    result.buttonBackgroundHovered = neutralLighter;
    result.buttonBackgroundDisabled = neutralLighter;
    result.buttonBorderDisabled = neutralLighter;
    result.primaryButtonBackgroundDisabled = neutralLighter;
    result.disabledBackground = neutralLighter;
    result.listItemBackgroundHovered = neutralLighter;
    result.listHeaderBackgroundHovered = neutralLighter;
    result.menuItemBackgroundHovered = neutralLighter;
  }
  if (neutralQuaternary) {
    result.primaryButtonTextDisabled = neutralQuaternary;
    result.disabledSubtext = neutralQuaternary;
  }
  if (neutralQuaternaryAlt) {
    result.listItemBackgroundCheckedHovered = neutralQuaternaryAlt;
  }
  if (neutralTertiary) {
    result.disabledBodyText = neutralTertiary;
    result.variantBorderHovered = (s === null || s === void 0 ? void 0 : s.variantBorderHovered) || neutralTertiary;
    result.buttonTextDisabled = neutralTertiary;
    result.inputIconDisabled = neutralTertiary;
    result.disabledText = neutralTertiary;
  }
  if (neutralPrimary) {
    result.bodyText = neutralPrimary;
    result.actionLink = neutralPrimary;
    result.buttonText = neutralPrimary;
    result.inputBorderHovered = neutralPrimary;
    result.inputText = neutralPrimary;
    result.listText = neutralPrimary;
    result.menuItemText = neutralPrimary;
  }
  if (neutralLighterAlt) {
    result.bodyStandoutBackground = neutralLighterAlt;
    result.defaultStateBackground = neutralLighterAlt;
  }
  if (neutralDark) {
    result.actionLinkHovered = neutralDark;
    result.buttonTextHovered = neutralDark;
    result.buttonTextChecked = neutralDark;
    result.buttonTextPressed = neutralDark;
    result.inputTextHovered = neutralDark;
    result.menuItemTextHovered = neutralDark;
  }
  if (neutralSecondary) {
    result.bodySubtext = neutralSecondary;
    result.focusBorder = neutralSecondary;
    result.inputBorder = neutralSecondary;
    result.smallInputBorder = neutralSecondary;
    result.inputPlaceholderText = neutralSecondary;
  }
  if (neutralSecondaryAlt) {
    result.buttonBorder = neutralSecondaryAlt;
  }
  if (neutralTertiaryAlt) {
    result.disabledBodySubtext = neutralTertiaryAlt;
    result.disabledBorder = neutralTertiaryAlt;
    result.buttonBackgroundChecked = neutralTertiaryAlt;
    result.menuDivider = neutralTertiaryAlt;
  }
  if (accent) {
    result.accentButtonBackground = accent;
  }
  if (e === null || e === void 0 ? void 0 : e.elevation4) {
    result.cardShadow = e.elevation4;
  }
  if (!isInverted && (e === null || e === void 0 ? void 0 : e.elevation8)) {
    result.cardShadowHovered = e.elevation8;
  } else if (result.variantBorderHovered) {
    result.cardShadowHovered = "0 0 1px " + result.variantBorderHovered;
  }
  result = __assign(__assign({}, result), s);
  return result;
}
function _fixDeprecatedSlots(s, depComments) {
  var dep = "";
  if (depComments === true) {
    dep = " /* @deprecated */";
  }
  s.listTextColor = s.listText + dep;
  s.menuItemBackgroundChecked += dep;
  s.warningHighlight += dep;
  s.warningText = s.messageText + dep;
  s.successText += dep;
  return s;
}

// node_modules/@fluentui/theme/lib/mergeThemes.js
function mergeThemes(theme, partialTheme) {
  var _a7, _b3, _c3;
  if (partialTheme === void 0) {
    partialTheme = {};
  }
  var mergedTheme = merge({}, theme, partialTheme, {
    semanticColors: getSemanticColors(partialTheme.palette, partialTheme.effects, partialTheme.semanticColors, partialTheme.isInverted === void 0 ? theme.isInverted : partialTheme.isInverted)
  });
  if (((_a7 = partialTheme.palette) === null || _a7 === void 0 ? void 0 : _a7.themePrimary) && !((_b3 = partialTheme.palette) === null || _b3 === void 0 ? void 0 : _b3.accent)) {
    mergedTheme.palette.accent = partialTheme.palette.themePrimary;
  }
  if (partialTheme.defaultFontStyle) {
    for (var _i = 0, _d3 = Object.keys(mergedTheme.fonts); _i < _d3.length; _i++) {
      var fontStyle = _d3[_i];
      mergedTheme.fonts[fontStyle] = merge(mergedTheme.fonts[fontStyle], partialTheme.defaultFontStyle, (_c3 = partialTheme === null || partialTheme === void 0 ? void 0 : partialTheme.fonts) === null || _c3 === void 0 ? void 0 : _c3[fontStyle]);
    }
  }
  return mergedTheme;
}

// node_modules/@fluentui/theme/lib/colors/FluentColors.js
var CommunicationColors;
(function(CommunicationColors2) {
  CommunicationColors2.shade30 = "#004578";
  CommunicationColors2.shade20 = "#005a9e";
  CommunicationColors2.shade10 = "#106ebe";
  CommunicationColors2.primary = "#0078d4";
  CommunicationColors2.tint10 = "#2b88d8";
  CommunicationColors2.tint20 = "#c7e0f4";
  CommunicationColors2.tint30 = "#deecf9";
  CommunicationColors2.tint40 = "#eff6fc";
})(CommunicationColors || (CommunicationColors = {}));
var NeutralColors;
(function(NeutralColors2) {
  NeutralColors2.black = "#000000";
  NeutralColors2.gray220 = "#11100f";
  NeutralColors2.gray210 = "#161514";
  NeutralColors2.gray200 = "#1b1a19";
  NeutralColors2.gray190 = "#201f1e";
  NeutralColors2.gray180 = "#252423";
  NeutralColors2.gray170 = "#292827";
  NeutralColors2.gray160 = "#323130";
  NeutralColors2.gray150 = "#3b3a39";
  NeutralColors2.gray140 = "#484644";
  NeutralColors2.gray130 = "#605e5c";
  NeutralColors2.gray120 = "#797775";
  NeutralColors2.gray110 = "#8a8886";
  NeutralColors2.gray100 = "#979593";
  NeutralColors2.gray90 = "#a19f9d";
  NeutralColors2.gray80 = "#b3b0ad";
  NeutralColors2.gray70 = "#bebbb8";
  NeutralColors2.gray60 = "#c8c6c4";
  NeutralColors2.gray50 = "#d2d0ce";
  NeutralColors2.gray40 = "#e1dfdd";
  NeutralColors2.gray30 = "#edebe9";
  NeutralColors2.gray20 = "#f3f2f1";
  NeutralColors2.gray10 = "#faf9f8";
  NeutralColors2.white = "#ffffff";
})(NeutralColors || (NeutralColors = {}));
var SharedColors;
(function(SharedColors2) {
  SharedColors2.pinkRed10 = "#750b1c";
  SharedColors2.red20 = "#a4262c";
  SharedColors2.red10 = "#d13438";
  SharedColors2.redOrange20 = "#603d30";
  SharedColors2.redOrange10 = "#da3b01";
  SharedColors2.orange30 = "#8e562e";
  SharedColors2.orange20 = "#ca5010";
  SharedColors2.orange10 = "#ffaa44";
  SharedColors2.yellow10 = "#fce100";
  SharedColors2.orangeYellow20 = "#986f0b";
  SharedColors2.orangeYellow10 = "#c19c00";
  SharedColors2.yellowGreen10 = "#8cbd18";
  SharedColors2.green20 = "#0b6a0b";
  SharedColors2.green10 = "#498205";
  SharedColors2.greenCyan10 = "#00ad56";
  SharedColors2.cyan40 = "#005e50";
  SharedColors2.cyan30 = "#005b70";
  SharedColors2.cyan20 = "#038387";
  SharedColors2.cyan10 = "#00b7c3";
  SharedColors2.cyanBlue20 = "#004e8c";
  SharedColors2.cyanBlue10 = "#0078d4";
  SharedColors2.blue10 = "#4f6bed";
  SharedColors2.blueMagenta40 = "#373277";
  SharedColors2.blueMagenta30 = "#5c2e91";
  SharedColors2.blueMagenta20 = "#8764b8";
  SharedColors2.blueMagenta10 = "#8378de";
  SharedColors2.magenta20 = "#881798";
  SharedColors2.magenta10 = "#c239b3";
  SharedColors2.magentaPink20 = "#9b0062";
  SharedColors2.magentaPink10 = "#e3008c";
  SharedColors2.gray40 = "#393939";
  SharedColors2.gray30 = "#7a7574";
  SharedColors2.gray20 = "#69797e";
  SharedColors2.gray10 = "#a0aeb2";
})(SharedColors || (SharedColors = {}));

// node_modules/@fluentui/theme/lib/colors/DefaultPalette.js
var DefaultPalette = {
  themeDarker: "#004578",
  themeDark: "#005a9e",
  themeDarkAlt: "#106ebe",
  themePrimary: "#0078d4",
  themeSecondary: "#2b88d8",
  themeTertiary: "#71afe5",
  themeLight: "#c7e0f4",
  themeLighter: "#deecf9",
  themeLighterAlt: "#eff6fc",
  black: "#000000",
  blackTranslucent40: "rgba(0,0,0,.4)",
  neutralDark: "#201f1e",
  neutralPrimary: "#323130",
  neutralPrimaryAlt: "#3b3a39",
  neutralSecondary: "#605e5c",
  neutralSecondaryAlt: "#8a8886",
  neutralTertiary: "#a19f9d",
  neutralTertiaryAlt: "#c8c6c4",
  neutralQuaternary: "#d2d0ce",
  neutralQuaternaryAlt: "#e1dfdd",
  neutralLight: "#edebe9",
  neutralLighter: "#f3f2f1",
  neutralLighterAlt: "#faf9f8",
  accent: "#0078d4",
  white: "#ffffff",
  whiteTranslucent40: "rgba(255,255,255,.4)",
  yellowDark: "#d29200",
  yellow: "#ffb900",
  yellowLight: "#fff100",
  orange: "#d83b01",
  orangeLight: "#ea4300",
  orangeLighter: "#ff8c00",
  redDark: "#a4262c",
  red: "#e81123",
  magentaDark: "#5c005c",
  magenta: "#b4009e",
  magentaLight: "#e3008c",
  purpleDark: "#32145a",
  purple: "#5c2d91",
  purpleLight: "#b4a0ff",
  blueDark: "#002050",
  blueMid: "#00188f",
  blue: "#0078d4",
  blueLight: "#00bcf2",
  tealDark: "#004b50",
  teal: "#008272",
  tealLight: "#00b294",
  greenDark: "#004b1c",
  green: "#107c10",
  greenLight: "#bad80a"
};

// node_modules/@fluentui/theme/lib/effects/FluentDepths.js
var Depths;
(function(Depths2) {
  Depths2.depth0 = "0 0 0 0 transparent";
  Depths2.depth4 = "0 1.6px 3.6px 0 rgba(0, 0, 0, 0.132), 0 0.3px 0.9px 0 rgba(0, 0, 0, 0.108)";
  Depths2.depth8 = "0 3.2px 7.2px 0 rgba(0, 0, 0, 0.132), 0 0.6px 1.8px 0 rgba(0, 0, 0, 0.108)";
  Depths2.depth16 = "0 6.4px 14.4px 0 rgba(0, 0, 0, 0.132), 0 1.2px 3.6px 0 rgba(0, 0, 0, 0.108)";
  Depths2.depth64 = "0 25.6px 57.6px 0 rgba(0, 0, 0, 0.22), 0 4.8px 14.4px 0 rgba(0, 0, 0, 0.18)";
})(Depths || (Depths = {}));

// node_modules/@fluentui/theme/lib/effects/DefaultEffects.js
var DefaultEffects = {
  elevation4: Depths.depth4,
  elevation8: Depths.depth8,
  elevation16: Depths.depth16,
  elevation64: Depths.depth64,
  roundedCorner2: "2px",
  roundedCorner4: "4px",
  roundedCorner6: "6px"
};

// node_modules/@fluentui/theme/lib/spacing/DefaultSpacing.js
var DefaultSpacing = {
  s2: "4px",
  s1: "8px",
  m: "16px",
  l1: "20px",
  l2: "32px"
};

// node_modules/@fluentui/theme/lib/motion/FluentMotion.js
var fadeInAnimationName = keyframes({
  from: { opacity: 0 },
  to: { opacity: 1 }
});
var fadeOutAnimationName = keyframes({
  from: { opacity: 1 },
  to: { opacity: 0 }
});
var scaleDownInAnimationName = keyframes({
  from: { transform: "scale3d(1.15, 1.15, 1)" },
  to: { transform: "scale3d(1, 1, 1)" }
});
var scaleDownOutAnimationName = keyframes({
  from: { transform: "scale3d(1, 1, 1)" },
  to: { transform: "scale3d(0.9, 0.9, 1)" }
});
var slideLeftOutAnimationName = keyframes({
  from: { transform: "translate3d(0, 0, 0)" },
  to: { transform: "translate3d(-48px, 0, 0)" }
});
var slideRightOutAnimationName = keyframes({
  from: { transform: "translate3d(0, 0, 0)" },
  to: { transform: "translate3d(48px, 0, 0)" }
});
var slideLeftInAnimationName = keyframes({
  from: { transform: "translate3d(48px, 0, 0)" },
  to: { transform: "translate3d(0, 0, 0)" }
});
var slideRightInAnimationName = keyframes({
  from: { transform: "translate3d(-48px, 0, 0)" },
  to: { transform: "translate3d(0, 0, 0)" }
});
var slideUpOutAnimationName = keyframes({
  from: { transform: "translate3d(0, 0, 0)" },
  to: { transform: "translate3d(0, -48px, 0)" }
});
var slideDownOutAnimationName = keyframes({
  from: { transform: "translate3d(0, 0, 0)" },
  to: { transform: "translate3d(0, 48px, 0)" }
});
var slideUpInAnimationName = keyframes({
  from: { transform: "translate3d(0, 48px, 0)" },
  to: { transform: "translate3d(0, 0, 0)" }
});
var slideDownInAnimationName = keyframes({
  from: { transform: "translate3d(0, -48px, 0)" },
  to: { transform: "translate3d(0, 0, 0)" }
});
var MotionDurations;
(function(MotionDurations2) {
  MotionDurations2.duration1 = "100ms";
  MotionDurations2.duration2 = "200ms";
  MotionDurations2.duration3 = "300ms";
  MotionDurations2.duration4 = "400ms";
})(MotionDurations || (MotionDurations = {}));
var MotionTimings;
(function(MotionTimings2) {
  MotionTimings2.accelerate = "cubic-bezier(0.9, 0.1, 1, 0.2)";
  MotionTimings2.decelerate = "cubic-bezier(0.1, 0.9, 0.2, 1)";
  MotionTimings2.linear = "cubic-bezier(0, 0, 1, 1)";
  MotionTimings2.standard = "cubic-bezier(0.8, 0, 0.2, 1)";
})(MotionTimings || (MotionTimings = {}));
function _createAnimation(animationName, animationDuration, animationTimingFunction) {
  return "".concat(animationName, " ").concat(animationDuration, " ").concat(animationTimingFunction);
}
var MotionAnimations;
(function(MotionAnimations2) {
  MotionAnimations2.fadeIn = _createAnimation(fadeInAnimationName, MotionDurations.duration1, MotionTimings.linear);
  MotionAnimations2.fadeOut = _createAnimation(fadeOutAnimationName, MotionDurations.duration1, MotionTimings.linear);
  MotionAnimations2.scaleDownIn = _createAnimation(scaleDownInAnimationName, MotionDurations.duration3, MotionTimings.decelerate);
  MotionAnimations2.scaleDownOut = _createAnimation(scaleDownOutAnimationName, MotionDurations.duration3, MotionTimings.decelerate);
  MotionAnimations2.slideLeftOut = _createAnimation(slideLeftOutAnimationName, MotionDurations.duration1, MotionTimings.accelerate);
  MotionAnimations2.slideRightOut = _createAnimation(slideRightOutAnimationName, MotionDurations.duration1, MotionTimings.accelerate);
  MotionAnimations2.slideLeftIn = _createAnimation(slideLeftInAnimationName, MotionDurations.duration1, MotionTimings.decelerate);
  MotionAnimations2.slideRightIn = _createAnimation(slideRightInAnimationName, MotionDurations.duration1, MotionTimings.decelerate);
  MotionAnimations2.slideUpOut = _createAnimation(slideUpOutAnimationName, MotionDurations.duration1, MotionTimings.accelerate);
  MotionAnimations2.slideDownOut = _createAnimation(slideDownOutAnimationName, MotionDurations.duration1, MotionTimings.accelerate);
  MotionAnimations2.slideUpIn = _createAnimation(slideUpInAnimationName, MotionDurations.duration1, MotionTimings.decelerate);
  MotionAnimations2.slideDownIn = _createAnimation(slideDownInAnimationName, MotionDurations.duration1, MotionTimings.decelerate);
})(MotionAnimations || (MotionAnimations = {}));

// node_modules/@fluentui/theme/lib/motion/AnimationStyles.js
var EASING_FUNCTION_1 = "cubic-bezier(.1,.9,.2,1)";
var EASING_FUNCTION_2 = "cubic-bezier(.1,.25,.75,.9)";
var DURATION_1 = "0.167s";
var DURATION_2 = "0.267s";
var DURATION_3 = "0.367s";
var DURATION_4 = "0.467s";
var FADE_IN = keyframes({
  from: { opacity: 0 },
  to: { opacity: 1 }
});
var FADE_OUT = keyframes({
  from: { opacity: 1 },
  to: { opacity: 0, visibility: "hidden" }
});
var SLIDE_RIGHT_IN10 = _createSlideInX(-10);
var SLIDE_RIGHT_IN20 = _createSlideInX(-20);
var SLIDE_RIGHT_IN40 = _createSlideInX(-40);
var SLIDE_RIGHT_IN400 = _createSlideInX(-400);
var SLIDE_LEFT_IN10 = _createSlideInX(10);
var SLIDE_LEFT_IN20 = _createSlideInX(20);
var SLIDE_LEFT_IN40 = _createSlideInX(40);
var SLIDE_LEFT_IN400 = _createSlideInX(400);
var SLIDE_UP_IN10 = _createSlideInY(10);
var SLIDE_UP_IN20 = _createSlideInY(20);
var SLIDE_DOWN_IN10 = _createSlideInY(-10);
var SLIDE_DOWN_IN20 = _createSlideInY(-20);
var SLIDE_RIGHT_OUT10 = _createSlideOutX(10);
var SLIDE_RIGHT_OUT20 = _createSlideOutX(20);
var SLIDE_RIGHT_OUT40 = _createSlideOutX(40);
var SLIDE_RIGHT_OUT400 = _createSlideOutX(400);
var SLIDE_LEFT_OUT10 = _createSlideOutX(-10);
var SLIDE_LEFT_OUT20 = _createSlideOutX(-20);
var SLIDE_LEFT_OUT40 = _createSlideOutX(-40);
var SLIDE_LEFT_OUT400 = _createSlideOutX(-400);
var SLIDE_UP_OUT10 = _createSlideOutY(-10);
var SLIDE_UP_OUT20 = _createSlideOutY(-20);
var SLIDE_DOWN_OUT10 = _createSlideOutY(10);
var SLIDE_DOWN_OUT20 = _createSlideOutY(20);
var SCALE_UP100 = keyframes({
  from: { transform: "scale3d(.98,.98,1)" },
  to: { transform: "scale3d(1,1,1)" }
});
var SCALE_DOWN98 = keyframes({
  from: { transform: "scale3d(1,1,1)" },
  to: { transform: "scale3d(.98,.98,1)" }
});
var SCALE_DOWN100 = keyframes({
  from: { transform: "scale3d(1.03,1.03,1)" },
  to: { transform: "scale3d(1,1,1)" }
});
var SCALE_UP103 = keyframes({
  from: { transform: "scale3d(1,1,1)" },
  to: { transform: "scale3d(1.03,1.03,1)" }
});
var ROTATE90 = keyframes({
  from: { transform: "rotateZ(0deg)" },
  to: { transform: "rotateZ(90deg)" }
});
var ROTATE_N90 = keyframes({
  from: { transform: "rotateZ(0deg)" },
  to: { transform: "rotateZ(-90deg)" }
});
var AnimationVariables = {
  easeFunction1: EASING_FUNCTION_1,
  easeFunction2: EASING_FUNCTION_2,
  durationValue1: DURATION_1,
  durationValue2: DURATION_2,
  durationValue3: DURATION_3,
  durationValue4: DURATION_4
};
var AnimationStyles = {
  slideRightIn10: _createAnimation2("".concat(FADE_IN, ",").concat(SLIDE_RIGHT_IN10), DURATION_3, EASING_FUNCTION_1),
  slideRightIn20: _createAnimation2("".concat(FADE_IN, ",").concat(SLIDE_RIGHT_IN20), DURATION_3, EASING_FUNCTION_1),
  slideRightIn40: _createAnimation2("".concat(FADE_IN, ",").concat(SLIDE_RIGHT_IN40), DURATION_3, EASING_FUNCTION_1),
  slideRightIn400: _createAnimation2("".concat(FADE_IN, ",").concat(SLIDE_RIGHT_IN400), DURATION_3, EASING_FUNCTION_1),
  slideLeftIn10: _createAnimation2("".concat(FADE_IN, ",").concat(SLIDE_LEFT_IN10), DURATION_3, EASING_FUNCTION_1),
  slideLeftIn20: _createAnimation2("".concat(FADE_IN, ",").concat(SLIDE_LEFT_IN20), DURATION_3, EASING_FUNCTION_1),
  slideLeftIn40: _createAnimation2("".concat(FADE_IN, ",").concat(SLIDE_LEFT_IN40), DURATION_3, EASING_FUNCTION_1),
  slideLeftIn400: _createAnimation2("".concat(FADE_IN, ",").concat(SLIDE_LEFT_IN400), DURATION_3, EASING_FUNCTION_1),
  slideUpIn10: _createAnimation2("".concat(FADE_IN, ",").concat(SLIDE_UP_IN10), DURATION_3, EASING_FUNCTION_1),
  slideUpIn20: _createAnimation2("".concat(FADE_IN, ",").concat(SLIDE_UP_IN20), DURATION_3, EASING_FUNCTION_1),
  slideDownIn10: _createAnimation2("".concat(FADE_IN, ",").concat(SLIDE_DOWN_IN10), DURATION_3, EASING_FUNCTION_1),
  slideDownIn20: _createAnimation2("".concat(FADE_IN, ",").concat(SLIDE_DOWN_IN20), DURATION_3, EASING_FUNCTION_1),
  slideRightOut10: _createAnimation2("".concat(FADE_OUT, ",").concat(SLIDE_RIGHT_OUT10), DURATION_3, EASING_FUNCTION_1),
  slideRightOut20: _createAnimation2("".concat(FADE_OUT, ",").concat(SLIDE_RIGHT_OUT20), DURATION_3, EASING_FUNCTION_1),
  slideRightOut40: _createAnimation2("".concat(FADE_OUT, ",").concat(SLIDE_RIGHT_OUT40), DURATION_3, EASING_FUNCTION_1),
  slideRightOut400: _createAnimation2("".concat(FADE_OUT, ",").concat(SLIDE_RIGHT_OUT400), DURATION_3, EASING_FUNCTION_1),
  slideLeftOut10: _createAnimation2("".concat(FADE_OUT, ",").concat(SLIDE_LEFT_OUT10), DURATION_3, EASING_FUNCTION_1),
  slideLeftOut20: _createAnimation2("".concat(FADE_OUT, ",").concat(SLIDE_LEFT_OUT20), DURATION_3, EASING_FUNCTION_1),
  slideLeftOut40: _createAnimation2("".concat(FADE_OUT, ",").concat(SLIDE_LEFT_OUT40), DURATION_3, EASING_FUNCTION_1),
  slideLeftOut400: _createAnimation2("".concat(FADE_OUT, ",").concat(SLIDE_LEFT_OUT400), DURATION_3, EASING_FUNCTION_1),
  slideUpOut10: _createAnimation2("".concat(FADE_OUT, ",").concat(SLIDE_UP_OUT10), DURATION_3, EASING_FUNCTION_1),
  slideUpOut20: _createAnimation2("".concat(FADE_OUT, ",").concat(SLIDE_UP_OUT20), DURATION_3, EASING_FUNCTION_1),
  slideDownOut10: _createAnimation2("".concat(FADE_OUT, ",").concat(SLIDE_DOWN_OUT10), DURATION_3, EASING_FUNCTION_1),
  slideDownOut20: _createAnimation2("".concat(FADE_OUT, ",").concat(SLIDE_DOWN_OUT20), DURATION_3, EASING_FUNCTION_1),
  scaleUpIn100: _createAnimation2("".concat(FADE_IN, ",").concat(SCALE_UP100), DURATION_3, EASING_FUNCTION_1),
  scaleDownIn100: _createAnimation2("".concat(FADE_IN, ",").concat(SCALE_DOWN100), DURATION_3, EASING_FUNCTION_1),
  scaleUpOut103: _createAnimation2("".concat(FADE_OUT, ",").concat(SCALE_UP103), DURATION_1, EASING_FUNCTION_2),
  scaleDownOut98: _createAnimation2("".concat(FADE_OUT, ",").concat(SCALE_DOWN98), DURATION_1, EASING_FUNCTION_2),
  fadeIn100: _createAnimation2(FADE_IN, DURATION_1, EASING_FUNCTION_2),
  fadeIn200: _createAnimation2(FADE_IN, DURATION_2, EASING_FUNCTION_2),
  fadeIn400: _createAnimation2(FADE_IN, DURATION_3, EASING_FUNCTION_2),
  fadeIn500: _createAnimation2(FADE_IN, DURATION_4, EASING_FUNCTION_2),
  fadeOut100: _createAnimation2(FADE_OUT, DURATION_1, EASING_FUNCTION_2),
  fadeOut200: _createAnimation2(FADE_OUT, DURATION_2, EASING_FUNCTION_2),
  fadeOut400: _createAnimation2(FADE_OUT, DURATION_3, EASING_FUNCTION_2),
  fadeOut500: _createAnimation2(FADE_OUT, DURATION_4, EASING_FUNCTION_2),
  rotate90deg: _createAnimation2(ROTATE90, "0.1s", EASING_FUNCTION_2),
  rotateN90deg: _createAnimation2(ROTATE_N90, "0.1s", EASING_FUNCTION_2)
  // expandCollapse 100/200/400, delay 100/200
};
function _createAnimation2(animationName, animationDuration, animationTimingFunction) {
  return {
    animationName,
    animationDuration,
    animationTimingFunction,
    animationFillMode: "both"
  };
}
function _createSlideInX(fromX) {
  return keyframes({
    from: { transform: "translate3d(".concat(fromX, "px,0,0)"), pointerEvents: "none" },
    to: { transform: "translate3d(0,0,0)", pointerEvents: "auto" }
  });
}
function _createSlideInY(fromY) {
  return keyframes({
    from: { transform: "translate3d(0,".concat(fromY, "px,0)"), pointerEvents: "none" },
    to: { transform: "translate3d(0,0,0)", pointerEvents: "auto" }
  });
}
function _createSlideOutX(toX) {
  return keyframes({
    from: { transform: "translate3d(0,0,0)" },
    to: { transform: "translate3d(".concat(toX, "px,0,0)") }
  });
}
function _createSlideOutY(toY) {
  return keyframes({
    from: { transform: "translate3d(0,0,0)" },
    to: { transform: "translate3d(0,".concat(toY, "px,0)") }
  });
}

// node_modules/@fluentui/theme/lib/fonts/FluentFonts.js
var LocalizedFontNames;
(function(LocalizedFontNames2) {
  LocalizedFontNames2.Arabic = "Segoe UI Web (Arabic)";
  LocalizedFontNames2.Cyrillic = "Segoe UI Web (Cyrillic)";
  LocalizedFontNames2.EastEuropean = "Segoe UI Web (East European)";
  LocalizedFontNames2.Greek = "Segoe UI Web (Greek)";
  LocalizedFontNames2.Hebrew = "Segoe UI Web (Hebrew)";
  LocalizedFontNames2.Thai = "Leelawadee UI Web";
  LocalizedFontNames2.Vietnamese = "Segoe UI Web (Vietnamese)";
  LocalizedFontNames2.WestEuropean = "Segoe UI Web (West European)";
  LocalizedFontNames2.Selawik = "Selawik Web";
  LocalizedFontNames2.Armenian = "Segoe UI Web (Armenian)";
  LocalizedFontNames2.Georgian = "Segoe UI Web (Georgian)";
})(LocalizedFontNames || (LocalizedFontNames = {}));
var LocalizedFontFamilies;
(function(LocalizedFontFamilies2) {
  LocalizedFontFamilies2.Arabic = "'".concat(LocalizedFontNames.Arabic, "'");
  LocalizedFontFamilies2.ChineseSimplified = "'Microsoft Yahei UI', Verdana, Simsun";
  LocalizedFontFamilies2.ChineseTraditional = "'Microsoft Jhenghei UI', Pmingliu";
  LocalizedFontFamilies2.Cyrillic = "'".concat(LocalizedFontNames.Cyrillic, "'");
  LocalizedFontFamilies2.EastEuropean = "'".concat(LocalizedFontNames.EastEuropean, "'");
  LocalizedFontFamilies2.Greek = "'".concat(LocalizedFontNames.Greek, "'");
  LocalizedFontFamilies2.Hebrew = "'".concat(LocalizedFontNames.Hebrew, "'");
  LocalizedFontFamilies2.Hindi = "'Nirmala UI'";
  LocalizedFontFamilies2.Japanese = "'Yu Gothic UI', 'Meiryo UI', Meiryo, 'MS Pgothic', Osaka";
  LocalizedFontFamilies2.Korean = "'Malgun Gothic', Gulim";
  LocalizedFontFamilies2.Selawik = "'".concat(LocalizedFontNames.Selawik, "'");
  LocalizedFontFamilies2.Thai = "'Leelawadee UI Web', 'Kmer UI'";
  LocalizedFontFamilies2.Vietnamese = "'".concat(LocalizedFontNames.Vietnamese, "'");
  LocalizedFontFamilies2.WestEuropean = "'".concat(LocalizedFontNames.WestEuropean, "'");
  LocalizedFontFamilies2.Armenian = "'".concat(LocalizedFontNames.Armenian, "'");
  LocalizedFontFamilies2.Georgian = "'".concat(LocalizedFontNames.Georgian, "'");
})(LocalizedFontFamilies || (LocalizedFontFamilies = {}));
var FontSizes;
(function(FontSizes2) {
  FontSizes2.size10 = "10px";
  FontSizes2.size12 = "12px";
  FontSizes2.size14 = "14px";
  FontSizes2.size16 = "16px";
  FontSizes2.size18 = "18px";
  FontSizes2.size20 = "20px";
  FontSizes2.size24 = "24px";
  FontSizes2.size28 = "28px";
  FontSizes2.size32 = "32px";
  FontSizes2.size42 = "42px";
  FontSizes2.size68 = "68px";
  FontSizes2.mini = "10px";
  FontSizes2.xSmall = "10px";
  FontSizes2.small = "12px";
  FontSizes2.smallPlus = "12px";
  FontSizes2.medium = "14px";
  FontSizes2.mediumPlus = "16px";
  FontSizes2.icon = "16px";
  FontSizes2.large = "18px";
  FontSizes2.xLarge = "20px";
  FontSizes2.xLargePlus = "24px";
  FontSizes2.xxLarge = "28px";
  FontSizes2.xxLargePlus = "32px";
  FontSizes2.superLarge = "42px";
  FontSizes2.mega = "68px";
})(FontSizes || (FontSizes = {}));
var FontWeights;
(function(FontWeights2) {
  FontWeights2.light = 100;
  FontWeights2.semilight = 300;
  FontWeights2.regular = 400;
  FontWeights2.semibold = 600;
  FontWeights2.bold = 700;
})(FontWeights || (FontWeights = {}));
var IconFontSizes;
(function(IconFontSizes2) {
  IconFontSizes2.xSmall = "10px";
  IconFontSizes2.small = "12px";
  IconFontSizes2.medium = "16px";
  IconFontSizes2.large = "20px";
})(IconFontSizes || (IconFontSizes = {}));

// node_modules/@fluentui/theme/lib/fonts/createFontStyles.js
var FontFamilyFallbacks = "'Segoe UI', -apple-system, BlinkMacSystemFont, 'Roboto', 'Helvetica Neue', sans-serif";
var defaultFontFamily = "'Segoe UI', '".concat(LocalizedFontNames.WestEuropean, "'");
var LanguageToFontMap = {
  ar: LocalizedFontFamilies.Arabic,
  bg: LocalizedFontFamilies.Cyrillic,
  cs: LocalizedFontFamilies.EastEuropean,
  el: LocalizedFontFamilies.Greek,
  et: LocalizedFontFamilies.EastEuropean,
  he: LocalizedFontFamilies.Hebrew,
  hi: LocalizedFontFamilies.Hindi,
  hr: LocalizedFontFamilies.EastEuropean,
  hu: LocalizedFontFamilies.EastEuropean,
  ja: LocalizedFontFamilies.Japanese,
  kk: LocalizedFontFamilies.EastEuropean,
  ko: LocalizedFontFamilies.Korean,
  lt: LocalizedFontFamilies.EastEuropean,
  lv: LocalizedFontFamilies.EastEuropean,
  pl: LocalizedFontFamilies.EastEuropean,
  ru: LocalizedFontFamilies.Cyrillic,
  sk: LocalizedFontFamilies.EastEuropean,
  "sr-latn": LocalizedFontFamilies.EastEuropean,
  th: LocalizedFontFamilies.Thai,
  tr: LocalizedFontFamilies.EastEuropean,
  uk: LocalizedFontFamilies.Cyrillic,
  vi: LocalizedFontFamilies.Vietnamese,
  "zh-hans": LocalizedFontFamilies.ChineseSimplified,
  "zh-hant": LocalizedFontFamilies.ChineseTraditional,
  hy: LocalizedFontFamilies.Armenian,
  ka: LocalizedFontFamilies.Georgian
};
function _fontFamilyWithFallbacks(fontFamily) {
  return "".concat(fontFamily, ", ").concat(FontFamilyFallbacks);
}
function _getLocalizedFontFamily(language) {
  for (var lang in LanguageToFontMap) {
    if (LanguageToFontMap.hasOwnProperty(lang) && language && lang.indexOf(language) === 0) {
      return LanguageToFontMap[lang];
    }
  }
  return defaultFontFamily;
}
function _createFont(size, weight, fontFamily) {
  return {
    fontFamily,
    MozOsxFontSmoothing: "grayscale",
    WebkitFontSmoothing: "antialiased",
    fontSize: size,
    fontWeight: weight
  };
}
function createFontStyles(localeCode) {
  var localizedFont = _getLocalizedFontFamily(localeCode);
  var fontFamilyWithFallback = _fontFamilyWithFallbacks(localizedFont);
  var fontStyles = {
    tiny: _createFont(FontSizes.mini, FontWeights.regular, fontFamilyWithFallback),
    xSmall: _createFont(FontSizes.xSmall, FontWeights.regular, fontFamilyWithFallback),
    small: _createFont(FontSizes.small, FontWeights.regular, fontFamilyWithFallback),
    smallPlus: _createFont(FontSizes.smallPlus, FontWeights.regular, fontFamilyWithFallback),
    medium: _createFont(FontSizes.medium, FontWeights.regular, fontFamilyWithFallback),
    mediumPlus: _createFont(FontSizes.mediumPlus, FontWeights.regular, fontFamilyWithFallback),
    large: _createFont(FontSizes.large, FontWeights.regular, fontFamilyWithFallback),
    xLarge: _createFont(FontSizes.xLarge, FontWeights.semibold, fontFamilyWithFallback),
    xLargePlus: _createFont(FontSizes.xLargePlus, FontWeights.semibold, fontFamilyWithFallback),
    xxLarge: _createFont(FontSizes.xxLarge, FontWeights.semibold, fontFamilyWithFallback),
    xxLargePlus: _createFont(FontSizes.xxLargePlus, FontWeights.semibold, fontFamilyWithFallback),
    superLarge: _createFont(FontSizes.superLarge, FontWeights.semibold, fontFamilyWithFallback),
    mega: _createFont(FontSizes.mega, FontWeights.semibold, fontFamilyWithFallback)
  };
  return fontStyles;
}

// node_modules/@fluentui/theme/lib/fonts/DefaultFontStyles.js
var DefaultBaseUrl = "https://res-1.cdn.office.net/files/fabric-cdn-prod_20230815.002/assets";
var DefaultFontStyles = createFontStyles(getLanguage());
function _registerFontFace(fontFamily, url, fontWeight, localFontName) {
  fontFamily = "'".concat(fontFamily, "'");
  var localFontSrc = localFontName !== void 0 ? "local('".concat(localFontName, "'),") : "";
  fontFace({
    fontFamily,
    src: localFontSrc + "url('".concat(url, ".woff2') format('woff2'),") + "url('".concat(url, ".woff') format('woff')"),
    fontWeight,
    fontStyle: "normal",
    fontDisplay: "swap"
  });
}
function _registerFontFaceSet(baseUrl, fontFamily, cdnFolder, cdnFontName, localFontName) {
  if (cdnFontName === void 0) {
    cdnFontName = "segoeui";
  }
  var urlBase = "".concat(baseUrl, "/").concat(cdnFolder, "/").concat(cdnFontName);
  _registerFontFace(fontFamily, urlBase + "-light", FontWeights.light, localFontName && localFontName + " Light");
  _registerFontFace(fontFamily, urlBase + "-semilight", FontWeights.semilight, localFontName && localFontName + " SemiLight");
  _registerFontFace(fontFamily, urlBase + "-regular", FontWeights.regular, localFontName);
  _registerFontFace(fontFamily, urlBase + "-semibold", FontWeights.semibold, localFontName && localFontName + " SemiBold");
  _registerFontFace(fontFamily, urlBase + "-bold", FontWeights.bold, localFontName && localFontName + " Bold");
}
function registerDefaultFontFaces(baseUrl) {
  if (baseUrl) {
    var fontUrl = "".concat(baseUrl, "/fonts");
    _registerFontFaceSet(fontUrl, LocalizedFontNames.Thai, "leelawadeeui-thai", "leelawadeeui");
    _registerFontFaceSet(fontUrl, LocalizedFontNames.Arabic, "segoeui-arabic");
    _registerFontFaceSet(fontUrl, LocalizedFontNames.Cyrillic, "segoeui-cyrillic");
    _registerFontFaceSet(fontUrl, LocalizedFontNames.EastEuropean, "segoeui-easteuropean");
    _registerFontFaceSet(fontUrl, LocalizedFontNames.Greek, "segoeui-greek");
    _registerFontFaceSet(fontUrl, LocalizedFontNames.Hebrew, "segoeui-hebrew");
    _registerFontFaceSet(fontUrl, LocalizedFontNames.Vietnamese, "segoeui-vietnamese");
    _registerFontFaceSet(fontUrl, LocalizedFontNames.WestEuropean, "segoeui-westeuropean", "segoeui", "Segoe UI");
    _registerFontFaceSet(fontUrl, LocalizedFontFamilies.Selawik, "selawik", "selawik");
    _registerFontFaceSet(fontUrl, LocalizedFontNames.Armenian, "segoeui-armenian");
    _registerFontFaceSet(fontUrl, LocalizedFontNames.Georgian, "segoeui-georgian");
    _registerFontFace("Leelawadee UI Web", "".concat(fontUrl, "/leelawadeeui-thai/leelawadeeui-semilight"), FontWeights.light);
    _registerFontFace("Leelawadee UI Web", "".concat(fontUrl, "/leelawadeeui-thai/leelawadeeui-bold"), FontWeights.semibold);
  }
}
function _getFontBaseUrl() {
  var _a7, _b3;
  var fabricConfig = (_a7 = getWindow()) === null || _a7 === void 0 ? void 0 : _a7.FabricConfig;
  return (_b3 = fabricConfig === null || fabricConfig === void 0 ? void 0 : fabricConfig.fontBaseUrl) !== null && _b3 !== void 0 ? _b3 : DefaultBaseUrl;
}
registerDefaultFontFaces(_getFontBaseUrl());

// node_modules/@fluentui/theme/lib/createTheme.js
function createTheme(theme, depComments) {
  if (theme === void 0) {
    theme = {};
  }
  if (depComments === void 0) {
    depComments = false;
  }
  var isInverted = !!theme.isInverted;
  var baseTheme = {
    palette: DefaultPalette,
    effects: DefaultEffects,
    fonts: DefaultFontStyles,
    spacing: DefaultSpacing,
    isInverted,
    disableGlobalClassNames: false,
    semanticColors: makeSemanticColors(DefaultPalette, DefaultEffects, void 0, isInverted, depComments),
    rtl: void 0
  };
  return mergeThemes(baseTheme, theme);
}

// node_modules/@fluentui/theme/lib/FluentTheme.js
var FluentTheme = createTheme({});

// node_modules/@fluentui/theme/lib/version.js
setVersion("@fluentui/theme", "2.6.41");

// node_modules/@fluentui/style-utilities/lib/styles/CommonStyles.js
var HighContrastSelector = "@media screen and (-ms-high-contrast: active), screen and (forced-colors: active)";
var HighContrastSelectorWhite = (
  // eslint-disable-next-line @fluentui/max-len
  "@media screen and (-ms-high-contrast: black-on-white), screen and (forced-colors: active) and (prefers-color-scheme: light)"
);
var ScreenWidthMinMedium = 480;
var ScreenWidthMinLarge = 640;
var ScreenWidthMinXLarge = 1024;
var ScreenWidthMinXXLarge = 1366;
var ScreenWidthMinXXXLarge = 1920;
var ScreenWidthMaxSmall = ScreenWidthMinMedium - 1;
var ScreenWidthMaxMedium = ScreenWidthMinLarge - 1;
var ScreenWidthMaxLarge = ScreenWidthMinXLarge - 1;
var ScreenWidthMaxXLarge = ScreenWidthMinXXLarge - 1;
var ScreenWidthMaxXXLarge = ScreenWidthMinXXXLarge - 1;
var ScreenWidthMinUhfMobile = 768;
function getScreenSelector(min, max) {
  var minSelector = typeof min === "number" ? " and (min-width: ".concat(min, "px)") : "";
  var maxSelector = typeof max === "number" ? " and (max-width: ".concat(max, "px)") : "";
  return "@media only screen".concat(minSelector).concat(maxSelector);
}
function getHighContrastNoAdjustStyle() {
  return {
    forcedColorAdjust: "none",
    MsHighContrastAdjust: "none"
  };
}

// node_modules/@fluentui/style-utilities/lib/styles/zIndexes.js
var ZIndexes;
(function(ZIndexes2) {
  ZIndexes2.Nav = 1;
  ZIndexes2.ScrollablePane = 1;
  ZIndexes2.FocusStyle = 1;
  ZIndexes2.Coachmark = 1e3;
  ZIndexes2.Layer = 1e6;
  ZIndexes2.KeytipLayer = 1000001;
})(ZIndexes || (ZIndexes = {}));

// node_modules/@fluentui/style-utilities/lib/styles/getFocusStyle.js
function getFocusStyle(theme, insetOrOptions, position, highContrastStyle, borderColor, outlineColor, isFocusedOnly, borderRadius) {
  if (typeof insetOrOptions === "number" || !insetOrOptions) {
    return _getFocusStyleInternal(theme, {
      inset: insetOrOptions,
      position,
      highContrastStyle,
      borderColor,
      outlineColor,
      isFocusedOnly,
      borderRadius
    });
  } else {
    return _getFocusStyleInternal(theme, insetOrOptions);
  }
}
function _getFocusStyleInternal(theme, options) {
  var _a7, _b3;
  if (options === void 0) {
    options = {};
  }
  var borderRadius = options.borderRadius, _c3 = options.inset, inset = _c3 === void 0 ? 0 : _c3, _d3 = options.width, width = _d3 === void 0 ? 1 : _d3, _e2 = options.position, position = _e2 === void 0 ? "relative" : _e2, highContrastStyle = options.highContrastStyle, _f = options.borderColor, borderColor = _f === void 0 ? theme.palette.white : _f, _g = options.outlineColor, outlineColor = _g === void 0 ? theme.palette.neutralSecondary : _g, _h = options.isFocusedOnly, isFocusedOnly = _h === void 0 ? true : _h, pointerEvents = options.pointerEvents;
  return {
    // Clear browser-specific focus styles and use 'transparent' as placeholder for focus style.
    outline: "transparent",
    // Requirement because pseudo-element is absolutely positioned.
    position,
    selectors: (_a7 = {
      // Clear the focus border in Firefox.
      // Reference: http://stackoverflow.com/a/199319/1436671
      "::-moz-focus-inner": {
        border: "0"
      }
    }, // When the element that uses this mixin is in a :focus state, add a pseudo-element to
    // create a border.
    _a7[".".concat(IsFocusVisibleClassName, " &").concat(isFocusedOnly ? ":focus" : "", ":after")] = {
      content: '""',
      position: "absolute",
      pointerEvents,
      left: inset + 1,
      top: inset + 1,
      bottom: inset + 1,
      right: inset + 1,
      border: "".concat(width, "px solid ").concat(borderColor),
      outline: "".concat(width, "px solid ").concat(outlineColor),
      zIndex: ZIndexes.FocusStyle,
      borderRadius,
      selectors: (_b3 = {}, _b3[HighContrastSelector] = highContrastStyle, _b3)
    }, _a7)
  };
}
function focusClear() {
  return {
    selectors: {
      "&::-moz-focus-inner": {
        // Clear the focus border in Firefox. Reference: http://stackoverflow.com/a/199319/1436671
        border: 0
      },
      "&": {
        // Clear browser specific focus styles and use transparent as placeholder for focus style
        outline: "transparent"
      }
    }
  };
}

// node_modules/@fluentui/style-utilities/lib/styles/hiddenContentStyle.js
var hiddenContentStyle = {
  position: "absolute",
  width: 1,
  height: 1,
  margin: -1,
  padding: 0,
  border: 0,
  overflow: "hidden",
  whiteSpace: "nowrap"
};

// node_modules/@fluentui/style-utilities/lib/styles/getGlobalClassNames.js
var _getGlobalClassNames = memoizeFunction(function(classNames2, disableGlobalClassNames) {
  var styleSheet = Stylesheet.getInstance();
  if (disableGlobalClassNames) {
    return Object.keys(classNames2).reduce(function(acc, className) {
      acc[className] = styleSheet.getClassName(classNames2[className]);
      return acc;
    }, {});
  }
  return classNames2;
});
function getGlobalClassNames(classNames2, theme, disableGlobalClassNames) {
  return _getGlobalClassNames(classNames2, disableGlobalClassNames !== void 0 ? disableGlobalClassNames : theme.disableGlobalClassNames);
}

// node_modules/@microsoft/load-themed-styles/lib-es6/index.js
var __assign2 = function() {
  __assign2 = Object.assign || function(t) {
    for (var s, i = 1, n = arguments.length; i < n; i++) {
      s = arguments[i];
      for (var p in s)
        if (Object.prototype.hasOwnProperty.call(s, p))
          t[p] = s[p];
    }
    return t;
  };
  return __assign2.apply(this, arguments);
};
var _root = typeof window === "undefined" ? global : window;
var _styleNonce = _root && _root.CSPSettings && _root.CSPSettings.nonce;
var _themeState = initializeThemeState();
function initializeThemeState() {
  var state = _root.__themeState__ || {
    theme: void 0,
    lastStyleElement: void 0,
    registeredStyles: []
  };
  if (!state.runState) {
    state = __assign2(__assign2({}, state), { perf: {
      count: 0,
      duration: 0
    }, runState: {
      flushTimer: 0,
      mode: 0,
      buffer: []
    } });
  }
  if (!state.registeredThemableStyles) {
    state = __assign2(__assign2({}, state), { registeredThemableStyles: [] });
  }
  _root.__themeState__ = state;
  return state;
}
function applyThemableStyles(stylesArray, styleRecord) {
  if (_themeState.loadStyles) {
    _themeState.loadStyles(resolveThemableArray(stylesArray).styleString, stylesArray);
  } else {
    registerStyles(stylesArray);
  }
}
function loadTheme(theme) {
  _themeState.theme = theme;
  reloadStyles();
}
function clearStyles(option) {
  if (option === void 0) {
    option = 3;
  }
  if (option === 3 || option === 2) {
    clearStylesInternal(_themeState.registeredStyles);
    _themeState.registeredStyles = [];
  }
  if (option === 3 || option === 1) {
    clearStylesInternal(_themeState.registeredThemableStyles);
    _themeState.registeredThemableStyles = [];
  }
}
function clearStylesInternal(records) {
  records.forEach(function(styleRecord) {
    var styleElement = styleRecord && styleRecord.styleElement;
    if (styleElement && styleElement.parentElement) {
      styleElement.parentElement.removeChild(styleElement);
    }
  });
}
function reloadStyles() {
  if (_themeState.theme) {
    var themableStyles = [];
    for (var _i = 0, _a7 = _themeState.registeredThemableStyles; _i < _a7.length; _i++) {
      var styleRecord = _a7[_i];
      themableStyles.push(styleRecord.themableStyle);
    }
    if (themableStyles.length > 0) {
      clearStyles(
        1
        /* ClearStyleOptions.onlyThemable */
      );
      applyThemableStyles([].concat.apply([], themableStyles));
    }
  }
}
function resolveThemableArray(splitStyleArray) {
  var theme = _themeState.theme;
  var themable = false;
  var resolvedArray = (splitStyleArray || []).map(function(currentValue) {
    var themeSlot = currentValue.theme;
    if (themeSlot) {
      themable = true;
      var themedValue = theme ? theme[themeSlot] : void 0;
      var defaultValue = currentValue.defaultValue || "inherit";
      if (theme && !themedValue && console && !(themeSlot in theme) && typeof DEBUG !== "undefined" && DEBUG) {
        console.warn('Theming value not provided for "'.concat(themeSlot, '". Falling back to "').concat(defaultValue, '".'));
      }
      return themedValue || defaultValue;
    } else {
      return currentValue.rawString;
    }
  });
  return {
    styleString: resolvedArray.join(""),
    themable
  };
}
function registerStyles(styleArray) {
  if (typeof document === "undefined") {
    return;
  }
  var head = document.getElementsByTagName("head")[0];
  var styleElement = document.createElement("style");
  var _a7 = resolveThemableArray(styleArray), styleString = _a7.styleString, themable = _a7.themable;
  styleElement.setAttribute("data-load-themed-styles", "true");
  if (_styleNonce) {
    styleElement.setAttribute("nonce", _styleNonce);
  }
  styleElement.appendChild(document.createTextNode(styleString));
  _themeState.perf.count++;
  head.appendChild(styleElement);
  var ev = document.createEvent("HTMLEvents");
  ev.initEvent(
    "styleinsert",
    true,
    false
    /* cancelable */
  );
  ev.args = {
    newStyle: styleElement
  };
  document.dispatchEvent(ev);
  var record = {
    styleElement,
    themableStyle: styleArray
  };
  if (themable) {
    _themeState.registeredThemableStyles.push(record);
  } else {
    _themeState.registeredStyles.push(record);
  }
}

// node_modules/@fluentui/style-utilities/lib/styles/theme.js
var _theme = createTheme({});
var _onThemeChangeCallbacks = [];
var ThemeSettingName = "theme";
function initializeThemeInCustomizations() {
  var _a7;
  var _b3, _c3;
  var win = getWindow();
  if ((_b3 = win === null || win === void 0 ? void 0 : win.FabricConfig) === null || _b3 === void 0 ? void 0 : _b3.legacyTheme) {
    loadTheme2(win.FabricConfig.legacyTheme);
  } else if (!Customizations.getSettings([ThemeSettingName]).theme) {
    if ((_c3 = win === null || win === void 0 ? void 0 : win.FabricConfig) === null || _c3 === void 0 ? void 0 : _c3.theme) {
      _theme = createTheme(win.FabricConfig.theme);
    }
    Customizations.applySettings((_a7 = {}, _a7[ThemeSettingName] = _theme, _a7));
  }
}
initializeThemeInCustomizations();
function getTheme(depComments) {
  if (depComments === void 0) {
    depComments = false;
  }
  if (depComments === true) {
    _theme = createTheme({}, depComments);
  }
  return _theme;
}
function loadTheme2(theme, depComments) {
  var _a7;
  if (depComments === void 0) {
    depComments = false;
  }
  _theme = createTheme(theme, depComments);
  loadTheme(__assign(__assign(__assign(__assign({}, _theme.palette), _theme.semanticColors), _theme.effects), _loadFonts(_theme)));
  Customizations.applySettings((_a7 = {}, _a7[ThemeSettingName] = _theme, _a7));
  _onThemeChangeCallbacks.forEach(function(callback) {
    try {
      callback(_theme);
    } catch (e) {
    }
  });
  return _theme;
}
function _loadFonts(theme) {
  var lines = {};
  for (var _i = 0, _a7 = Object.keys(theme.fonts); _i < _a7.length; _i++) {
    var fontName = _a7[_i];
    var font = theme.fonts[fontName];
    for (var _b3 = 0, _c3 = Object.keys(font); _b3 < _c3.length; _b3++) {
      var propName = _c3[_b3];
      var name_1 = fontName + propName.charAt(0).toUpperCase() + propName.slice(1);
      var value = font[propName];
      if (propName === "fontSize" && typeof value === "number") {
        value = value + "px";
      }
      lines[name_1] = value;
    }
  }
  return lines;
}

// node_modules/@fluentui/style-utilities/lib/styles/GeneralStyles.js
var normalize = {
  boxShadow: "none",
  margin: 0,
  padding: 0,
  boxSizing: "border-box"
};

// node_modules/@fluentui/style-utilities/lib/classNames/AnimationClassNames.js
var AnimationClassNames = buildClassMap(AnimationStyles);

// node_modules/@fluentui/style-utilities/lib/classNames/FontClassNames.js
var FontClassNames = buildClassMap(DefaultFontStyles);

// node_modules/@fluentui/style-utilities/lib/classNames/ColorClassNames.js
var ColorClassNames = {};
for (colorName in DefaultPalette) {
  if (DefaultPalette.hasOwnProperty(colorName)) {
    _defineGetter(ColorClassNames, colorName, "", false, "color");
    _defineGetter(ColorClassNames, colorName, "Hover", true, "color");
    _defineGetter(ColorClassNames, colorName, "Background", false, "background");
    _defineGetter(ColorClassNames, colorName, "BackgroundHover", true, "background");
    _defineGetter(ColorClassNames, colorName, "Border", false, "borderColor");
    _defineGetter(ColorClassNames, colorName, "BorderHover", true, "borderColor");
  }
}
var colorName;
function _defineGetter(obj, colorName, suffix, isHover, cssProperty) {
  Object.defineProperty(obj, colorName + suffix, {
    get: function() {
      var _a7;
      var style = (_a7 = {}, _a7[cssProperty] = getTheme().palette[colorName], _a7);
      return mergeStyles(isHover ? { selectors: { ":hover": style } } : style).toString();
    },
    enumerable: true,
    configurable: true
  });
}

// node_modules/@fluentui/style-utilities/lib/version.js
setVersion("@fluentui/style-utilities", "8.10.3");

// node_modules/@fluentui/style-utilities/lib/index.js
initializeThemeInCustomizations();

// node_modules/@fluentui/react/lib/utilities/dom.js
var useWindowEx = function() {
  var _a7;
  return ((_a7 = useWindow()) !== null && _a7 !== void 0 ? _a7 : typeof window !== "undefined") ? window : void 0;
};
var getDocumentEx = function(ctx) {
  var _a7, _b3;
  return ((_b3 = (_a7 = ctx === null || ctx === void 0 ? void 0 : ctx.window) === null || _a7 === void 0 ? void 0 : _a7.document) !== null && _b3 !== void 0 ? _b3 : typeof document !== "undefined") ? document : void 0;
};
var getWindowEx = function(ctx) {
  var _a7;
  return ((_a7 = ctx === null || ctx === void 0 ? void 0 : ctx.window) !== null && _a7 !== void 0 ? _a7 : typeof window !== "undefined") ? window : void 0;
};

// node_modules/@fluentui/react/lib/components/Callout/CalloutContent.base.js
var _a4;
var COMPONENT_NAME = "CalloutContentBase";
var ANIMATIONS = (_a4 = {}, _a4[RectangleEdge.top] = AnimationClassNames.slideUpIn10, _a4[RectangleEdge.bottom] = AnimationClassNames.slideDownIn10, _a4[RectangleEdge.left] = AnimationClassNames.slideLeftIn10, _a4[RectangleEdge.right] = AnimationClassNames.slideRightIn10, _a4);
var BEAK_ORIGIN_POSITION = { top: 0, left: 0 };
var OFF_SCREEN_STYLE = {
  opacity: 0,
  filter: "opacity(0)",
  pointerEvents: "none"
};
var ARIA_ROLE_ATTRIBUTES = ["role", "aria-roledescription"];
var DEFAULT_PROPS = {
  preventDismissOnLostFocus: false,
  preventDismissOnScroll: false,
  preventDismissOnResize: false,
  isBeakVisible: true,
  beakWidth: 16,
  gapSpace: 0,
  minPagePadding: 8,
  directionalHint: DirectionalHint.bottomAutoEdge
};
var getClassNames = classNamesFunction({
  disableCaching: true
  // disabling caching because stylesProp.position mutates often
});
function useBounds(_a7, targetRef, targetWindow) {
  var bounds = _a7.bounds, _b3 = _a7.minPagePadding, minPagePadding = _b3 === void 0 ? DEFAULT_PROPS.minPagePadding : _b3, target = _a7.target;
  var _c3 = React33.useState(false), targetWindowResized = _c3[0], setTargetWindowResized = _c3[1];
  var cachedBounds = React33.useRef();
  var getBounds = React33.useCallback(function() {
    if (!cachedBounds.current || targetWindowResized) {
      var currentBounds = typeof bounds === "function" ? targetWindow ? bounds(target, targetWindow) : void 0 : bounds;
      if (!currentBounds && targetWindow) {
        currentBounds = getBoundsFromTargetWindow(targetRef.current, targetWindow);
        currentBounds = {
          top: currentBounds.top + minPagePadding,
          left: currentBounds.left + minPagePadding,
          right: currentBounds.right - minPagePadding,
          bottom: currentBounds.bottom - minPagePadding,
          width: currentBounds.width - minPagePadding * 2,
          height: currentBounds.height - minPagePadding * 2
        };
      }
      cachedBounds.current = currentBounds;
      targetWindowResized && setTargetWindowResized(false);
    }
    return cachedBounds.current;
  }, [bounds, minPagePadding, target, targetRef, targetWindow, targetWindowResized]);
  var async = useAsync();
  useOnEvent(targetWindow, "resize", async.debounce(function() {
    setTargetWindowResized(true);
  }, 500, { leading: true }));
  return getBounds;
}
function useMaxHeight(_a7, getBounds, targetRef, positions) {
  var _b3;
  var calloutMaxHeight = _a7.calloutMaxHeight, finalHeight = _a7.finalHeight, directionalHint = _a7.directionalHint, directionalHintFixed = _a7.directionalHintFixed, hidden = _a7.hidden, gapSpace = _a7.gapSpace, beakWidth = _a7.beakWidth, isBeakVisible = _a7.isBeakVisible, coverTarget = _a7.coverTarget;
  var _c3 = React33.useState(), maxHeight = _c3[0], setMaxHeight = _c3[1];
  var _d3 = (_b3 = positions === null || positions === void 0 ? void 0 : positions.elementPosition) !== null && _b3 !== void 0 ? _b3 : {}, top = _d3.top, bottom = _d3.bottom;
  var targetRect = (targetRef === null || targetRef === void 0 ? void 0 : targetRef.current) ? getRectangleFromTarget(targetRef.current) : void 0;
  React33.useEffect(function() {
    var _a8;
    var bounds = (_a8 = getBounds()) !== null && _a8 !== void 0 ? _a8 : {};
    var topBounds = bounds.top;
    var bottomBounds = bounds.bottom;
    var calculatedHeight;
    if ((positions === null || positions === void 0 ? void 0 : positions.targetEdge) === RectangleEdge.top && (targetRect === null || targetRect === void 0 ? void 0 : targetRect.top) && !coverTarget) {
      bottomBounds = targetRect.top - calculateGapSpace(isBeakVisible, beakWidth, gapSpace);
    }
    if (typeof top === "number" && bottomBounds) {
      calculatedHeight = bottomBounds - top;
    } else if (typeof bottom === "number" && typeof topBounds === "number" && bottomBounds) {
      calculatedHeight = bottomBounds - topBounds - bottom;
    }
    if (!calloutMaxHeight && !hidden || calloutMaxHeight && calculatedHeight && calloutMaxHeight > calculatedHeight) {
      setMaxHeight(calculatedHeight);
    } else if (calloutMaxHeight) {
      setMaxHeight(calloutMaxHeight);
    } else {
      setMaxHeight(void 0);
    }
  }, [
    bottom,
    calloutMaxHeight,
    finalHeight,
    directionalHint,
    directionalHintFixed,
    getBounds,
    hidden,
    positions,
    top,
    gapSpace,
    beakWidth,
    isBeakVisible,
    targetRect,
    coverTarget
  ]);
  return maxHeight;
}
function usePositions(props, hostElement, calloutElement, targetRef, getBounds, popupRef) {
  var _a7 = React33.useState(), positions = _a7[0], setPositions = _a7[1];
  var positionAttempts = React33.useRef(0);
  var previousTarget = React33.useRef();
  var async = useAsync();
  var hidden = props.hidden, target = props.target, finalHeight = props.finalHeight, calloutMaxHeight = props.calloutMaxHeight, onPositioned = props.onPositioned, directionalHint = props.directionalHint, hideOverflow = props.hideOverflow, preferScrollResizePositioning = props.preferScrollResizePositioning;
  var win = useWindowEx();
  var localRef = React33.useRef();
  var popupStyles;
  if (localRef.current !== popupRef.current) {
    localRef.current = popupRef.current;
    popupStyles = popupRef.current ? win === null || win === void 0 ? void 0 : win.getComputedStyle(popupRef.current) : void 0;
  }
  var popupOverflowY = popupStyles === null || popupStyles === void 0 ? void 0 : popupStyles.overflowY;
  React33.useEffect(function() {
    if (!hidden) {
      var timerId_1 = async.requestAnimationFrame(function() {
        var _a8, _b3;
        if (hostElement.current && calloutElement) {
          var currentProps = __assign(__assign({}, props), { target: targetRef.current, bounds: getBounds() });
          var dupeCalloutElement = calloutElement.cloneNode(true);
          dupeCalloutElement.style.maxHeight = calloutMaxHeight ? "".concat(calloutMaxHeight) : "";
          dupeCalloutElement.style.visibility = "hidden";
          (_a8 = calloutElement.parentElement) === null || _a8 === void 0 ? void 0 : _a8.appendChild(dupeCalloutElement);
          var previousPositions = previousTarget.current === target ? positions : void 0;
          var isOverflowYHidden = hideOverflow || popupOverflowY === "clip" || popupOverflowY === "hidden";
          var shouldScroll = preferScrollResizePositioning && !isOverflowYHidden;
          var newPositions = finalHeight ? positionCard(currentProps, hostElement.current, dupeCalloutElement, previousPositions, win) : positionCallout(currentProps, hostElement.current, dupeCalloutElement, previousPositions, shouldScroll, void 0, win);
          (_b3 = calloutElement.parentElement) === null || _b3 === void 0 ? void 0 : _b3.removeChild(dupeCalloutElement);
          if (!positions && newPositions || positions && newPositions && !arePositionsEqual(positions, newPositions) && positionAttempts.current < 5) {
            positionAttempts.current++;
            setPositions(newPositions);
          } else if (positionAttempts.current > 0) {
            positionAttempts.current = 0;
            onPositioned === null || onPositioned === void 0 ? void 0 : onPositioned(positions);
          }
        }
      }, calloutElement);
      previousTarget.current = target;
      return function() {
        async.cancelAnimationFrame(timerId_1);
        previousTarget.current = void 0;
      };
    } else {
      setPositions(void 0);
      positionAttempts.current = 0;
    }
  }, [
    hidden,
    directionalHint,
    async,
    calloutElement,
    calloutMaxHeight,
    hostElement,
    targetRef,
    finalHeight,
    getBounds,
    onPositioned,
    positions,
    props,
    target,
    hideOverflow,
    preferScrollResizePositioning,
    popupOverflowY,
    win
  ]);
  return positions;
}
function useAutoFocus(_a7, positions, calloutElement) {
  var hidden = _a7.hidden, setInitialFocus = _a7.setInitialFocus;
  var async = useAsync();
  var hasPositions = !!positions;
  React33.useEffect(function() {
    if (!hidden && setInitialFocus && hasPositions && calloutElement) {
      var timerId_2 = async.requestAnimationFrame(function() {
        return focusFirstChild(calloutElement);
      }, calloutElement);
      return function() {
        return async.cancelAnimationFrame(timerId_2);
      };
    }
  }, [hidden, hasPositions, async, calloutElement, setInitialFocus]);
}
function useDismissHandlers(_a7, positions, hostElement, targetRef, targetWindow) {
  var hidden = _a7.hidden, onDismiss = _a7.onDismiss, preventDismissOnScroll = _a7.preventDismissOnScroll, preventDismissOnResize = _a7.preventDismissOnResize, preventDismissOnLostFocus = _a7.preventDismissOnLostFocus, dismissOnTargetClick = _a7.dismissOnTargetClick, shouldDismissOnWindowFocus = _a7.shouldDismissOnWindowFocus, preventDismissOnEvent = _a7.preventDismissOnEvent;
  var isMouseDownOnPopup = React33.useRef(false);
  var async = useAsync();
  var mouseDownHandlers = useConst([
    function() {
      isMouseDownOnPopup.current = true;
    },
    function() {
      isMouseDownOnPopup.current = false;
    }
  ]);
  var positionsExists = !!positions;
  React33.useEffect(function() {
    var dismissOnScroll = function(ev) {
      if (positionsExists && !preventDismissOnScroll) {
        dismissOnClickOrScroll(ev);
      }
    };
    var dismissOnResize = function(ev) {
      if (!preventDismissOnResize && !(preventDismissOnEvent && preventDismissOnEvent(ev))) {
        onDismiss === null || onDismiss === void 0 ? void 0 : onDismiss(ev);
      }
    };
    var dismissOnLostFocus = function(ev) {
      if (!preventDismissOnLostFocus) {
        dismissOnClickOrScroll(ev);
      }
    };
    var dismissOnClickOrScroll = function(ev) {
      var eventPaths = ev.composedPath ? ev.composedPath() : [];
      var target = eventPaths.length > 0 ? eventPaths[0] : ev.target;
      var isEventTargetOutsideCallout = hostElement.current && !elementContains(hostElement.current, target);
      if (isEventTargetOutsideCallout && isMouseDownOnPopup.current) {
        isMouseDownOnPopup.current = false;
        return;
      }
      if (!targetRef.current && isEventTargetOutsideCallout || ev.target !== targetWindow && isEventTargetOutsideCallout && (!targetRef.current || "stopPropagation" in targetRef.current || dismissOnTargetClick || target !== targetRef.current && !elementContains(targetRef.current, target))) {
        if (preventDismissOnEvent && preventDismissOnEvent(ev)) {
          return;
        }
        onDismiss === null || onDismiss === void 0 ? void 0 : onDismiss(ev);
      }
    };
    var dismissOnTargetWindowBlur = function(ev) {
      if (!shouldDismissOnWindowFocus) {
        return;
      }
      if ((preventDismissOnEvent && !preventDismissOnEvent(ev) || !preventDismissOnEvent && !preventDismissOnLostFocus) && !(targetWindow === null || targetWindow === void 0 ? void 0 : targetWindow.document.hasFocus()) && ev.relatedTarget === null) {
        onDismiss === null || onDismiss === void 0 ? void 0 : onDismiss(ev);
      }
    };
    var disposablesPromise = new Promise(function(resolve) {
      async.setTimeout(function() {
        if (!hidden && targetWindow) {
          var disposables_1 = [
            on(targetWindow, "scroll", dismissOnScroll, true),
            on(targetWindow, "resize", dismissOnResize, true),
            on(targetWindow.document.documentElement, "focus", dismissOnLostFocus, true),
            on(targetWindow.document.documentElement, "click", dismissOnLostFocus, true),
            on(targetWindow, "blur", dismissOnTargetWindowBlur, true)
          ];
          resolve(function() {
            disposables_1.forEach(function(dispose) {
              return dispose();
            });
          });
        }
      }, 0);
    });
    return function() {
      disposablesPromise.then(function(dispose) {
        return dispose();
      });
    };
  }, [
    hidden,
    async,
    hostElement,
    targetRef,
    targetWindow,
    onDismiss,
    shouldDismissOnWindowFocus,
    dismissOnTargetClick,
    preventDismissOnLostFocus,
    preventDismissOnResize,
    preventDismissOnScroll,
    positionsExists,
    preventDismissOnEvent
  ]);
  return mouseDownHandlers;
}
var CalloutContentBase = React33.memo(React33.forwardRef(function(propsWithoutDefaults, forwardedRef) {
  var props = getPropsWithDefaults(DEFAULT_PROPS, propsWithoutDefaults);
  var styles = props.styles, style = props.style, ariaLabel = props.ariaLabel, ariaDescribedBy = props.ariaDescribedBy, ariaLabelledBy = props.ariaLabelledBy, className = props.className, isBeakVisible = props.isBeakVisible, children = props.children, beakWidth = props.beakWidth, calloutWidth = props.calloutWidth, calloutMaxWidth = props.calloutMaxWidth, calloutMinWidth = props.calloutMinWidth, doNotLayer = props.doNotLayer, finalHeight = props.finalHeight, _a7 = props.hideOverflow, hideOverflow = _a7 === void 0 ? !!finalHeight : _a7, backgroundColor = props.backgroundColor, calloutMaxHeight = props.calloutMaxHeight, onScroll = props.onScroll, _b3 = props.shouldRestoreFocus, shouldRestoreFocus = _b3 === void 0 ? true : _b3, target = props.target, hidden = props.hidden, onLayerMounted = props.onLayerMounted, popupProps = props.popupProps;
  var hostElement = React33.useRef(null);
  var popupRef = React33.useRef(null);
  var mergedPopupRefs = useMergedRefs(popupRef, popupProps === null || popupProps === void 0 ? void 0 : popupProps.ref);
  var _c3 = React33.useState(null), calloutElement = _c3[0], setCalloutElement = _c3[1];
  var calloutCallback = React33.useCallback(function(calloutEl) {
    setCalloutElement(calloutEl);
  }, []);
  var rootRef = useMergedRefs(hostElement, forwardedRef);
  var _d3 = useTarget(props.target, {
    current: calloutElement
  }), targetRef = _d3[0], targetWindow = _d3[1];
  var getBounds = useBounds(props, targetRef, targetWindow);
  var positions = usePositions(props, hostElement, calloutElement, targetRef, getBounds, mergedPopupRefs);
  var maxHeight = useMaxHeight(props, getBounds, targetRef, positions);
  var _e2 = useDismissHandlers(props, positions, hostElement, targetRef, targetWindow), mouseDownOnPopup = _e2[0], mouseUpOnPopup = _e2[1];
  var isForcedInBounds = (positions === null || positions === void 0 ? void 0 : positions.elementPosition.top) && (positions === null || positions === void 0 ? void 0 : positions.elementPosition.bottom);
  var cssPositions = __assign(__assign({}, positions === null || positions === void 0 ? void 0 : positions.elementPosition), { maxHeight });
  if (isForcedInBounds) {
    cssPositions.bottom = void 0;
  }
  useAutoFocus(props, positions, calloutElement);
  React33.useEffect(function() {
    if (!hidden) {
      onLayerMounted === null || onLayerMounted === void 0 ? void 0 : onLayerMounted();
    }
  }, [hidden]);
  if (!targetWindow) {
    return null;
  }
  var overflowYHidden = hideOverflow;
  var beakVisible = isBeakVisible && !!target;
  var classNames2 = getClassNames(styles, {
    theme: props.theme,
    className,
    overflowYHidden,
    calloutWidth,
    positions,
    beakWidth,
    backgroundColor,
    calloutMaxWidth,
    calloutMinWidth,
    doNotLayer
  });
  var overflowStyle = __assign(__assign({ maxHeight: calloutMaxHeight ? calloutMaxHeight : "100%" }, style), overflowYHidden && { overflowY: "hidden" });
  var visibilityStyle = props.hidden ? { visibility: "hidden" } : void 0;
  return React33.createElement(
    "div",
    { ref: rootRef, className: classNames2.container, style: visibilityStyle },
    React33.createElement(
      "div",
      __assign({}, getNativeProps(props, divProperties, ARIA_ROLE_ATTRIBUTES), {
        className: css(classNames2.root, positions && positions.targetEdge && ANIMATIONS[positions.targetEdge]),
        style: positions ? __assign({}, cssPositions) : OFF_SCREEN_STYLE,
        // Safari and Firefox on Mac OS requires this to back-stop click events so focus remains in the Callout.
        // See https://developer.mozilla.org/en-US/docs/Web/HTML/Element/button#Clicking_and_focus
        tabIndex: -1,
        ref: calloutCallback
      }),
      beakVisible && React33.createElement("div", { className: classNames2.beak, style: getBeakPosition(positions) }),
      beakVisible && React33.createElement("div", { className: classNames2.beakCurtain }),
      React33.createElement(
        Popup,
        __assign({
          // don't use getNativeElementProps for role and roledescription because it will also
          // pass through data-* props (resulting in them being used in two places)
          role: props.role,
          "aria-roledescription": props["aria-roledescription"],
          ariaDescribedBy,
          ariaLabel,
          ariaLabelledBy,
          className: classNames2.calloutMain,
          onDismiss: props.onDismiss,
          onMouseDown: mouseDownOnPopup,
          onMouseUp: mouseUpOnPopup,
          onRestoreFocus: props.onRestoreFocus,
          onScroll,
          shouldRestoreFocus,
          style: overflowStyle
        }, popupProps, { ref: mergedPopupRefs }),
        children
      )
    )
  );
}), function(previousProps, nextProps) {
  if (!nextProps.shouldUpdateWhenHidden && previousProps.hidden && nextProps.hidden) {
    return true;
  }
  return shallowCompare(previousProps, nextProps);
});
function getBeakPosition(positions) {
  var _a7, _b3;
  var beakPositionStyle = __assign(__assign({}, (_a7 = positions === null || positions === void 0 ? void 0 : positions.beakPosition) === null || _a7 === void 0 ? void 0 : _a7.elementPosition), { display: ((_b3 = positions === null || positions === void 0 ? void 0 : positions.beakPosition) === null || _b3 === void 0 ? void 0 : _b3.hideBeak) ? "none" : void 0 });
  if (!beakPositionStyle.top && !beakPositionStyle.bottom && !beakPositionStyle.left && !beakPositionStyle.right) {
    beakPositionStyle.left = BEAK_ORIGIN_POSITION.left;
    beakPositionStyle.top = BEAK_ORIGIN_POSITION.top;
  }
  return beakPositionStyle;
}
function arePositionsEqual(prevElementPositions, newElementPosition) {
  return comparePositions(prevElementPositions.elementPosition, newElementPosition.elementPosition) && comparePositions(prevElementPositions.beakPosition.elementPosition, newElementPosition.beakPosition.elementPosition);
}
function comparePositions(prevElementPositions, newElementPositions) {
  for (var key in newElementPositions) {
    if (newElementPositions.hasOwnProperty(key)) {
      var oldPositionEdge = prevElementPositions[key];
      var newPositionEdge = newElementPositions[key];
      if (oldPositionEdge !== void 0 && newPositionEdge !== void 0) {
        if (oldPositionEdge.toFixed(2) !== newPositionEdge.toFixed(2)) {
          return false;
        }
      } else {
        return false;
      }
    }
  }
  return true;
}
CalloutContentBase.displayName = COMPONENT_NAME;

// node_modules/@fluentui/react/lib/components/Callout/CalloutContent.styles.js
function getBeakStyle(beakWidth) {
  return {
    height: beakWidth,
    width: beakWidth
  };
}
var GlobalClassNames = {
  container: "ms-Callout-container",
  root: "ms-Callout",
  beak: "ms-Callout-beak",
  beakCurtain: "ms-Callout-beakCurtain",
  calloutMain: "ms-Callout-main"
};
var getStyles = function(props) {
  var _a7;
  var theme = props.theme, className = props.className, overflowYHidden = props.overflowYHidden, calloutWidth = props.calloutWidth, beakWidth = props.beakWidth, backgroundColor = props.backgroundColor, calloutMaxWidth = props.calloutMaxWidth, calloutMinWidth = props.calloutMinWidth, doNotLayer = props.doNotLayer;
  var classNames2 = getGlobalClassNames(GlobalClassNames, theme);
  var semanticColors = theme.semanticColors, effects = theme.effects;
  return {
    container: [
      classNames2.container,
      {
        position: "relative"
      }
    ],
    root: [
      classNames2.root,
      theme.fonts.medium,
      {
        position: "absolute",
        display: "flex",
        zIndex: doNotLayer ? ZIndexes.Layer : void 0,
        boxSizing: "border-box",
        borderRadius: effects.roundedCorner2,
        boxShadow: effects.elevation16,
        selectors: (_a7 = {}, _a7[HighContrastSelector] = {
          borderWidth: 1,
          borderStyle: "solid",
          borderColor: "WindowText"
        }, _a7)
      },
      focusClear(),
      className,
      !!calloutWidth && { width: calloutWidth },
      !!calloutMaxWidth && { maxWidth: calloutMaxWidth },
      !!calloutMinWidth && { minWidth: calloutMinWidth }
    ],
    beak: [
      classNames2.beak,
      {
        position: "absolute",
        backgroundColor: semanticColors.menuBackground,
        boxShadow: "inherit",
        border: "inherit",
        boxSizing: "border-box",
        transform: "rotate(45deg)"
      },
      getBeakStyle(beakWidth),
      backgroundColor && {
        backgroundColor
      }
    ],
    beakCurtain: [
      classNames2.beakCurtain,
      {
        position: "absolute",
        top: 0,
        right: 0,
        bottom: 0,
        left: 0,
        backgroundColor: semanticColors.menuBackground,
        borderRadius: effects.roundedCorner2
      }
    ],
    calloutMain: [
      classNames2.calloutMain,
      {
        backgroundColor: semanticColors.menuBackground,
        overflowX: "hidden",
        overflowY: "auto",
        position: "relative",
        width: "100%",
        borderRadius: effects.roundedCorner2
      },
      overflowYHidden && {
        overflowY: "hidden"
      },
      backgroundColor && {
        backgroundColor
      }
    ]
  };
};

// node_modules/@fluentui/react/lib/components/Callout/CalloutContent.js
var CalloutContent = styled(CalloutContentBase, getStyles, void 0, {
  scope: "CalloutContent"
});

// node_modules/@fluentui/react-portal-compat-context/lib/PortalCompatContext.js
var React34 = __toESM(require_react());
var PortalCompatContext = React34.createContext(void 0);
var portalCompatContextDefaultValue = function() {
  return function() {
    return void 0;
  };
};
var PortalCompatContextProvider = PortalCompatContext.Provider;
function usePortalCompat() {
  var _React_useContext;
  return (_React_useContext = React34.useContext(PortalCompatContext)) !== null && _React_useContext !== void 0 ? _React_useContext : portalCompatContextDefaultValue;
}

// node_modules/@fluentui/react/lib/components/Layer/Layer.base.js
var React36 = __toESM(require_react());
var ReactDOM = __toESM(require_react_dom());

// node_modules/@fluentui/react/lib/components/Fabric/Fabric.base.js
var React35 = __toESM(require_react());
var getClassNames2 = classNamesFunction();
var getFabricTheme = memoizeFunction(function(theme, isRTL) {
  return createTheme(__assign(__assign({}, theme), { rtl: isRTL }));
});
var getDir = function(_a7) {
  var theme = _a7.theme, dir = _a7.dir;
  var contextDir = getRTL2(theme) ? "rtl" : "ltr";
  var pageDir = getRTL2() ? "rtl" : "ltr";
  var componentDir = dir ? dir : contextDir;
  return {
    // If Fabric dir !== contextDir
    // Or If contextDir !== pageDir
    // Then we need to set dir of the Fabric root
    rootDir: componentDir !== contextDir || componentDir !== pageDir ? componentDir : dir,
    // If dir !== contextDir || pageDir
    // then set contextual theme around content
    needsTheme: componentDir !== contextDir
  };
};
var FabricBase = React35.forwardRef(function(props, ref) {
  var className = props.className, theme = props.theme, applyTheme = props.applyTheme, applyThemeToBody = props.applyThemeToBody, styles = props.styles;
  var classNames2 = getClassNames2(styles, {
    theme,
    applyTheme,
    className
  });
  var rootElement = React35.useRef(null);
  useApplyThemeToBody(applyThemeToBody, classNames2, rootElement);
  return React35.createElement(React35.Fragment, null, useRenderedContent(props, classNames2, rootElement, ref));
});
FabricBase.displayName = "FabricBase";
function useRenderedContent(props, _a7, rootElement, ref) {
  var root = _a7.root;
  var _b3 = props.as, Root = _b3 === void 0 ? "div" : _b3, dir = props.dir, theme = props.theme;
  var divProps = getNativeProps(props, divProperties, ["dir"]);
  var _c3 = getDir(props), rootDir = _c3.rootDir, needsTheme = _c3.needsTheme;
  var renderedContent = React35.createElement(
    FocusRectsProvider,
    { providerRef: rootElement },
    React35.createElement(Root, __assign({ dir: rootDir }, divProps, { className: root, ref: useMergedRefs(rootElement, ref) }))
  );
  if (needsTheme) {
    renderedContent = // eslint-disable-next-line deprecation/deprecation
    React35.createElement(Customizer, { settings: { theme: getFabricTheme(theme, dir === "rtl") } }, renderedContent);
  }
  return renderedContent;
}
function useApplyThemeToBody(applyThemeToBody, _a7, rootElement) {
  var bodyThemed = _a7.bodyThemed;
  React35.useEffect(function() {
    if (applyThemeToBody) {
      var currentDoc_1 = getDocument(rootElement.current);
      if (currentDoc_1) {
        currentDoc_1.body.classList.add(bodyThemed);
        return function() {
          currentDoc_1.body.classList.remove(bodyThemed);
        };
      }
    }
  }, [bodyThemed, applyThemeToBody, rootElement]);
  return rootElement;
}

// node_modules/@fluentui/react/lib/components/Fabric/Fabric.styles.js
var inheritFont = { fontFamily: "inherit" };
var GlobalClassNames2 = {
  root: "ms-Fabric",
  bodyThemed: "ms-Fabric-bodyThemed"
};
var getStyles2 = function(props) {
  var applyTheme = props.applyTheme, className = props.className, preventBlanketFontInheritance = props.preventBlanketFontInheritance, theme = props.theme;
  var classNames2 = getGlobalClassNames(GlobalClassNames2, theme);
  return {
    root: [
      classNames2.root,
      theme.fonts.medium,
      {
        color: theme.palette.neutralPrimary
      },
      !preventBlanketFontInheritance && {
        "& button": inheritFont,
        "& input": inheritFont,
        "& textarea": inheritFont
      },
      // apply theme to only if applyTheme is true
      applyTheme && {
        color: theme.semanticColors.bodyText,
        backgroundColor: theme.semanticColors.bodyBackground
      },
      className
    ],
    bodyThemed: [
      {
        backgroundColor: theme.semanticColors.bodyBackground
      }
    ]
  };
};

// node_modules/@fluentui/react/lib/components/Fabric/Fabric.js
var Fabric = styled(FabricBase, getStyles2, void 0, {
  scope: "Fabric"
});

// node_modules/@fluentui/react/lib/components/Layer/Layer.notification.js
var _layersByHostId = {};
var _layerHostsById = {};
var defaultHostId = "fluent-default-layer-host";
var _defaultHostSelector = "#".concat(defaultHostId);
function registerLayer(hostId, callback) {
  if (!_layersByHostId[hostId]) {
    _layersByHostId[hostId] = [];
  }
  _layersByHostId[hostId].push(callback);
  var layerHosts = _layerHostsById[hostId];
  if (layerHosts) {
    for (var _i = 0, layerHosts_1 = layerHosts; _i < layerHosts_1.length; _i++) {
      var layerHost = layerHosts_1[_i];
      layerHost.notifyLayersChanged();
    }
  }
}
function unregisterLayer(hostId, callback) {
  var layers = _layersByHostId[hostId];
  if (layers) {
    var idx = layers.indexOf(callback);
    if (idx >= 0) {
      layers.splice(idx, 1);
      if (layers.length === 0) {
        delete _layersByHostId[hostId];
      }
    }
  }
  var layerHosts = _layerHostsById[hostId];
  if (layerHosts) {
    for (var _i = 0, layerHosts_2 = layerHosts; _i < layerHosts_2.length; _i++) {
      var layerHost = layerHosts_2[_i];
      layerHost.notifyLayersChanged();
    }
  }
}
function getLayerHost(hostId) {
  var layerHosts = _layerHostsById[hostId];
  return layerHosts && layerHosts[0] || void 0;
}
function createDefaultLayerHost(doc) {
  var host = doc.createElement("div");
  host.setAttribute("id", defaultHostId);
  host.style.cssText = "position:fixed;z-index:1000000";
  doc === null || doc === void 0 ? void 0 : doc.body.appendChild(host);
  return host;
}
function getDefaultTarget() {
  return _defaultHostSelector;
}

// node_modules/@fluentui/react/lib/components/Layer/Layer.base.js
var getClassNames3 = classNamesFunction();
var getFocusVisibility = function(providerRef) {
  if (providerRef === null || providerRef === void 0 ? void 0 : providerRef.current) {
    return providerRef.current.classList.contains(IsFocusVisibleClassName);
  }
  return false;
};
var LayerBase = React36.forwardRef(function(props, ref) {
  var registerPortalEl = usePortalCompat();
  var rootRef = React36.useRef(null);
  var mergedRef = useMergedRefs(rootRef, ref);
  var layerRef = React36.useRef();
  var fabricElementRef = React36.useRef(null);
  var focusContext = React36.useContext(FocusRectsContext);
  var _a7 = React36.useState(false), needRaiseLayerMount = _a7[0], setNeedRaiseLayerMount = _a7[1];
  var focusRectsRef = React36.useCallback(function(el) {
    var isFocusVisible = getFocusVisibility(focusContext === null || focusContext === void 0 ? void 0 : focusContext.providerRef);
    if (el && isFocusVisible) {
      el.classList.add(IsFocusVisibleClassName);
    }
  }, [focusContext]);
  var children = props.children, className = props.className, eventBubblingEnabled = props.eventBubblingEnabled, fabricProps = props.fabricProps, hostId = props.hostId, insertFirst = props.insertFirst, _b3 = props.onLayerDidMount, onLayerDidMount = _b3 === void 0 ? function() {
    return void 0;
  } : _b3, _c3 = props.onLayerMounted, onLayerMounted = _c3 === void 0 ? function() {
    return void 0;
  } : _c3, onLayerWillUnmount = props.onLayerWillUnmount, styles = props.styles, theme = props.theme;
  var fabricRef = useMergedRefs(fabricElementRef, fabricProps === null || fabricProps === void 0 ? void 0 : fabricProps.ref, focusRectsRef);
  var classNames2 = getClassNames3(styles, {
    theme,
    className,
    isNotHost: !hostId
  });
  var getHost = function(doc) {
    var _a8, _b4;
    if (hostId) {
      var layerHost = getLayerHost(hostId);
      if (layerHost) {
        return (_a8 = layerHost.rootRef.current) !== null && _a8 !== void 0 ? _a8 : null;
      }
      return (_b4 = doc.getElementById(hostId)) !== null && _b4 !== void 0 ? _b4 : null;
    } else {
      var defaultHostSelector = getDefaultTarget();
      var host = defaultHostSelector ? doc.querySelector(defaultHostSelector) : null;
      if (!host) {
        host = createDefaultLayerHost(doc);
      }
      return host;
    }
  };
  var removeLayerElement = function() {
    onLayerWillUnmount === null || onLayerWillUnmount === void 0 ? void 0 : onLayerWillUnmount();
    var elem = layerRef.current;
    layerRef.current = void 0;
    if (elem && elem.parentNode) {
      elem.parentNode.removeChild(elem);
    }
  };
  var createLayerElement = function() {
    var _a8;
    var doc = getDocument(rootRef.current);
    if (!doc) {
      return;
    }
    var host = getHost(doc);
    if (!host) {
      return;
    }
    removeLayerElement();
    var el = ((_a8 = host.ownerDocument) !== null && _a8 !== void 0 ? _a8 : doc).createElement("div");
    el.className = classNames2.root;
    setPortalAttribute(el);
    setVirtualParent(el, rootRef.current);
    insertFirst ? host.insertBefore(el, host.firstChild) : host.appendChild(el);
    layerRef.current = el;
    setNeedRaiseLayerMount(true);
  };
  useIsomorphicLayoutEffect(function() {
    createLayerElement();
    if (hostId) {
      registerLayer(hostId, createLayerElement);
    }
    var unregisterPortalEl = layerRef.current ? registerPortalEl(layerRef.current) : void 0;
    return function() {
      if (unregisterPortalEl) {
        unregisterPortalEl();
      }
      removeLayerElement();
      if (hostId) {
        unregisterLayer(hostId, createLayerElement);
      }
    };
  }, [hostId]);
  React36.useEffect(function() {
    if (layerRef.current && needRaiseLayerMount) {
      onLayerMounted === null || onLayerMounted === void 0 ? void 0 : onLayerMounted();
      onLayerDidMount === null || onLayerDidMount === void 0 ? void 0 : onLayerDidMount();
      setNeedRaiseLayerMount(false);
    }
  }, [needRaiseLayerMount, onLayerMounted, onLayerDidMount]);
  useDebugWarnings(props);
  return React36.createElement("span", { className: "ms-layer", ref: mergedRef }, layerRef.current && ReactDOM.createPortal(React36.createElement(
    FocusRectsProvider,
    { layerRoot: true, providerRef: fabricRef },
    React36.createElement(Fabric, __assign({}, !eventBubblingEnabled && getFilteredEvents(), fabricProps, { className: css(classNames2.content, fabricProps === null || fabricProps === void 0 ? void 0 : fabricProps.className), ref: fabricRef }), children)
  ), layerRef.current));
});
LayerBase.displayName = "LayerBase";
var filteredEventProps;
var onFilterEvent = function(ev) {
  if (ev.eventPhase === Event.BUBBLING_PHASE && ev.type !== "mouseenter" && ev.type !== "mouseleave" && ev.type !== "touchstart" && ev.type !== "touchend") {
    ev.stopPropagation();
  }
};
function getFilteredEvents() {
  if (!filteredEventProps) {
    filteredEventProps = {};
    [
      "onClick",
      "onContextMenu",
      "onDoubleClick",
      "onDrag",
      "onDragEnd",
      "onDragEnter",
      "onDragExit",
      "onDragLeave",
      "onDragOver",
      "onDragStart",
      "onDrop",
      "onMouseDown",
      "onMouseEnter",
      "onMouseLeave",
      "onMouseMove",
      "onMouseOver",
      "onMouseOut",
      "onMouseUp",
      "onTouchMove",
      "onTouchStart",
      "onTouchCancel",
      "onTouchEnd",
      "onKeyDown",
      "onKeyPress",
      "onKeyUp",
      "onFocus",
      "onBlur",
      "onChange",
      "onInput",
      "onInvalid",
      "onSubmit"
    ].forEach(function(name) {
      return filteredEventProps[name] = onFilterEvent;
    });
  }
  return filteredEventProps;
}
function useDebugWarnings(props) {
  if (true) {
    useWarnings({
      name: "Layer",
      props,
      deprecations: { onLayerMounted: "onLayerDidMount" }
    });
  }
}

// node_modules/@fluentui/react/lib/components/Layer/Layer.styles.js
var GlobalClassNames3 = {
  root: "ms-Layer",
  rootNoHost: "ms-Layer--fixed",
  content: "ms-Layer-content"
};
var getStyles3 = function(props) {
  var className = props.className, isNotHost = props.isNotHost, theme = props.theme;
  var classNames2 = getGlobalClassNames(GlobalClassNames3, theme);
  return {
    root: [
      classNames2.root,
      theme.fonts.medium,
      isNotHost && [
        classNames2.rootNoHost,
        {
          position: "fixed",
          zIndex: ZIndexes.Layer,
          top: 0,
          left: 0,
          bottom: 0,
          right: 0,
          visibility: "hidden"
        }
      ],
      className
    ],
    content: [
      classNames2.content,
      {
        visibility: "visible"
      }
    ]
  };
};

// node_modules/@fluentui/react/lib/components/Layer/Layer.js
var Layer = styled(LayerBase, getStyles3, void 0, {
  scope: "Layer",
  fields: ["hostId", "theme", "styles"]
});

// node_modules/@fluentui/react/lib/components/Layer/LayerHost.js
var React37 = __toESM(require_react());

// node_modules/@fluentui/react/lib/components/Callout/Callout.js
var Callout = React38.forwardRef(function(_a7, forwardedRef) {
  var layerProps = _a7.layerProps, doNotLayer = _a7.doNotLayer, rest = __rest(_a7, ["layerProps", "doNotLayer"]);
  var content = React38.createElement(CalloutContent, __assign({}, rest, { doNotLayer, ref: forwardedRef }));
  return doNotLayer ? content : React38.createElement(Layer, __assign({}, layerProps), content);
});
Callout.displayName = "Callout";

// node_modules/@fluentui/react/lib/components/Callout/FocusTrapCallout.js
var React40 = __toESM(require_react());

// node_modules/@fluentui/react/lib/components/FocusTrapZone/FocusTrapZone.js
var React39 = __toESM(require_react());
var COMPONENT_NAME2 = "FocusTrapZone";
var DEFAULT_PROPS2 = {
  disabled: false,
  disableFirstFocus: false,
  forceFocusInsideTrap: true,
  isClickableOutsideFocusTrap: false,
  // Hardcoding completely uncontrolled flag for proper interop with FluentUI V9.
  "data-tabster": '{"uncontrolled": {"completely": true}}'
};
var useComponentRef = function(componentRef, previouslyFocusedElement, focusFTZ) {
  React39.useImperativeHandle(componentRef, function() {
    return {
      get previouslyFocusedElement() {
        return previouslyFocusedElement;
      },
      focus: focusFTZ
    };
  }, [focusFTZ, previouslyFocusedElement]);
};
var FocusTrapZone = React39.forwardRef(function(propsWithoutDefaults, ref) {
  var _a7;
  var root = React39.useRef(null);
  var firstBumper = React39.useRef(null);
  var lastBumper = React39.useRef(null);
  var mergedRootRef = useMergedRefs(root, ref);
  var doc = useDocument();
  var win = useWindowEx();
  var isFirstRender = (_a7 = usePrevious(false)) !== null && _a7 !== void 0 ? _a7 : true;
  var props = getPropsWithDefaults(DEFAULT_PROPS2, propsWithoutDefaults);
  var internalState = useConst({
    hasFocus: false,
    focusStackId: useId("ftz-", props.id)
  });
  var children = props.children, componentRef = props.componentRef, disabled = props.disabled, disableFirstFocus = props.disableFirstFocus, forceFocusInsideTrap = props.forceFocusInsideTrap, focusPreviouslyFocusedInnerElement = props.focusPreviouslyFocusedInnerElement, firstFocusableSelector = props.firstFocusableSelector, firstFocusableTarget = props.firstFocusableTarget, _b3 = props.disableRestoreFocus, disableRestoreFocus = _b3 === void 0 ? props.ignoreExternalFocusing : _b3, isClickableOutsideFocusTrap = props.isClickableOutsideFocusTrap, enableAriaHiddenSiblings = props.enableAriaHiddenSiblings;
  var bumperProps = {
    "aria-hidden": true,
    style: {
      pointerEvents: "none",
      position: "fixed"
      // 'fixed' prevents browsers from scrolling to bumpers when viewport does not contain them
    },
    tabIndex: disabled ? -1 : 0,
    "data-is-visible": true,
    "data-is-focus-trap-zone-bumper": true
  };
  var focusElementAsync = React39.useCallback(function(element) {
    if (element !== firstBumper.current && element !== lastBumper.current) {
      focusAsync(element);
    }
  }, []);
  var focusFTZ = useEventCallback(function() {
    if (!root.current) {
      return;
    }
    var previouslyFocusedElementInTrapZone = internalState.previouslyFocusedElementInTrapZone;
    if (focusPreviouslyFocusedInnerElement && previouslyFocusedElementInTrapZone && elementContains(root.current, previouslyFocusedElementInTrapZone)) {
      focusElementAsync(previouslyFocusedElementInTrapZone);
      return;
    }
    var firstFocusableChild = null;
    if (typeof firstFocusableTarget === "string") {
      firstFocusableChild = root.current.querySelector(firstFocusableTarget);
    } else if (firstFocusableTarget) {
      firstFocusableChild = firstFocusableTarget(root.current);
    } else if (firstFocusableSelector) {
      var focusSelector = typeof firstFocusableSelector === "string" ? firstFocusableSelector : firstFocusableSelector();
      firstFocusableChild = root.current.querySelector("." + focusSelector);
    }
    if (!firstFocusableChild) {
      firstFocusableChild = getNextElement(root.current, root.current.firstChild, false, false, false, true);
    }
    if (firstFocusableChild) {
      focusElementAsync(firstFocusableChild);
    }
  });
  var focusBumper = function(isFirstBumper) {
    if (disabled || !root.current) {
      return;
    }
    var nextFocusable = isFirstBumper === internalState.hasFocus ? getLastTabbable(root.current, lastBumper.current, true, false) : getFirstTabbable(root.current, firstBumper.current, true, false);
    if (nextFocusable) {
      if (nextFocusable === firstBumper.current || nextFocusable === lastBumper.current) {
        focusFTZ();
      } else {
        nextFocusable.focus();
      }
    }
  };
  var onRootBlurCapture = function(ev) {
    var _a8;
    (_a8 = props.onBlurCapture) === null || _a8 === void 0 ? void 0 : _a8.call(props, ev);
    var relatedTarget = ev.relatedTarget;
    if (ev.relatedTarget === null) {
      relatedTarget = doc.activeElement;
    }
    if (!elementContains(root.current, relatedTarget)) {
      internalState.hasFocus = false;
    }
  };
  var onRootFocusCapture = function(ev) {
    var _a8;
    (_a8 = props.onFocusCapture) === null || _a8 === void 0 ? void 0 : _a8.call(props, ev);
    if (ev.target === firstBumper.current) {
      focusBumper(true);
    } else if (ev.target === lastBumper.current) {
      focusBumper(false);
    }
    internalState.hasFocus = true;
    if (ev.target !== ev.currentTarget && !(ev.target === firstBumper.current || ev.target === lastBumper.current)) {
      internalState.previouslyFocusedElementInTrapZone = ev.target;
    }
  };
  var returnFocusToInitiator = useEventCallback(function(elementToFocusOnDismiss) {
    FocusTrapZone.focusStack = FocusTrapZone.focusStack.filter(function(value) {
      return internalState.focusStackId !== value;
    });
    if (!doc) {
      return;
    }
    var activeElement = doc.activeElement;
    if (!disableRestoreFocus && typeof (elementToFocusOnDismiss === null || elementToFocusOnDismiss === void 0 ? void 0 : elementToFocusOnDismiss.focus) === "function" && // only restore focus if the current focused element is within the FTZ, or if nothing is focused
    (elementContains(root.current, activeElement) || activeElement === doc.body)) {
      focusElementAsync(elementToFocusOnDismiss);
    }
  });
  var forceFocusOrClickInTrap = useEventCallback(function(ev) {
    if (disabled) {
      return;
    }
    if (internalState.focusStackId === FocusTrapZone.focusStack.slice(-1)[0]) {
      var targetElement = ev.target;
      if (targetElement && !elementContains(root.current, targetElement)) {
        if (doc && doc.activeElement === doc.body) {
          setTimeout(function() {
            if (doc && doc.activeElement === doc.body) {
              focusFTZ();
              internalState.hasFocus = true;
            }
          }, 0);
        } else {
          focusFTZ();
          internalState.hasFocus = true;
        }
        ev.preventDefault();
        ev.stopPropagation();
      }
    }
  });
  React39.useEffect(function() {
    var disposables = [];
    if (forceFocusInsideTrap) {
      disposables.push(on(win, "focus", forceFocusOrClickInTrap, true));
    }
    if (!isClickableOutsideFocusTrap) {
      disposables.push(on(win, "click", forceFocusOrClickInTrap, true));
    }
    return function() {
      disposables.forEach(function(dispose) {
        return dispose();
      });
    };
  }, [forceFocusInsideTrap, isClickableOutsideFocusTrap, win]);
  React39.useEffect(function() {
    if (disabled || !isFirstRender && !forceFocusInsideTrap || !root.current) {
      return;
    }
    FocusTrapZone.focusStack.push(internalState.focusStackId);
    var elementToFocusOnDismiss = props.elementToFocusOnDismiss || doc.activeElement;
    if (!disableFirstFocus && !elementContains(root.current, elementToFocusOnDismiss)) {
      focusFTZ();
    }
    return function() {
      return returnFocusToInitiator(elementToFocusOnDismiss);
    };
  }, [forceFocusInsideTrap, disabled]);
  React39.useEffect(function() {
    if (!disabled && enableAriaHiddenSiblings) {
      var unmodalize2 = modalize(root.current);
      return unmodalize2;
    }
  }, [disabled, enableAriaHiddenSiblings, root]);
  useUnmount(function() {
    delete internalState.previouslyFocusedElementInTrapZone;
  });
  useComponentRef(componentRef, internalState.previouslyFocusedElementInTrapZone, focusFTZ);
  return React39.createElement(
    "div",
    __assign({ "aria-labelledby": props.ariaLabelledBy }, getNativeProps(props, divProperties), { ref: mergedRootRef, onFocusCapture: onRootFocusCapture, onBlurCapture: onRootBlurCapture }),
    React39.createElement("div", __assign({}, bumperProps, { ref: firstBumper })),
    children,
    React39.createElement("div", __assign({}, bumperProps, { ref: lastBumper }))
  );
});
FocusTrapZone.displayName = COMPONENT_NAME2;
FocusTrapZone.focusStack = [];

// node_modules/@fluentui/react/lib/components/Button/BaseButton.js
var React60 = __toESM(require_react());

// node_modules/@fluentui/react/lib/components/Icon/Icon.base.js
var React43 = __toESM(require_react());

// node_modules/@fluentui/react/lib/components/Icon/Icon.types.js
var IconType;
(function(IconType2) {
  IconType2[IconType2["default"] = 0] = "default";
  IconType2[IconType2["image"] = 1] = "image";
  IconType2[IconType2["Default"] = 1e5] = "Default";
  IconType2[IconType2["Image"] = 100001] = "Image";
})(IconType || (IconType = {}));

// node_modules/@fluentui/react/lib/components/Image/Image.base.js
var React41 = __toESM(require_react());

// node_modules/@fluentui/react/lib/components/Image/Image.types.js
var ImageFit;
(function(ImageFit2) {
  ImageFit2[ImageFit2["center"] = 0] = "center";
  ImageFit2[ImageFit2["contain"] = 1] = "contain";
  ImageFit2[ImageFit2["cover"] = 2] = "cover";
  ImageFit2[ImageFit2["none"] = 3] = "none";
  ImageFit2[ImageFit2["centerCover"] = 4] = "centerCover";
  ImageFit2[ImageFit2["centerContain"] = 5] = "centerContain";
})(ImageFit || (ImageFit = {}));
var ImageCoverStyle;
(function(ImageCoverStyle2) {
  ImageCoverStyle2[ImageCoverStyle2["landscape"] = 0] = "landscape";
  ImageCoverStyle2[ImageCoverStyle2["portrait"] = 1] = "portrait";
})(ImageCoverStyle || (ImageCoverStyle = {}));
var ImageLoadState;
(function(ImageLoadState2) {
  ImageLoadState2[ImageLoadState2["notLoaded"] = 0] = "notLoaded";
  ImageLoadState2[ImageLoadState2["loaded"] = 1] = "loaded";
  ImageLoadState2[ImageLoadState2["error"] = 2] = "error";
  ImageLoadState2[ImageLoadState2["errorLoaded"] = 3] = "errorLoaded";
})(ImageLoadState || (ImageLoadState = {}));

// node_modules/@fluentui/react/lib/components/Image/Image.base.js
var getClassNames4 = classNamesFunction();
var SVG_REGEX = /\.svg$/i;
var KEY_PREFIX = "fabricImage";
function useLoadState(props, imageElement) {
  var onLoadingStateChange = props.onLoadingStateChange, onLoad = props.onLoad, onError = props.onError, src = props.src;
  var _a7 = React41.useState(ImageLoadState.notLoaded), loadState = _a7[0], setLoadState = _a7[1];
  useIsomorphicLayoutEffect(function() {
    setLoadState(ImageLoadState.notLoaded);
  }, [src]);
  React41.useEffect(function() {
    if (loadState === ImageLoadState.notLoaded) {
      var isLoaded = imageElement.current ? src && imageElement.current.naturalWidth > 0 && imageElement.current.naturalHeight > 0 || imageElement.current.complete && SVG_REGEX.test(src) : false;
      if (isLoaded) {
        setLoadState(ImageLoadState.loaded);
      }
    }
  });
  React41.useEffect(function() {
    onLoadingStateChange === null || onLoadingStateChange === void 0 ? void 0 : onLoadingStateChange(loadState);
  }, [loadState]);
  var onImageLoaded = React41.useCallback(function(ev) {
    onLoad === null || onLoad === void 0 ? void 0 : onLoad(ev);
    if (src) {
      setLoadState(ImageLoadState.loaded);
    }
  }, [src, onLoad]);
  var onImageError = React41.useCallback(function(ev) {
    onError === null || onError === void 0 ? void 0 : onError(ev);
    setLoadState(ImageLoadState.error);
  }, [onError]);
  return [loadState, onImageLoaded, onImageError];
}
var ImageBase = React41.forwardRef(function(props, forwardedRef) {
  var frameElement = React41.useRef();
  var imageElement = React41.useRef();
  var _a7 = useLoadState(props, imageElement), loadState = _a7[0], onImageLoaded = _a7[1], onImageError = _a7[2];
  var imageProps = getNativeProps(props, imgProperties, [
    "width",
    "height"
  ]);
  var src = props.src, alt = props.alt, width = props.width, height = props.height, _b3 = props.shouldFadeIn, shouldFadeIn = _b3 === void 0 ? true : _b3, shouldStartVisible = props.shouldStartVisible, className = props.className, imageFit = props.imageFit, role = props.role, maximizeFrame = props.maximizeFrame, styles = props.styles, theme = props.theme, loading = props.loading;
  var coverStyle = useCoverStyle(props, loadState, imageElement, frameElement);
  var classNames2 = getClassNames4(styles, {
    theme,
    className,
    width,
    height,
    maximizeFrame,
    shouldFadeIn,
    shouldStartVisible,
    isLoaded: loadState === ImageLoadState.loaded || loadState === ImageLoadState.notLoaded && props.shouldStartVisible,
    isLandscape: coverStyle === ImageCoverStyle.landscape,
    isCenter: imageFit === ImageFit.center,
    isCenterContain: imageFit === ImageFit.centerContain,
    isCenterCover: imageFit === ImageFit.centerCover,
    isContain: imageFit === ImageFit.contain,
    isCover: imageFit === ImageFit.cover,
    isNone: imageFit === ImageFit.none,
    isError: loadState === ImageLoadState.error,
    isNotImageFit: imageFit === void 0
  });
  return React41.createElement(
    "div",
    { className: classNames2.root, style: { width, height }, ref: frameElement },
    React41.createElement("img", __assign({}, imageProps, { onLoad: onImageLoaded, onError: onImageError, key: KEY_PREFIX + props.src || "", className: classNames2.image, ref: useMergedRefs(imageElement, forwardedRef), src, alt, role, loading }))
  );
});
ImageBase.displayName = "ImageBase";
function useCoverStyle(props, loadState, imageElement, frameElement) {
  var previousLoadState = React41.useRef(loadState);
  var coverStyle = React41.useRef();
  if (coverStyle === void 0 || previousLoadState.current === ImageLoadState.notLoaded && loadState === ImageLoadState.loaded) {
    coverStyle.current = computeCoverStyle(props, loadState, imageElement, frameElement);
  }
  previousLoadState.current = loadState;
  return coverStyle.current;
}
function computeCoverStyle(props, loadState, imageElement, frameElement) {
  var imageFit = props.imageFit, width = props.width, height = props.height;
  if (props.coverStyle !== void 0) {
    return props.coverStyle;
  } else if (loadState === ImageLoadState.loaded && (imageFit === ImageFit.cover || imageFit === ImageFit.contain || imageFit === ImageFit.centerContain || imageFit === ImageFit.centerCover) && imageElement.current && frameElement.current) {
    var desiredRatio = void 0;
    if (typeof width === "number" && typeof height === "number" && imageFit !== ImageFit.centerContain && imageFit !== ImageFit.centerCover) {
      desiredRatio = width / height;
    } else {
      desiredRatio = frameElement.current.clientWidth / frameElement.current.clientHeight;
    }
    var naturalRatio = imageElement.current.naturalWidth / imageElement.current.naturalHeight;
    if (naturalRatio > desiredRatio) {
      return ImageCoverStyle.landscape;
    }
  }
  return ImageCoverStyle.portrait;
}

// node_modules/@fluentui/react/lib/components/Image/Image.styles.js
var GlobalClassNames4 = {
  root: "ms-Image",
  rootMaximizeFrame: "ms-Image--maximizeFrame",
  image: "ms-Image-image",
  imageCenter: "ms-Image-image--center",
  imageContain: "ms-Image-image--contain",
  imageCover: "ms-Image-image--cover",
  imageCenterContain: "ms-Image-image--centerContain",
  imageCenterCover: "ms-Image-image--centerCover",
  imageNone: "ms-Image-image--none",
  imageLandscape: "ms-Image-image--landscape",
  imagePortrait: "ms-Image-image--portrait"
};
var getStyles4 = function(props) {
  var className = props.className, width = props.width, height = props.height, maximizeFrame = props.maximizeFrame, isLoaded = props.isLoaded, shouldFadeIn = props.shouldFadeIn, shouldStartVisible = props.shouldStartVisible, isLandscape = props.isLandscape, isCenter = props.isCenter, isContain = props.isContain, isCover = props.isCover, isCenterContain = props.isCenterContain, isCenterCover = props.isCenterCover, isNone = props.isNone, isError = props.isError, isNotImageFit = props.isNotImageFit, theme = props.theme;
  var classNames2 = getGlobalClassNames(GlobalClassNames4, theme);
  var ImageFitStyles = {
    position: "absolute",
    left: "50% /* @noflip */",
    top: "50%",
    transform: "translate(-50%,-50%)"
    // @todo test RTL renders transform: translate(50%,-50%);
  };
  var window2 = getWindow();
  var supportsObjectFit = window2 !== void 0 && // eslint-disable-next-line @fluentui/max-len
  // cast needed as vendor prefixed `msMaxTouchPoints` api is no longer part of TS lib declaration - introduced with TS 4.4
  window2.navigator.msMaxTouchPoints === void 0;
  var fallbackObjectFitStyles = isContain && isLandscape || isCover && !isLandscape ? { width: "100%", height: "auto" } : { width: "auto", height: "100%" };
  return {
    root: [
      classNames2.root,
      theme.fonts.medium,
      {
        overflow: "hidden"
      },
      maximizeFrame && [
        classNames2.rootMaximizeFrame,
        {
          height: "100%",
          width: "100%"
        }
      ],
      isLoaded && shouldFadeIn && !shouldStartVisible && AnimationClassNames.fadeIn400,
      (isCenter || isContain || isCover || isCenterContain || isCenterCover) && {
        position: "relative"
      },
      className
    ],
    image: [
      classNames2.image,
      {
        display: "block",
        opacity: 0
      },
      isLoaded && [
        "is-loaded",
        {
          opacity: 1
        }
      ],
      isCenter && [classNames2.imageCenter, ImageFitStyles],
      isContain && [
        classNames2.imageContain,
        supportsObjectFit && {
          width: "100%",
          height: "100%",
          objectFit: "contain"
        },
        !supportsObjectFit && fallbackObjectFitStyles,
        !supportsObjectFit && ImageFitStyles
      ],
      isCover && [
        classNames2.imageCover,
        supportsObjectFit && {
          width: "100%",
          height: "100%",
          objectFit: "cover"
        },
        !supportsObjectFit && fallbackObjectFitStyles,
        !supportsObjectFit && ImageFitStyles
      ],
      isCenterContain && [
        classNames2.imageCenterContain,
        isLandscape && {
          maxWidth: "100%"
        },
        !isLandscape && {
          maxHeight: "100%"
        },
        ImageFitStyles
      ],
      isCenterCover && [
        classNames2.imageCenterCover,
        isLandscape && {
          maxHeight: "100%"
        },
        !isLandscape && {
          maxWidth: "100%"
        },
        ImageFitStyles
      ],
      isNone && [
        classNames2.imageNone,
        {
          width: "auto",
          height: "auto"
        }
      ],
      isNotImageFit && [
        !!width && !height && {
          height: "auto",
          width: "100%"
        },
        !width && !!height && {
          height: "100%",
          width: "auto"
        },
        !!width && !!height && {
          height: "100%",
          width: "100%"
        }
      ],
      isLandscape && classNames2.imageLandscape,
      !isLandscape && classNames2.imagePortrait,
      !isLoaded && "is-notLoaded",
      shouldFadeIn && "is-fadeIn",
      isError && "is-error"
    ]
  };
};

// node_modules/@fluentui/react/lib/components/Image/Image.js
var Image = styled(ImageBase, getStyles4, void 0, {
  scope: "Image"
}, true);
Image.displayName = "Image";

// node_modules/@fluentui/react/lib/components/Icon/FontIcon.js
var React42 = __toESM(require_react());

// node_modules/@fluentui/react/lib/components/Icon/Icon.styles.js
var classNames = mergeStyleSets({
  root: {
    display: "inline-block"
  },
  placeholder: [
    "ms-Icon-placeHolder",
    {
      width: "1em"
    }
  ],
  image: [
    "ms-Icon-imageContainer",
    {
      overflow: "hidden"
    }
  ]
});
var MS_ICON = "ms-Icon";
var getStyles5 = function(props) {
  var className = props.className, iconClassName = props.iconClassName, isPlaceholder = props.isPlaceholder, isImage = props.isImage, styles = props.styles;
  return {
    root: [
      isPlaceholder && classNames.placeholder,
      classNames.root,
      isImage && classNames.image,
      iconClassName,
      className,
      styles && styles.root,
      // eslint-disable-next-line deprecation/deprecation
      styles && styles.imageContainer
    ]
  };
};

// node_modules/@fluentui/react/lib/components/Icon/FontIcon.js
var getIconContent = memoizeFunction(
  function(iconName) {
    var _a7 = getIcon(iconName) || {
      subset: {},
      code: void 0
    }, code = _a7.code, subset = _a7.subset;
    if (!code) {
      return null;
    }
    return {
      children: code,
      iconClassName: subset.className,
      fontFamily: subset.fontFace && subset.fontFace.fontFamily,
      mergeImageProps: subset.mergeImageProps
    };
  },
  void 0,
  true
  /*ignoreNullOrUndefinedResult */
);
var FontIcon = function(props) {
  var iconName = props.iconName, className = props.className, _a7 = props.style, style = _a7 === void 0 ? {} : _a7;
  var iconContent = getIconContent(iconName) || {};
  var iconClassName = iconContent.iconClassName, children = iconContent.children, fontFamily = iconContent.fontFamily, mergeImageProps = iconContent.mergeImageProps;
  var nativeProps = getNativeProps(props, htmlElementProperties);
  var accessibleName = props["aria-label"] || props.title;
  var containerProps = props["aria-label"] || props["aria-labelledby"] || props.title ? {
    role: mergeImageProps ? void 0 : "img"
  } : {
    "aria-hidden": true
  };
  var finalChildren = children;
  if (mergeImageProps) {
    if (typeof children === "object" && typeof children.props === "object" && accessibleName) {
      finalChildren = React42.cloneElement(children, { alt: accessibleName });
    }
  }
  return React42.createElement("i", __assign({ "data-icon-name": iconName }, containerProps, nativeProps, mergeImageProps ? {
    title: void 0,
    "aria-label": void 0
  } : {}, {
    className: css(MS_ICON, classNames.root, iconClassName, !iconName && classNames.placeholder, className),
    // Apply the font family this way to ensure it doesn't get overridden by Fabric Core ms-Icon styles
    // https://github.com/microsoft/fluentui/issues/10449
    style: __assign({ fontFamily }, style)
  }), finalChildren);
};
var getFontIcon = memoizeFunction(function(iconName, className, ariaLabel) {
  return FontIcon({ iconName, className, "aria-label": ariaLabel });
});

// node_modules/@fluentui/react/lib/components/Icon/Icon.base.js
var getClassNames5 = classNamesFunction({
  // Icon is used a lot by other components.
  // It's likely to see expected cases which pass different className to the Icon.
  // Therefore setting a larger cache size.
  cacheSize: 100
});
var IconBase = (
  /** @class */
  function(_super) {
    __extends(IconBase2, _super);
    function IconBase2(props) {
      var _this = _super.call(this, props) || this;
      _this._onImageLoadingStateChange = function(state) {
        if (_this.props.imageProps && _this.props.imageProps.onLoadingStateChange) {
          _this.props.imageProps.onLoadingStateChange(state);
        }
        if (state === ImageLoadState.error) {
          _this.setState({ imageLoadError: true });
        }
      };
      _this.state = {
        imageLoadError: false
      };
      return _this;
    }
    IconBase2.prototype.render = function() {
      var _a7 = this.props, children = _a7.children, className = _a7.className, styles = _a7.styles, iconName = _a7.iconName, imageErrorAs = _a7.imageErrorAs, theme = _a7.theme;
      var isPlaceholder = typeof iconName === "string" && iconName.length === 0;
      var isImage = (
        // eslint-disable-next-line deprecation/deprecation
        !!this.props.imageProps || this.props.iconType === IconType.image || this.props.iconType === IconType.Image
      );
      var iconContent = getIconContent(iconName) || {};
      var iconClassName = iconContent.iconClassName, iconContentChildren = iconContent.children, mergeImageProps = iconContent.mergeImageProps;
      var classNames2 = getClassNames5(styles, {
        theme,
        className,
        iconClassName,
        isImage,
        isPlaceholder
      });
      var RootType = isImage ? "span" : "i";
      var nativeProps = getNativeProps(this.props, htmlElementProperties, [
        "aria-label"
      ]);
      var imageLoadError = this.state.imageLoadError;
      var imageProps = __assign(__assign({}, this.props.imageProps), { onLoadingStateChange: this._onImageLoadingStateChange });
      var ImageType = imageLoadError && imageErrorAs || Image;
      var ariaLabel = this.props["aria-label"] || this.props.ariaLabel;
      var accessibleName = imageProps.alt || ariaLabel || this.props.title;
      var hasName = !!(accessibleName || this.props["aria-labelledby"] || imageProps["aria-label"] || imageProps["aria-labelledby"]);
      var containerProps = hasName ? {
        role: isImage || mergeImageProps ? void 0 : "img",
        "aria-label": isImage || mergeImageProps ? void 0 : accessibleName
      } : {
        "aria-hidden": true
      };
      var finalIconContentChildren = iconContentChildren;
      if (mergeImageProps && iconContentChildren && typeof iconContentChildren === "object" && accessibleName) {
        finalIconContentChildren = React43.cloneElement(iconContentChildren, {
          alt: accessibleName
        });
      }
      return React43.createElement(RootType, __assign({ "data-icon-name": iconName }, containerProps, nativeProps, mergeImageProps ? {
        title: void 0,
        "aria-label": void 0
      } : {}, { className: classNames2.root }), isImage ? React43.createElement(ImageType, __assign({}, imageProps)) : children || finalIconContentChildren);
    };
    return IconBase2;
  }(React43.Component)
);

// node_modules/@fluentui/react/lib/components/Icon/Icon.js
var Icon = styled(IconBase, getStyles5, void 0, {
  scope: "Icon"
}, true);
Icon.displayName = "Icon";

// node_modules/@fluentui/react/lib/components/Icon/ImageIcon.js
var React44 = __toESM(require_react());
var ImageIcon = function(props) {
  var className = props.className, imageProps = props.imageProps;
  var nativeProps = getNativeProps(props, htmlElementProperties, [
    "aria-label",
    "aria-labelledby",
    "title",
    "aria-describedby"
  ]);
  var altText = imageProps.alt || props["aria-label"];
  var hasName = altText || props["aria-labelledby"] || props.title || imageProps["aria-label"] || imageProps["aria-labelledby"] || imageProps.title;
  var imageNameProps = {
    "aria-labelledby": props["aria-labelledby"],
    "aria-describedby": props["aria-describedby"],
    title: props.title
  };
  var containerProps = hasName ? {} : {
    "aria-hidden": true
  };
  return React44.createElement(
    "div",
    __assign({}, containerProps, nativeProps, { className: css(MS_ICON, classNames.root, classNames.image, className) }),
    React44.createElement(Image, __assign({}, imageNameProps, imageProps, { alt: hasName ? altText : "" }))
  );
};

// node_modules/@fluentui/react/lib/components/ContextualMenu/ContextualMenu.js
var React59 = __toESM(require_react());

// node_modules/@fluentui/react/lib/components/ContextualMenu/ContextualMenu.base.js
var React58 = __toESM(require_react());

// node_modules/@fluentui/react/lib/components/ContextualMenu/ContextualMenu.types.js
var ContextualMenuItemType;
(function(ContextualMenuItemType2) {
  ContextualMenuItemType2[ContextualMenuItemType2["Normal"] = 0] = "Normal";
  ContextualMenuItemType2[ContextualMenuItemType2["Divider"] = 1] = "Divider";
  ContextualMenuItemType2[ContextualMenuItemType2["Header"] = 2] = "Header";
  ContextualMenuItemType2[ContextualMenuItemType2["Section"] = 3] = "Section";
})(ContextualMenuItemType || (ContextualMenuItemType = {}));

// node_modules/@fluentui/react-focus/lib/version.js
setVersion("@fluentui/react-focus", "8.8.40");

// node_modules/@fluentui/react-focus/lib/components/FocusZone/FocusZone.js
var React45 = __toESM(require_react());

// node_modules/@fluentui/react-focus/lib/components/FocusZone/FocusZone.types.js
var FocusZoneTabbableElements = {
  /** Tabbing is not allowed */
  none: 0,
  /** All tabbing action is allowed */
  all: 1,
  /** Tabbing is allowed only on input elements */
  inputOnly: 2
};
var FocusZoneDirection;
(function(FocusZoneDirection2) {
  FocusZoneDirection2[FocusZoneDirection2["vertical"] = 0] = "vertical";
  FocusZoneDirection2[FocusZoneDirection2["horizontal"] = 1] = "horizontal";
  FocusZoneDirection2[FocusZoneDirection2["bidirectional"] = 2] = "bidirectional";
  FocusZoneDirection2[FocusZoneDirection2["domOrder"] = 3] = "domOrder";
})(FocusZoneDirection || (FocusZoneDirection = {}));

// node_modules/@fluentui/react-focus/lib/components/FocusZone/FocusZone.js
var IS_FOCUSABLE_ATTRIBUTE2 = "data-is-focusable";
var IS_ENTER_DISABLED_ATTRIBUTE = "data-disable-click-on-enter";
var FOCUSZONE_ID_ATTRIBUTE2 = "data-focuszone-id";
var TABINDEX = "tabindex";
var NO_VERTICAL_WRAP = "data-no-vertical-wrap";
var NO_HORIZONTAL_WRAP = "data-no-horizontal-wrap";
var LARGE_DISTANCE_FROM_CENTER = 999999999;
var LARGE_NEGATIVE_DISTANCE_FROM_CENTER = -999999999;
var focusZoneStyles;
var focusZoneClass = "ms-FocusZone";
function raiseClickFromKeyboardEvent(target, ev) {
  var event;
  if (typeof MouseEvent === "function") {
    event = new MouseEvent("click", {
      ctrlKey: ev === null || ev === void 0 ? void 0 : ev.ctrlKey,
      metaKey: ev === null || ev === void 0 ? void 0 : ev.metaKey,
      shiftKey: ev === null || ev === void 0 ? void 0 : ev.shiftKey,
      altKey: ev === null || ev === void 0 ? void 0 : ev.altKey,
      bubbles: ev === null || ev === void 0 ? void 0 : ev.bubbles,
      cancelable: ev === null || ev === void 0 ? void 0 : ev.cancelable
    });
  } else {
    event = document.createEvent("MouseEvents");
    event.initMouseEvent(
      "click",
      ev ? ev.bubbles : false,
      ev ? ev.cancelable : false,
      // eslint-disable-next-line no-restricted-globals
      window,
      // not using getWindow() since this can only be run client side
      0,
      // detail
      0,
      // screen x
      0,
      // screen y
      0,
      // client x
      0,
      // client y
      ev ? ev.ctrlKey : false,
      ev ? ev.altKey : false,
      ev ? ev.shiftKey : false,
      ev ? ev.metaKey : false,
      0,
      // button
      null
    );
  }
  target.dispatchEvent(event);
}
function getRootClass() {
  if (!focusZoneStyles) {
    focusZoneStyles = mergeStyles({
      selectors: {
        ":focus": {
          outline: "none"
        }
      }
    }, focusZoneClass);
  }
  return focusZoneStyles;
}
var _allInstances = {};
var _outerZones = /* @__PURE__ */ new Set();
var ALLOWED_INPUT_TYPES = ["text", "number", "password", "email", "tel", "url", "search", "textarea"];
var ALLOW_VIRTUAL_ELEMENTS = false;
var FocusZone = (
  /** @class */
  function(_super) {
    __extends(FocusZone2, _super);
    function FocusZone2(props) {
      var _this = this;
      var _a7, _b3, _c3, _d3;
      _this = _super.call(this, props) || this;
      _this._root = React45.createRef();
      _this._mergedRef = createMergedRef();
      _this._onFocus = function(ev) {
        if (_this._portalContainsElement(ev.target)) {
          return;
        }
        var _a8 = _this.props, onActiveElementChanged = _a8.onActiveElementChanged, doNotAllowFocusEventToPropagate = _a8.doNotAllowFocusEventToPropagate, stopFocusPropagation = _a8.stopFocusPropagation, onFocusNotification = _a8.onFocusNotification, onFocus = _a8.onFocus, shouldFocusInnerElementWhenReceivedFocus = _a8.shouldFocusInnerElementWhenReceivedFocus, defaultTabbableElement = _a8.defaultTabbableElement;
        var isImmediateDescendant = _this._isImmediateDescendantOfZone(ev.target);
        var newActiveElement;
        if (isImmediateDescendant) {
          newActiveElement = ev.target;
        } else {
          var parentElement = ev.target;
          while (parentElement && parentElement !== _this._root.current) {
            if (isElementTabbable(parentElement) && _this._isImmediateDescendantOfZone(parentElement)) {
              newActiveElement = parentElement;
              break;
            }
            parentElement = getParent(parentElement, ALLOW_VIRTUAL_ELEMENTS);
          }
        }
        if (shouldFocusInnerElementWhenReceivedFocus && ev.target === _this._root.current) {
          var maybeElementToFocus = defaultTabbableElement && typeof defaultTabbableElement === "function" && _this._root.current && defaultTabbableElement(_this._root.current);
          if (maybeElementToFocus && isElementTabbable(maybeElementToFocus)) {
            newActiveElement = maybeElementToFocus;
            maybeElementToFocus.focus();
          } else {
            _this.focus(true);
            if (_this._activeElement) {
              newActiveElement = null;
            }
          }
        }
        var initialElementFocused = !_this._activeElement;
        if (newActiveElement && newActiveElement !== _this._activeElement) {
          if (isImmediateDescendant || initialElementFocused) {
            _this._setFocusAlignment(newActiveElement, true, true);
          }
          _this._activeElement = newActiveElement;
          if (initialElementFocused) {
            _this._updateTabIndexes();
          }
        }
        if (onActiveElementChanged) {
          onActiveElementChanged(_this._activeElement, ev);
        }
        if (stopFocusPropagation || doNotAllowFocusEventToPropagate) {
          ev.stopPropagation();
        }
        if (onFocus) {
          onFocus(ev);
        } else if (onFocusNotification) {
          onFocusNotification();
        }
      };
      _this._onBlur = function() {
        _this._setParkedFocus(false);
      };
      _this._onMouseDown = function(ev) {
        if (_this._portalContainsElement(ev.target)) {
          return;
        }
        var disabled = _this.props.disabled;
        if (disabled) {
          return;
        }
        var target = ev.target;
        var path = [];
        while (target && target !== _this._root.current) {
          path.push(target);
          target = getParent(target, ALLOW_VIRTUAL_ELEMENTS);
        }
        while (path.length) {
          target = path.pop();
          if (target && isElementTabbable(target)) {
            _this._setActiveElement(target, true);
          }
          if (isElementFocusZone(target)) {
            break;
          }
        }
      };
      _this._onKeyDown = function(ev, theme) {
        if (_this._portalContainsElement(ev.target)) {
          return;
        }
        var _a8 = _this.props, direction = _a8.direction, disabled = _a8.disabled, isInnerZoneKeystroke = _a8.isInnerZoneKeystroke, pagingSupportDisabled = _a8.pagingSupportDisabled, shouldEnterInnerZone = _a8.shouldEnterInnerZone;
        if (disabled) {
          return;
        }
        if (_this.props.onKeyDown) {
          _this.props.onKeyDown(ev);
        }
        if (ev.isDefaultPrevented()) {
          return;
        }
        if (_this._getDocument().activeElement === _this._root.current && _this._isInnerZone) {
          return;
        }
        if ((shouldEnterInnerZone && shouldEnterInnerZone(ev) || isInnerZoneKeystroke && isInnerZoneKeystroke(ev)) && _this._isImmediateDescendantOfZone(ev.target)) {
          var innerZone = _this._getFirstInnerZone();
          if (innerZone) {
            if (!innerZone.focus(true)) {
              return;
            }
          } else if (isElementFocusSubZone(ev.target)) {
            if (!_this.focusElement(getNextElement(ev.target, ev.target.firstChild, true))) {
              return;
            }
          } else {
            return;
          }
        } else if (ev.altKey) {
          return;
        } else {
          switch (ev.which) {
            case KeyCodes.space:
              if (_this._shouldRaiseClicksOnSpace && _this._tryInvokeClickForFocusable(ev.target, ev)) {
                break;
              }
              return;
            case KeyCodes.left:
              if (direction !== FocusZoneDirection.vertical) {
                _this._preventDefaultWhenHandled(ev);
                if (_this._moveFocusLeft(theme)) {
                  break;
                }
              }
              return;
            case KeyCodes.right:
              if (direction !== FocusZoneDirection.vertical) {
                _this._preventDefaultWhenHandled(ev);
                if (_this._moveFocusRight(theme)) {
                  break;
                }
              }
              return;
            case KeyCodes.up:
              if (direction !== FocusZoneDirection.horizontal) {
                _this._preventDefaultWhenHandled(ev);
                if (_this._moveFocusUp()) {
                  break;
                }
              }
              return;
            case KeyCodes.down:
              if (direction !== FocusZoneDirection.horizontal) {
                _this._preventDefaultWhenHandled(ev);
                if (_this._moveFocusDown()) {
                  break;
                }
              }
              return;
            case KeyCodes.pageDown:
              if (!pagingSupportDisabled && _this._moveFocusPaging(true)) {
                break;
              }
              return;
            case KeyCodes.pageUp:
              if (!pagingSupportDisabled && _this._moveFocusPaging(false)) {
                break;
              }
              return;
            case KeyCodes.tab:
              if (
                // eslint-disable-next-line deprecation/deprecation
                _this.props.allowTabKey || _this.props.handleTabKey === FocusZoneTabbableElements.all || _this.props.handleTabKey === FocusZoneTabbableElements.inputOnly && _this._isElementInput(ev.target)
              ) {
                var focusChanged = false;
                _this._processingTabKey = true;
                if (direction === FocusZoneDirection.vertical || !_this._shouldWrapFocus(_this._activeElement, NO_HORIZONTAL_WRAP)) {
                  focusChanged = ev.shiftKey ? _this._moveFocusUp() : _this._moveFocusDown();
                } else {
                  var tabWithDirection = getRTL2(theme) ? !ev.shiftKey : ev.shiftKey;
                  focusChanged = tabWithDirection ? _this._moveFocusLeft(theme) : _this._moveFocusRight(theme);
                }
                _this._processingTabKey = false;
                if (focusChanged) {
                  break;
                } else if (_this.props.shouldResetActiveElementWhenTabFromZone) {
                  _this._activeElement = null;
                }
              }
              return;
            case KeyCodes.home:
              if (_this._isContentEditableElement(ev.target) || _this._isElementInput(ev.target) && !_this._shouldInputLoseFocus(ev.target, false)) {
                return false;
              }
              var firstChild = _this._root.current && _this._root.current.firstChild;
              if (_this._root.current && firstChild && _this.focusElement(getNextElement(_this._root.current, firstChild, true))) {
                break;
              }
              return;
            case KeyCodes.end:
              if (_this._isContentEditableElement(ev.target) || _this._isElementInput(ev.target) && !_this._shouldInputLoseFocus(ev.target, true)) {
                return false;
              }
              var lastChild = _this._root.current && _this._root.current.lastChild;
              if (_this._root.current && _this.focusElement(getPreviousElement(_this._root.current, lastChild, true, true, true))) {
                break;
              }
              return;
            case KeyCodes.enter:
              if (_this._shouldRaiseClicksOnEnter && _this._tryInvokeClickForFocusable(ev.target, ev)) {
                break;
              }
              return;
            default:
              return;
          }
        }
        ev.preventDefault();
        ev.stopPropagation();
      };
      _this._getHorizontalDistanceFromCenter = function(isForward, activeRect, targetRect) {
        var leftAlignment = _this._focusAlignment.left || _this._focusAlignment.x || 0;
        var targetRectTop = Math.floor(targetRect.top);
        var activeRectBottom = Math.floor(activeRect.bottom);
        var targetRectBottom = Math.floor(targetRect.bottom);
        var activeRectTop = Math.floor(activeRect.top);
        var isValidCandidateOnpagingDown = isForward && targetRectTop > activeRectBottom;
        var isValidCandidateOnpagingUp = !isForward && targetRectBottom < activeRectTop;
        if (isValidCandidateOnpagingDown || isValidCandidateOnpagingUp) {
          if (leftAlignment >= targetRect.left && leftAlignment <= targetRect.left + targetRect.width) {
            return 0;
          }
          return Math.abs(targetRect.left + targetRect.width / 2 - leftAlignment);
        }
        if (!_this._shouldWrapFocus(_this._activeElement, NO_VERTICAL_WRAP)) {
          return LARGE_NEGATIVE_DISTANCE_FROM_CENTER;
        }
        return LARGE_DISTANCE_FROM_CENTER;
      };
      initializeComponentRef(_this);
      if (true) {
        warnDeprecations("FocusZone", props, {
          rootProps: void 0,
          allowTabKey: "handleTabKey",
          elementType: "as",
          ariaDescribedBy: "aria-describedby",
          ariaLabelledBy: "aria-labelledby"
        });
      }
      _this._id = getId("FocusZone");
      _this._focusAlignment = {
        left: 0,
        top: 0
      };
      _this._processingTabKey = false;
      var shouldRaiseClicksFallback = (_b3 = (_a7 = props.shouldRaiseClicks) !== null && _a7 !== void 0 ? _a7 : FocusZone2.defaultProps.shouldRaiseClicks) !== null && _b3 !== void 0 ? _b3 : true;
      _this._shouldRaiseClicksOnEnter = (_c3 = props.shouldRaiseClicksOnEnter) !== null && _c3 !== void 0 ? _c3 : shouldRaiseClicksFallback;
      _this._shouldRaiseClicksOnSpace = (_d3 = props.shouldRaiseClicksOnSpace) !== null && _d3 !== void 0 ? _d3 : shouldRaiseClicksFallback;
      return _this;
    }
    FocusZone2.getOuterZones = function() {
      return _outerZones.size;
    };
    FocusZone2._onKeyDownCapture = function(ev) {
      if (ev.which === KeyCodes.tab) {
        _outerZones.forEach(function(zone) {
          return zone._updateTabIndexes();
        });
      }
    };
    FocusZone2.prototype.componentDidMount = function() {
      var root = this._root.current;
      _allInstances[this._id] = this;
      if (root) {
        var parentElement = getParent(root, ALLOW_VIRTUAL_ELEMENTS);
        while (parentElement && parentElement !== this._getDocument().body && parentElement.nodeType === 1) {
          if (isElementFocusZone(parentElement)) {
            this._isInnerZone = true;
            break;
          }
          parentElement = getParent(parentElement, ALLOW_VIRTUAL_ELEMENTS);
        }
        if (!this._isInnerZone) {
          _outerZones.add(this);
          this._root.current && this._root.current.addEventListener("keydown", FocusZone2._onKeyDownCapture, true);
        }
        this._root.current && this._root.current.addEventListener("blur", this._onBlur, true);
        this._updateTabIndexes();
        if (this.props.defaultTabbableElement && typeof this.props.defaultTabbableElement === "string") {
          this._activeElement = this._getDocument().querySelector(this.props.defaultTabbableElement);
        } else if (this.props.defaultActiveElement) {
          this._activeElement = this._getDocument().querySelector(this.props.defaultActiveElement);
        }
        if (this.props.shouldFocusOnMount) {
          this.focus();
        }
      }
    };
    FocusZone2.prototype.componentDidUpdate = function() {
      var root = this._root.current;
      var doc = this._getDocument();
      if (this._activeElement && !elementContains(this._root.current, this._activeElement, ALLOW_VIRTUAL_ELEMENTS) || this._defaultFocusElement && !elementContains(this._root.current, this._defaultFocusElement, ALLOW_VIRTUAL_ELEMENTS)) {
        this._activeElement = null;
        this._defaultFocusElement = null;
        this._updateTabIndexes();
      }
      if (!this.props.preventFocusRestoration && doc && this._lastIndexPath && (doc.activeElement === doc.body || doc.activeElement === null || doc.activeElement === root)) {
        var elementToFocus = getFocusableByIndexPath(root, this._lastIndexPath);
        if (elementToFocus) {
          this._setActiveElement(elementToFocus, true);
          elementToFocus.focus();
          this._setParkedFocus(false);
        } else {
          this._setParkedFocus(true);
        }
      }
    };
    FocusZone2.prototype.componentWillUnmount = function() {
      delete _allInstances[this._id];
      if (!this._isInnerZone) {
        _outerZones.delete(this);
        this._root.current && this._root.current.removeEventListener("keydown", FocusZone2._onKeyDownCapture, true);
      }
      if (this._root.current) {
        this._root.current.removeEventListener("blur", this._onBlur, true);
      }
      this._activeElement = null;
      this._defaultFocusElement = null;
    };
    FocusZone2.prototype.render = function() {
      var _this = this;
      var _a7 = this.props, tag = _a7.as, elementType = _a7.elementType, rootProps = _a7.rootProps, ariaDescribedBy = _a7.ariaDescribedBy, ariaLabelledBy = _a7.ariaLabelledBy, className = _a7.className;
      var divProps = getNativeProps(this.props, htmlElementProperties);
      var Tag = tag || elementType || "div";
      this._evaluateFocusBeforeRender();
      var theme = getTheme();
      return React45.createElement(Tag, __assign({ "aria-labelledby": ariaLabelledBy, "aria-describedby": ariaDescribedBy }, divProps, rootProps, {
        // Once the getClassName correctly memoizes inputs this should
        // be replaced so that className is passed to getRootClass and is included there so
        // the class names will always be in the same order.
        className: css(getRootClass(), className),
        // eslint-disable-next-line deprecation/deprecation
        ref: this._mergedRef(this.props.elementRef, this._root),
        "data-focuszone-id": this._id,
        // eslint-disable-next-line react/jsx-no-bind
        onKeyDown: function(ev) {
          return _this._onKeyDown(ev, theme);
        },
        onFocus: this._onFocus,
        onMouseDownCapture: this._onMouseDown
      }), this.props.children);
    };
    FocusZone2.prototype.focus = function(forceIntoFirstElement, bypassHiddenElements) {
      if (forceIntoFirstElement === void 0) {
        forceIntoFirstElement = false;
      }
      if (bypassHiddenElements === void 0) {
        bypassHiddenElements = false;
      }
      if (this._root.current) {
        if (!forceIntoFirstElement && this._root.current.getAttribute(IS_FOCUSABLE_ATTRIBUTE2) === "true" && this._isInnerZone) {
          var ownerZoneElement = this._getOwnerZone(this._root.current);
          if (ownerZoneElement !== this._root.current) {
            var ownerZone = _allInstances[ownerZoneElement.getAttribute(FOCUSZONE_ID_ATTRIBUTE2)];
            return !!ownerZone && ownerZone.focusElement(this._root.current);
          }
          return false;
        } else if (!forceIntoFirstElement && this._activeElement && elementContains(this._root.current, this._activeElement) && isElementTabbable(this._activeElement) && (!bypassHiddenElements || isElementVisibleAndNotHidden(this._activeElement))) {
          this._activeElement.focus();
          return true;
        } else {
          var firstChild = this._root.current.firstChild;
          return this.focusElement(getNextElement(this._root.current, firstChild, true, void 0, void 0, void 0, void 0, void 0, bypassHiddenElements));
        }
      }
      return false;
    };
    FocusZone2.prototype.focusLast = function() {
      if (this._root.current) {
        var lastChild = this._root.current && this._root.current.lastChild;
        return this.focusElement(getPreviousElement(this._root.current, lastChild, true, true, true));
      }
      return false;
    };
    FocusZone2.prototype.focusElement = function(element, forceAlignment) {
      var _a7 = this.props, onBeforeFocus = _a7.onBeforeFocus, shouldReceiveFocus = _a7.shouldReceiveFocus;
      if (shouldReceiveFocus && !shouldReceiveFocus(element) || onBeforeFocus && !onBeforeFocus(element)) {
        return false;
      }
      if (element) {
        this._setActiveElement(element, forceAlignment);
        if (this._activeElement) {
          this._activeElement.focus();
        }
        return true;
      }
      return false;
    };
    FocusZone2.prototype.setFocusAlignment = function(point) {
      this._focusAlignment = point;
    };
    Object.defineProperty(FocusZone2.prototype, "defaultFocusElement", {
      get: function() {
        return this._defaultFocusElement;
      },
      enumerable: false,
      configurable: true
    });
    Object.defineProperty(FocusZone2.prototype, "activeElement", {
      get: function() {
        return this._activeElement;
      },
      enumerable: false,
      configurable: true
    });
    FocusZone2.prototype._evaluateFocusBeforeRender = function() {
      var root = this._root.current;
      var doc = this._getDocument();
      if (doc) {
        var focusedElement = doc.activeElement;
        if (focusedElement !== root) {
          var shouldRestoreFocus = elementContains(root, focusedElement, false);
          this._lastIndexPath = shouldRestoreFocus ? getElementIndexPath(root, focusedElement) : void 0;
        }
      }
    };
    FocusZone2.prototype._setParkedFocus = function(isParked) {
      var root = this._root.current;
      if (root && this._isParked !== isParked) {
        this._isParked = isParked;
        if (isParked) {
          if (!this.props.allowFocusRoot) {
            this._parkedTabIndex = root.getAttribute("tabindex");
            root.setAttribute("tabindex", "-1");
          }
          root.focus();
        } else if (!this.props.allowFocusRoot) {
          if (this._parkedTabIndex) {
            root.setAttribute("tabindex", this._parkedTabIndex);
            this._parkedTabIndex = void 0;
          } else {
            root.removeAttribute("tabindex");
          }
        }
      }
    };
    FocusZone2.prototype._setActiveElement = function(element, forceAlignment) {
      var previousActiveElement = this._activeElement;
      this._activeElement = element;
      if (previousActiveElement) {
        if (isElementFocusZone(previousActiveElement)) {
          this._updateTabIndexes(previousActiveElement);
        }
        previousActiveElement.tabIndex = -1;
      }
      if (this._activeElement) {
        if (!this._focusAlignment || forceAlignment) {
          this._setFocusAlignment(element, true, true);
        }
        this._activeElement.tabIndex = 0;
      }
    };
    FocusZone2.prototype._preventDefaultWhenHandled = function(ev) {
      this.props.preventDefaultWhenHandled && ev.preventDefault();
    };
    FocusZone2.prototype._tryInvokeClickForFocusable = function(targetElement, ev) {
      var target = targetElement;
      if (target === this._root.current) {
        return false;
      }
      do {
        if (target.tagName === "BUTTON" || target.tagName === "A" || target.tagName === "INPUT" || target.tagName === "TEXTAREA" || target.tagName === "SUMMARY") {
          return false;
        }
        if (this._isImmediateDescendantOfZone(target) && target.getAttribute(IS_FOCUSABLE_ATTRIBUTE2) === "true" && target.getAttribute(IS_ENTER_DISABLED_ATTRIBUTE) !== "true") {
          raiseClickFromKeyboardEvent(target, ev);
          return true;
        }
        target = getParent(target, ALLOW_VIRTUAL_ELEMENTS);
      } while (target !== this._root.current);
      return false;
    };
    FocusZone2.prototype._getFirstInnerZone = function(rootElement) {
      rootElement = rootElement || this._activeElement || this._root.current;
      if (!rootElement) {
        return null;
      }
      if (isElementFocusZone(rootElement)) {
        return _allInstances[rootElement.getAttribute(FOCUSZONE_ID_ATTRIBUTE2)];
      }
      var child = rootElement.firstElementChild;
      while (child) {
        if (isElementFocusZone(child)) {
          return _allInstances[child.getAttribute(FOCUSZONE_ID_ATTRIBUTE2)];
        }
        var match = this._getFirstInnerZone(child);
        if (match) {
          return match;
        }
        child = child.nextElementSibling;
      }
      return null;
    };
    FocusZone2.prototype._moveFocus = function(isForward, getDistanceFromCenter, ev, useDefaultWrap) {
      if (useDefaultWrap === void 0) {
        useDefaultWrap = true;
      }
      var element = this._activeElement;
      var candidateDistance = -1;
      var candidateElement = void 0;
      var changedFocus = false;
      var isBidirectional = this.props.direction === FocusZoneDirection.bidirectional;
      if (!element || !this._root.current) {
        return false;
      }
      if (this._isElementInput(element)) {
        if (!this._shouldInputLoseFocus(element, isForward)) {
          return false;
        }
      }
      var activeRect = isBidirectional ? element.getBoundingClientRect() : null;
      do {
        element = isForward ? getNextElement(this._root.current, element) : getPreviousElement(this._root.current, element);
        if (isBidirectional) {
          if (element) {
            var targetRect = element.getBoundingClientRect();
            var elementDistance = getDistanceFromCenter(activeRect, targetRect);
            if (elementDistance === -1 && candidateDistance === -1) {
              candidateElement = element;
              break;
            }
            if (elementDistance > -1 && (candidateDistance === -1 || elementDistance < candidateDistance)) {
              candidateDistance = elementDistance;
              candidateElement = element;
            }
            if (candidateDistance >= 0 && elementDistance < 0) {
              break;
            }
          }
        } else {
          candidateElement = element;
          break;
        }
      } while (element);
      if (candidateElement && candidateElement !== this._activeElement) {
        changedFocus = true;
        this.focusElement(candidateElement);
      } else if (this.props.isCircularNavigation && useDefaultWrap) {
        if (isForward) {
          return this.focusElement(getNextElement(this._root.current, this._root.current.firstElementChild, true));
        } else {
          return this.focusElement(getPreviousElement(this._root.current, this._root.current.lastElementChild, true, true, true));
        }
      }
      return changedFocus;
    };
    FocusZone2.prototype._moveFocusDown = function() {
      var _this = this;
      var targetTop = -1;
      var leftAlignment = this._focusAlignment.left || this._focusAlignment.x || 0;
      if (
        // eslint-disable-next-line deprecation/deprecation
        this._moveFocus(true, function(activeRect, targetRect) {
          var distance = -1;
          var targetRectTop = Math.floor(targetRect.top);
          var activeRectBottom = Math.floor(activeRect.bottom);
          if (targetRectTop < activeRectBottom) {
            if (!_this._shouldWrapFocus(_this._activeElement, NO_VERTICAL_WRAP)) {
              return LARGE_NEGATIVE_DISTANCE_FROM_CENTER;
            }
            return LARGE_DISTANCE_FROM_CENTER;
          }
          if (targetTop === -1 && targetRectTop >= activeRectBottom || targetRectTop === targetTop) {
            targetTop = targetRectTop;
            if (leftAlignment >= targetRect.left && leftAlignment <= targetRect.left + targetRect.width) {
              distance = 0;
            } else {
              distance = Math.abs(targetRect.left + targetRect.width / 2 - leftAlignment);
            }
          }
          return distance;
        })
      ) {
        this._setFocusAlignment(this._activeElement, false, true);
        return true;
      }
      return false;
    };
    FocusZone2.prototype._moveFocusUp = function() {
      var _this = this;
      var targetTop = -1;
      var leftAlignment = this._focusAlignment.left || this._focusAlignment.x || 0;
      if (
        // eslint-disable-next-line deprecation/deprecation
        this._moveFocus(false, function(activeRect, targetRect) {
          var distance = -1;
          var targetRectBottom = Math.floor(targetRect.bottom);
          var targetRectTop = Math.floor(targetRect.top);
          var activeRectTop = Math.floor(activeRect.top);
          if (targetRectBottom > activeRectTop) {
            if (!_this._shouldWrapFocus(_this._activeElement, NO_VERTICAL_WRAP)) {
              return LARGE_NEGATIVE_DISTANCE_FROM_CENTER;
            }
            return LARGE_DISTANCE_FROM_CENTER;
          }
          if (targetTop === -1 && targetRectBottom <= activeRectTop || targetRectTop === targetTop) {
            targetTop = targetRectTop;
            if (leftAlignment >= targetRect.left && leftAlignment <= targetRect.left + targetRect.width) {
              distance = 0;
            } else {
              distance = Math.abs(targetRect.left + targetRect.width / 2 - leftAlignment);
            }
          }
          return distance;
        })
      ) {
        this._setFocusAlignment(this._activeElement, false, true);
        return true;
      }
      return false;
    };
    FocusZone2.prototype._moveFocusLeft = function(theme) {
      var _this = this;
      var shouldWrap = this._shouldWrapFocus(this._activeElement, NO_HORIZONTAL_WRAP);
      if (this._moveFocus(
        getRTL2(theme),
        // eslint-disable-next-line deprecation/deprecation
        function(activeRect, targetRect) {
          var distance = -1;
          var topBottomComparison;
          if (getRTL2(theme)) {
            topBottomComparison = parseFloat(targetRect.top.toFixed(3)) < parseFloat(activeRect.bottom.toFixed(3));
          } else {
            topBottomComparison = parseFloat(targetRect.bottom.toFixed(3)) > parseFloat(activeRect.top.toFixed(3));
          }
          if (topBottomComparison && targetRect.right <= activeRect.right && _this.props.direction !== FocusZoneDirection.vertical) {
            distance = activeRect.right - targetRect.right;
          } else if (!shouldWrap) {
            distance = LARGE_NEGATIVE_DISTANCE_FROM_CENTER;
          }
          return distance;
        },
        void 0,
        shouldWrap
      )) {
        this._setFocusAlignment(this._activeElement, true, false);
        return true;
      }
      return false;
    };
    FocusZone2.prototype._moveFocusRight = function(theme) {
      var _this = this;
      var shouldWrap = this._shouldWrapFocus(this._activeElement, NO_HORIZONTAL_WRAP);
      if (this._moveFocus(
        !getRTL2(theme),
        // eslint-disable-next-line deprecation/deprecation
        function(activeRect, targetRect) {
          var distance = -1;
          var topBottomComparison;
          if (getRTL2(theme)) {
            topBottomComparison = parseFloat(targetRect.bottom.toFixed(3)) > parseFloat(activeRect.top.toFixed(3));
          } else {
            topBottomComparison = parseFloat(targetRect.top.toFixed(3)) < parseFloat(activeRect.bottom.toFixed(3));
          }
          if (topBottomComparison && targetRect.left >= activeRect.left && _this.props.direction !== FocusZoneDirection.vertical) {
            distance = targetRect.left - activeRect.left;
          } else if (!shouldWrap) {
            distance = LARGE_NEGATIVE_DISTANCE_FROM_CENTER;
          }
          return distance;
        },
        void 0,
        shouldWrap
      )) {
        this._setFocusAlignment(this._activeElement, true, false);
        return true;
      }
      return false;
    };
    FocusZone2.prototype._moveFocusPaging = function(isForward, useDefaultWrap) {
      if (useDefaultWrap === void 0) {
        useDefaultWrap = true;
      }
      var element = this._activeElement;
      if (!element || !this._root.current) {
        return false;
      }
      if (this._isElementInput(element)) {
        if (!this._shouldInputLoseFocus(element, isForward)) {
          return false;
        }
      }
      var scrollableParent = findScrollableParent(element);
      if (!scrollableParent) {
        return false;
      }
      var candidateDistance = -1;
      var candidateElement = void 0;
      var targetTop = -1;
      var targetBottom = -1;
      var pagesize = scrollableParent.clientHeight;
      var activeRect = element.getBoundingClientRect();
      do {
        element = isForward ? getNextElement(this._root.current, element) : getPreviousElement(this._root.current, element);
        if (element) {
          var targetRect = element.getBoundingClientRect();
          var targetRectTop = Math.floor(targetRect.top);
          var activeRectBottom = Math.floor(activeRect.bottom);
          var targetRectBottom = Math.floor(targetRect.bottom);
          var activeRectTop = Math.floor(activeRect.top);
          var elementDistance = this._getHorizontalDistanceFromCenter(isForward, activeRect, targetRect);
          var isElementPassedPageSizeOnPagingDown = isForward && targetRectTop > activeRectBottom + pagesize;
          var isElementPassedPageSizeOnPagingUp = !isForward && targetRectBottom < activeRectTop - pagesize;
          if (isElementPassedPageSizeOnPagingDown || isElementPassedPageSizeOnPagingUp) {
            break;
          }
          if (elementDistance > -1) {
            if (isForward && targetRectTop > targetTop) {
              targetTop = targetRectTop;
              candidateDistance = elementDistance;
              candidateElement = element;
            } else if (!isForward && targetRectBottom < targetBottom) {
              targetBottom = targetRectBottom;
              candidateDistance = elementDistance;
              candidateElement = element;
            } else if (candidateDistance === -1 || elementDistance <= candidateDistance) {
              candidateDistance = elementDistance;
              candidateElement = element;
            }
          }
        }
      } while (element);
      var changedFocus = false;
      if (candidateElement && candidateElement !== this._activeElement) {
        changedFocus = true;
        this.focusElement(candidateElement);
        this._setFocusAlignment(candidateElement, false, true);
      } else if (this.props.isCircularNavigation && useDefaultWrap) {
        if (isForward) {
          return this.focusElement(getNextElement(this._root.current, this._root.current.firstElementChild, true));
        }
        return this.focusElement(getPreviousElement(this._root.current, this._root.current.lastElementChild, true, true, true));
      }
      return changedFocus;
    };
    FocusZone2.prototype._setFocusAlignment = function(element, isHorizontal, isVertical) {
      if (this.props.direction === FocusZoneDirection.bidirectional && (!this._focusAlignment || isHorizontal || isVertical)) {
        var rect = element.getBoundingClientRect();
        var left = rect.left + rect.width / 2;
        var top_1 = rect.top + rect.height / 2;
        if (!this._focusAlignment) {
          this._focusAlignment = { left, top: top_1 };
        }
        if (isHorizontal) {
          this._focusAlignment.left = left;
        }
        if (isVertical) {
          this._focusAlignment.top = top_1;
        }
      }
    };
    FocusZone2.prototype._isImmediateDescendantOfZone = function(element) {
      return this._getOwnerZone(element) === this._root.current;
    };
    FocusZone2.prototype._getOwnerZone = function(element) {
      var parentElement = getParent(element, ALLOW_VIRTUAL_ELEMENTS);
      while (parentElement && parentElement !== this._root.current && parentElement !== this._getDocument().body) {
        if (isElementFocusZone(parentElement)) {
          return parentElement;
        }
        parentElement = getParent(parentElement, ALLOW_VIRTUAL_ELEMENTS);
      }
      return parentElement;
    };
    FocusZone2.prototype._updateTabIndexes = function(element) {
      if (!this._activeElement && this.props.defaultTabbableElement && typeof this.props.defaultTabbableElement === "function") {
        this._activeElement = this.props.defaultTabbableElement(this._root.current);
      }
      if (!element && this._root.current) {
        this._defaultFocusElement = null;
        element = this._root.current;
        if (this._activeElement && !elementContains(element, this._activeElement)) {
          this._activeElement = null;
        }
      }
      if (this._activeElement && !isElementTabbable(this._activeElement)) {
        this._activeElement = null;
      }
      var childNodes = element && element.children;
      for (var childIndex = 0; childNodes && childIndex < childNodes.length; childIndex++) {
        var child = childNodes[childIndex];
        if (!isElementFocusZone(child)) {
          if (child.getAttribute && child.getAttribute(IS_FOCUSABLE_ATTRIBUTE2) === "false") {
            child.setAttribute(TABINDEX, "-1");
          }
          if (isElementTabbable(child)) {
            if (this.props.disabled) {
              child.setAttribute(TABINDEX, "-1");
            } else if (!this._isInnerZone && (!this._activeElement && !this._defaultFocusElement || this._activeElement === child)) {
              this._defaultFocusElement = child;
              if (child.getAttribute(TABINDEX) !== "0") {
                child.setAttribute(TABINDEX, "0");
              }
            } else if (child.getAttribute(TABINDEX) !== "-1") {
              child.setAttribute(TABINDEX, "-1");
            }
          } else if (child.tagName === "svg" && child.getAttribute("focusable") !== "false") {
            child.setAttribute("focusable", "false");
          }
        } else if (child.getAttribute(IS_FOCUSABLE_ATTRIBUTE2) === "true") {
          if (!this._isInnerZone && (!this._activeElement && !this._defaultFocusElement || this._activeElement === child)) {
            this._defaultFocusElement = child;
            if (child.getAttribute(TABINDEX) !== "0") {
              child.setAttribute(TABINDEX, "0");
            }
          } else if (child.getAttribute(TABINDEX) !== "-1") {
            child.setAttribute(TABINDEX, "-1");
          }
        }
        this._updateTabIndexes(child);
      }
    };
    FocusZone2.prototype._isContentEditableElement = function(element) {
      return element && element.getAttribute("contenteditable") === "true";
    };
    FocusZone2.prototype._isElementInput = function(element) {
      if (element && element.tagName && (element.tagName.toLowerCase() === "input" || element.tagName.toLowerCase() === "textarea")) {
        return true;
      }
      return false;
    };
    FocusZone2.prototype._shouldInputLoseFocus = function(element, isForward) {
      if (!this._processingTabKey && element && element.type && ALLOWED_INPUT_TYPES.indexOf(element.type.toLowerCase()) > -1) {
        var selectionStart = element.selectionStart;
        var selectionEnd = element.selectionEnd;
        var isRangeSelected = selectionStart !== selectionEnd;
        var inputValue = element.value;
        var isReadonly = element.readOnly;
        if (isRangeSelected || selectionStart > 0 && !isForward && !isReadonly || selectionStart !== inputValue.length && isForward && !isReadonly || !!this.props.handleTabKey && !(this.props.shouldInputLoseFocusOnArrowKey && this.props.shouldInputLoseFocusOnArrowKey(element))) {
          return false;
        }
      }
      return true;
    };
    FocusZone2.prototype._shouldWrapFocus = function(element, noWrapDataAttribute) {
      return this.props.checkForNoWrap ? shouldWrapFocus(element, noWrapDataAttribute) : true;
    };
    FocusZone2.prototype._portalContainsElement = function(element) {
      return element && !!this._root.current && portalContainsElement(element, this._root.current);
    };
    FocusZone2.prototype._getDocument = function() {
      return getDocument(this._root.current);
    };
    FocusZone2.defaultProps = {
      isCircularNavigation: false,
      direction: FocusZoneDirection.bidirectional,
      shouldRaiseClicks: true,
      // Hardcoding uncontrolled flag for proper interop with FluentUI V9.
      "data-tabster": '{"uncontrolled": {}}'
    };
    return FocusZone2;
  }(React45.Component)
);

// node_modules/@fluentui/react/lib/utilities/contextualMenu/contextualMenuUtility.js
function getIsChecked(item) {
  if (item.canCheck) {
    return !!(item.isChecked || item.checked);
  }
  if (typeof item.isChecked === "boolean") {
    return item.isChecked;
  }
  if (typeof item.checked === "boolean") {
    return item.checked;
  }
  return null;
}
function hasSubmenu(item) {
  return !!(item.subMenuProps || item.items);
}
function isItemDisabled(item) {
  return !!(item.isDisabled || item.disabled);
}
function getMenuItemAriaRole(item) {
  var isChecked = getIsChecked(item);
  var canCheck = isChecked !== null;
  return canCheck ? "menuitemcheckbox" : "menuitem";
}

// node_modules/@fluentui/react/lib/components/ContextualMenu/ContextualMenuItem.base.js
var React46 = __toESM(require_react());
var defaultIconRenderer = function(props) {
  var item = props.item, classNames2 = props.classNames;
  var iconProps = item.iconProps;
  return React46.createElement(Icon, __assign({}, iconProps, { className: classNames2.icon }));
};
var renderItemIcon = function(props) {
  var item = props.item, hasIcons = props.hasIcons;
  if (!hasIcons) {
    return null;
  }
  if (item.onRenderIcon) {
    return item.onRenderIcon(props, defaultIconRenderer);
  }
  return defaultIconRenderer(props);
};
var renderCheckMarkIcon = function(_a7) {
  var onCheckmarkClick = _a7.onCheckmarkClick, item = _a7.item, classNames2 = _a7.classNames;
  var isItemChecked = getIsChecked(item);
  if (onCheckmarkClick) {
    var onClick = function(e) {
      return onCheckmarkClick(item, e);
    };
    return React46.createElement(Icon, {
      iconName: item.canCheck !== false && isItemChecked ? "CheckMark" : "",
      className: classNames2.checkmarkIcon,
      // eslint-disable-next-line react/jsx-no-bind
      onClick
    });
  }
  return null;
};
var renderItemName = function(_a7) {
  var item = _a7.item, classNames2 = _a7.classNames;
  if (item.text || item.name) {
    return React46.createElement("span", { className: classNames2.label }, item.text || item.name);
  }
  return null;
};
var renderSecondaryText = function(_a7) {
  var item = _a7.item, classNames2 = _a7.classNames;
  if (item.secondaryText) {
    return React46.createElement("span", { className: classNames2.secondaryText }, item.secondaryText);
  }
  return null;
};
var renderSubMenuIcon = function(_a7) {
  var item = _a7.item, classNames2 = _a7.classNames, theme = _a7.theme;
  if (hasSubmenu(item)) {
    return React46.createElement(Icon, __assign({ iconName: getRTL2(theme) ? "ChevronLeft" : "ChevronRight" }, item.submenuIconProps, { className: classNames2.subMenuIcon }));
  }
  return null;
};
var ContextualMenuItemBase = (
  /** @class */
  function(_super) {
    __extends(ContextualMenuItemBase2, _super);
    function ContextualMenuItemBase2(props) {
      var _this = _super.call(this, props) || this;
      _this.openSubMenu = function() {
        var _a7 = _this.props, item = _a7.item, openSubMenu = _a7.openSubMenu, getSubmenuTarget = _a7.getSubmenuTarget;
        if (getSubmenuTarget) {
          var submenuTarget = getSubmenuTarget();
          if (hasSubmenu(item) && openSubMenu && submenuTarget) {
            openSubMenu(item, submenuTarget);
          }
        }
      };
      _this.dismissSubMenu = function() {
        var _a7 = _this.props, item = _a7.item, dismissSubMenu = _a7.dismissSubMenu;
        if (hasSubmenu(item) && dismissSubMenu) {
          dismissSubMenu();
        }
      };
      _this.dismissMenu = function(dismissAll) {
        var dismissMenu = _this.props.dismissMenu;
        if (dismissMenu) {
          dismissMenu(void 0, dismissAll);
        }
      };
      initializeComponentRef(_this);
      return _this;
    }
    ContextualMenuItemBase2.prototype.render = function() {
      var _a7 = this.props, item = _a7.item, classNames2 = _a7.classNames;
      var renderContent = item.onRenderContent || this._renderLayout;
      return React46.createElement("div", { className: item.split ? classNames2.linkContentMenu : classNames2.linkContent }, renderContent(this.props, {
        renderCheckMarkIcon,
        renderItemIcon,
        renderItemName,
        renderSecondaryText,
        renderSubMenuIcon
      }));
    };
    ContextualMenuItemBase2.prototype._renderLayout = function(props, defaultRenders) {
      return React46.createElement(
        React46.Fragment,
        null,
        defaultRenders.renderCheckMarkIcon(props),
        defaultRenders.renderItemIcon(props),
        defaultRenders.renderItemName(props),
        defaultRenders.renderSecondaryText(props),
        defaultRenders.renderSubMenuIcon(props)
      );
    };
    return ContextualMenuItemBase2;
  }(React46.Component)
);

// node_modules/@fluentui/react/lib/components/Divider/VerticalDivider.classNames.js
var getDividerClassNames = memoizeFunction(
  // eslint-disable-next-line deprecation/deprecation
  function(theme) {
    return mergeStyleSets({
      wrapper: {
        display: "inline-flex",
        height: "100%",
        alignItems: "center"
      },
      divider: {
        width: 1,
        height: "100%",
        backgroundColor: theme.palette.neutralTertiaryAlt
      }
    });
  }
);

// node_modules/@fluentui/react/lib/components/ContextualMenu/ContextualMenu.cnstyles.js
var CONTEXTUAL_MENU_ITEM_HEIGHT = 36;
var MediumScreenSelector = getScreenSelector(0, ScreenWidthMaxMedium);
var getMenuItemStyles = memoizeFunction(function(theme) {
  var _a7, _b3, _c3, _d3, _e2;
  var semanticColors = theme.semanticColors, fonts = theme.fonts, palette = theme.palette;
  var ContextualMenuItemBackgroundHoverColor = semanticColors.menuItemBackgroundHovered;
  var ContextualMenuItemTextHoverColor = semanticColors.menuItemTextHovered;
  var ContextualMenuItemBackgroundSelectedColor = semanticColors.menuItemBackgroundPressed;
  var ContextualMenuItemDividerColor = semanticColors.bodyDivider;
  var menuItemStyles = {
    item: [
      fonts.medium,
      {
        color: semanticColors.bodyText,
        position: "relative",
        boxSizing: "border-box"
      }
    ],
    divider: {
      display: "block",
      height: "1px",
      backgroundColor: ContextualMenuItemDividerColor,
      position: "relative"
    },
    root: [
      getFocusStyle(theme),
      fonts.medium,
      {
        color: semanticColors.bodyText,
        backgroundColor: "transparent",
        border: "none",
        width: "100%",
        height: CONTEXTUAL_MENU_ITEM_HEIGHT,
        lineHeight: CONTEXTUAL_MENU_ITEM_HEIGHT,
        display: "block",
        cursor: "pointer",
        padding: "0px 8px 0 4px",
        textAlign: "left"
      }
    ],
    rootDisabled: {
      color: semanticColors.disabledBodyText,
      cursor: "default",
      pointerEvents: "none",
      selectors: (_a7 = {}, _a7[HighContrastSelector] = {
        // ensure disabled text looks different than enabled
        color: "GrayText",
        opacity: 1
      }, _a7)
    },
    rootHovered: {
      backgroundColor: ContextualMenuItemBackgroundHoverColor,
      color: ContextualMenuItemTextHoverColor,
      selectors: {
        ".ms-ContextualMenu-icon": {
          color: palette.themeDarkAlt
        },
        ".ms-ContextualMenu-submenuIcon": {
          color: palette.neutralPrimary
        }
      }
    },
    rootFocused: {
      backgroundColor: palette.white
    },
    rootChecked: {
      selectors: {
        ".ms-ContextualMenu-checkmarkIcon": {
          color: palette.neutralPrimary
        }
      }
    },
    rootPressed: {
      backgroundColor: ContextualMenuItemBackgroundSelectedColor,
      selectors: {
        ".ms-ContextualMenu-icon": {
          color: palette.themeDark
        },
        ".ms-ContextualMenu-submenuIcon": {
          color: palette.neutralPrimary
        }
      }
    },
    rootExpanded: {
      backgroundColor: ContextualMenuItemBackgroundSelectedColor,
      color: semanticColors.bodyTextChecked,
      selectors: (_b3 = {
        ".ms-ContextualMenu-submenuIcon": (_c3 = {}, _c3[HighContrastSelector] = {
          // icons inside of anchor tags are not properly inheriting color in high contrast
          color: "inherit"
        }, _c3)
      }, _b3[HighContrastSelector] = __assign({}, getHighContrastNoAdjustStyle()), _b3)
    },
    linkContent: {
      whiteSpace: "nowrap",
      height: "inherit",
      display: "flex",
      alignItems: "center",
      maxWidth: "100%"
    },
    anchorLink: {
      padding: "0px 8px 0 4px",
      textRendering: "auto",
      color: "inherit",
      letterSpacing: "normal",
      wordSpacing: "normal",
      textTransform: "none",
      textIndent: "0px",
      textShadow: "none",
      textDecoration: "none",
      boxSizing: "border-box"
    },
    label: {
      margin: "0 4px",
      verticalAlign: "middle",
      display: "inline-block",
      flexGrow: "1",
      textOverflow: "ellipsis",
      whiteSpace: "nowrap",
      overflow: "hidden"
    },
    secondaryText: {
      color: theme.palette.neutralSecondary,
      paddingLeft: "20px",
      textAlign: "right"
    },
    icon: {
      display: "inline-block",
      minHeight: "1px",
      maxHeight: CONTEXTUAL_MENU_ITEM_HEIGHT,
      fontSize: IconFontSizes.medium,
      width: IconFontSizes.medium,
      margin: "0 4px",
      verticalAlign: "middle",
      flexShrink: "0",
      selectors: (_d3 = {}, _d3[MediumScreenSelector] = {
        fontSize: IconFontSizes.large,
        width: IconFontSizes.large
      }, _d3)
    },
    iconColor: {
      color: semanticColors.menuIcon
    },
    iconDisabled: {
      color: semanticColors.disabledBodyText
    },
    checkmarkIcon: {
      color: semanticColors.bodySubtext
    },
    subMenuIcon: {
      height: CONTEXTUAL_MENU_ITEM_HEIGHT,
      lineHeight: CONTEXTUAL_MENU_ITEM_HEIGHT,
      color: palette.neutralSecondary,
      textAlign: "center",
      display: "inline-block",
      verticalAlign: "middle",
      flexShrink: "0",
      fontSize: IconFontSizes.small,
      selectors: (_e2 = {
        ":hover": {
          color: palette.neutralPrimary
        },
        ":active": {
          color: palette.neutralPrimary
        }
      }, _e2[MediumScreenSelector] = {
        fontSize: IconFontSizes.medium
        // 16px
      }, _e2)
    },
    splitButtonFlexContainer: [
      getFocusStyle(theme),
      {
        display: "flex",
        height: CONTEXTUAL_MENU_ITEM_HEIGHT,
        flexWrap: "nowrap",
        justifyContent: "center",
        alignItems: "flex-start"
      }
    ]
  };
  return concatStyleSets(menuItemStyles);
});

// node_modules/@fluentui/react/lib/components/ContextualMenu/ContextualMenu.classNames.js
var CONTEXTUAL_SPLIT_MENU_MINWIDTH = "28px";
var MediumScreenSelector2 = getScreenSelector(0, ScreenWidthMaxMedium);
var getSplitButtonVerticalDividerClassNames = memoizeFunction(
  /* eslint-disable deprecation/deprecation */
  function(theme) {
    var _a7;
    return mergeStyleSets(getDividerClassNames(theme), {
      /* eslint-enable deprecation/deprecation */
      wrapper: {
        position: "absolute",
        right: 28,
        selectors: (_a7 = {}, _a7[MediumScreenSelector2] = {
          right: 32
          // fontSize of the icon increased from 12px to 16px
        }, _a7)
      },
      divider: {
        height: 16,
        width: 1
      }
    });
  }
);
var GlobalClassNames5 = {
  item: "ms-ContextualMenu-item",
  divider: "ms-ContextualMenu-divider",
  root: "ms-ContextualMenu-link",
  isChecked: "is-checked",
  isExpanded: "is-expanded",
  isDisabled: "is-disabled",
  linkContent: "ms-ContextualMenu-linkContent",
  linkContentMenu: "ms-ContextualMenu-linkContent",
  icon: "ms-ContextualMenu-icon",
  iconColor: "ms-ContextualMenu-iconColor",
  checkmarkIcon: "ms-ContextualMenu-checkmarkIcon",
  subMenuIcon: "ms-ContextualMenu-submenuIcon",
  label: "ms-ContextualMenu-itemText",
  secondaryText: "ms-ContextualMenu-secondaryText",
  splitMenu: "ms-ContextualMenu-splitMenu",
  screenReaderText: "ms-ContextualMenu-screenReaderText"
};
var getItemClassNames = memoizeFunction(function(theme, disabled, expanded, checked, isAnchorLink, knownIcon, itemClassName, dividerClassName, iconClassName, subMenuClassName, primaryDisabled, className) {
  var _a7, _b3, _c3, _d3;
  var styles = getMenuItemStyles(theme);
  var classNames2 = getGlobalClassNames(GlobalClassNames5, theme);
  return mergeStyleSets({
    item: [classNames2.item, styles.item, itemClassName],
    divider: [classNames2.divider, styles.divider, dividerClassName],
    root: [
      classNames2.root,
      styles.root,
      checked && [classNames2.isChecked, styles.rootChecked],
      isAnchorLink && styles.anchorLink,
      expanded && [classNames2.isExpanded, styles.rootExpanded],
      disabled && [classNames2.isDisabled, styles.rootDisabled],
      !disabled && !expanded && [
        {
          selectors: (_a7 = {
            ":hover": styles.rootHovered,
            ":active": styles.rootPressed
          }, _a7[".".concat(IsFocusVisibleClassName, " &:focus, .").concat(IsFocusVisibleClassName, " &:focus:hover")] = styles.rootFocused, _a7[".".concat(IsFocusVisibleClassName, " &:hover")] = { background: "inherit;" }, _a7)
        }
      ],
      className
    ],
    splitPrimary: [
      styles.root,
      {
        width: "calc(100% - ".concat(CONTEXTUAL_SPLIT_MENU_MINWIDTH, ")")
      },
      checked && ["is-checked", styles.rootChecked],
      (disabled || primaryDisabled) && ["is-disabled", styles.rootDisabled],
      !(disabled || primaryDisabled) && !checked && [
        {
          selectors: (_b3 = {
            ":hover": styles.rootHovered
          }, // when hovering over the splitPrimary also affect the splitMenu
          _b3[":hover ~ .".concat(classNames2.splitMenu)] = styles.rootHovered, _b3[":active"] = styles.rootPressed, _b3[".".concat(IsFocusVisibleClassName, " &:focus, .").concat(IsFocusVisibleClassName, " &:focus:hover")] = styles.rootFocused, _b3[".".concat(IsFocusVisibleClassName, " &:hover")] = { background: "inherit;" }, _b3)
        }
      ]
    ],
    splitMenu: [
      classNames2.splitMenu,
      styles.root,
      {
        flexBasis: "0",
        padding: "0 8px",
        minWidth: CONTEXTUAL_SPLIT_MENU_MINWIDTH
      },
      expanded && ["is-expanded", styles.rootExpanded],
      disabled && ["is-disabled", styles.rootDisabled],
      !disabled && !expanded && [
        {
          selectors: (_c3 = {
            ":hover": styles.rootHovered,
            ":active": styles.rootPressed
          }, _c3[".".concat(IsFocusVisibleClassName, " &:focus, .").concat(IsFocusVisibleClassName, " &:focus:hover")] = styles.rootFocused, _c3[".".concat(IsFocusVisibleClassName, " &:hover")] = { background: "inherit;" }, _c3)
        }
      ]
    ],
    anchorLink: styles.anchorLink,
    linkContent: [classNames2.linkContent, styles.linkContent],
    linkContentMenu: [
      classNames2.linkContentMenu,
      styles.linkContent,
      {
        justifyContent: "center"
      }
    ],
    icon: [
      classNames2.icon,
      knownIcon && styles.iconColor,
      styles.icon,
      iconClassName,
      disabled && [classNames2.isDisabled, styles.iconDisabled]
    ],
    iconColor: styles.iconColor,
    checkmarkIcon: [classNames2.checkmarkIcon, knownIcon && styles.checkmarkIcon, styles.icon, iconClassName],
    subMenuIcon: [
      classNames2.subMenuIcon,
      styles.subMenuIcon,
      subMenuClassName,
      expanded && { color: theme.palette.neutralPrimary },
      disabled && [styles.iconDisabled]
    ],
    label: [classNames2.label, styles.label],
    secondaryText: [classNames2.secondaryText, styles.secondaryText],
    splitContainer: [
      styles.splitButtonFlexContainer,
      !disabled && !checked && [
        {
          selectors: (_d3 = {}, _d3[".".concat(IsFocusVisibleClassName, " &:focus, .").concat(IsFocusVisibleClassName, " &:focus:hover")] = styles.rootFocused, _d3)
        }
      ]
    ],
    screenReaderText: [
      classNames2.screenReaderText,
      styles.screenReaderText,
      hiddenContentStyle,
      { visibility: "hidden" }
    ]
  });
});
var getItemStyles = function(props) {
  var theme = props.theme, disabled = props.disabled, expanded = props.expanded, checked = props.checked, isAnchorLink = props.isAnchorLink, knownIcon = props.knownIcon, itemClassName = props.itemClassName, dividerClassName = props.dividerClassName, iconClassName = props.iconClassName, subMenuClassName = props.subMenuClassName, primaryDisabled = props.primaryDisabled, className = props.className;
  return getItemClassNames(theme, disabled, expanded, checked, isAnchorLink, knownIcon, itemClassName, dividerClassName, iconClassName, subMenuClassName, primaryDisabled, className);
};

// node_modules/@fluentui/react/lib/components/ContextualMenu/ContextualMenuItem.js
var ContextualMenuItem = styled(ContextualMenuItemBase, getItemStyles, void 0, { scope: "ContextualMenuItem" });

// node_modules/@fluentui/react/lib/components/ContextualMenu/ContextualMenuItemWrapper/ContextualMenuAnchor.js
var React50 = __toESM(require_react());

// node_modules/@fluentui/react/lib/components/ContextualMenu/ContextualMenuItemWrapper/ContextualMenuItemWrapper.js
var React47 = __toESM(require_react());
var ContextualMenuItemWrapper = (
  /** @class */
  function(_super) {
    __extends(ContextualMenuItemWrapper2, _super);
    function ContextualMenuItemWrapper2(props) {
      var _this = _super.call(this, props) || this;
      _this._onItemMouseEnter = function(ev) {
        var _a7 = _this.props, item = _a7.item, onItemMouseEnter = _a7.onItemMouseEnter;
        if (onItemMouseEnter) {
          onItemMouseEnter(item, ev, ev.currentTarget);
        }
      };
      _this._onItemClick = function(ev) {
        var _a7 = _this.props, item = _a7.item, onItemClickBase = _a7.onItemClickBase;
        if (onItemClickBase) {
          onItemClickBase(item, ev, ev.currentTarget);
        }
      };
      _this._onItemMouseLeave = function(ev) {
        var _a7 = _this.props, item = _a7.item, onItemMouseLeave = _a7.onItemMouseLeave;
        if (onItemMouseLeave) {
          onItemMouseLeave(item, ev);
        }
      };
      _this._onItemKeyDown = function(ev) {
        var _a7 = _this.props, item = _a7.item, onItemKeyDown = _a7.onItemKeyDown;
        if (onItemKeyDown) {
          onItemKeyDown(item, ev);
        }
      };
      _this._onItemMouseMove = function(ev) {
        var _a7 = _this.props, item = _a7.item, onItemMouseMove = _a7.onItemMouseMove;
        if (onItemMouseMove) {
          onItemMouseMove(item, ev, ev.currentTarget);
        }
      };
      _this._getSubmenuTarget = function() {
        return void 0;
      };
      initializeComponentRef(_this);
      return _this;
    }
    ContextualMenuItemWrapper2.prototype.shouldComponentUpdate = function(newProps) {
      return !shallowCompare(newProps, this.props);
    };
    return ContextualMenuItemWrapper2;
  }(React47.Component)
);

// node_modules/@fluentui/react/lib/utilities/keytips/KeytipConstants.js
var KTP_PREFIX = "ktp";
var KTP_SEPARATOR = "-";
var KTP_FULL_PREFIX = KTP_PREFIX + KTP_SEPARATOR;
var DATAKTP_TARGET = "data-ktp-target";
var DATAKTP_EXECUTE_TARGET = "data-ktp-execute-target";
var KTP_LAYER_ID = "ktp-layer-id";
var KeytipEvents;
(function(KeytipEvents2) {
  KeytipEvents2.KEYTIP_ADDED = "keytipAdded";
  KeytipEvents2.KEYTIP_REMOVED = "keytipRemoved";
  KeytipEvents2.KEYTIP_UPDATED = "keytipUpdated";
  KeytipEvents2.PERSISTED_KEYTIP_ADDED = "persistedKeytipAdded";
  KeytipEvents2.PERSISTED_KEYTIP_REMOVED = "persistedKeytipRemoved";
  KeytipEvents2.PERSISTED_KEYTIP_EXECUTE = "persistedKeytipExecute";
  KeytipEvents2.ENTER_KEYTIP_MODE = "enterKeytipMode";
  KeytipEvents2.EXIT_KEYTIP_MODE = "exitKeytipMode";
})(KeytipEvents || (KeytipEvents = {}));

// node_modules/@fluentui/react/lib/utilities/keytips/KeytipManager.js
var KeytipManager = (
  /** @class */
  function() {
    function KeytipManager2() {
      this.keytips = {};
      this.persistedKeytips = {};
      this.sequenceMapping = {};
      this.inKeytipMode = false;
      this.shouldEnterKeytipMode = true;
      this.delayUpdatingKeytipChange = false;
    }
    KeytipManager2.getInstance = function() {
      return this._instance;
    };
    KeytipManager2.prototype.init = function(delayUpdatingKeytipChange) {
      this.delayUpdatingKeytipChange = delayUpdatingKeytipChange;
    };
    KeytipManager2.prototype.register = function(keytipProps, persisted) {
      if (persisted === void 0) {
        persisted = false;
      }
      var props = keytipProps;
      if (!persisted) {
        props = this.addParentOverflow(keytipProps);
        this.sequenceMapping[props.keySequences.toString()] = props;
      }
      var uniqueKeytip = this._getUniqueKtp(props);
      persisted ? this.persistedKeytips[uniqueKeytip.uniqueID] = uniqueKeytip : this.keytips[uniqueKeytip.uniqueID] = uniqueKeytip;
      if (this.inKeytipMode || !this.delayUpdatingKeytipChange) {
        var event_1 = persisted ? KeytipEvents.PERSISTED_KEYTIP_ADDED : KeytipEvents.KEYTIP_ADDED;
        EventGroup.raise(this, event_1, {
          keytip: props,
          uniqueID: uniqueKeytip.uniqueID
        });
      }
      return uniqueKeytip.uniqueID;
    };
    KeytipManager2.prototype.update = function(keytipProps, uniqueID) {
      var newKeytipProps = this.addParentOverflow(keytipProps);
      var uniqueKeytip = this._getUniqueKtp(newKeytipProps, uniqueID);
      var oldKeyTip = this.keytips[uniqueID];
      if (oldKeyTip) {
        uniqueKeytip.keytip.visible = oldKeyTip.keytip.visible;
        this.keytips[uniqueID] = uniqueKeytip;
        delete this.sequenceMapping[oldKeyTip.keytip.keySequences.toString()];
        this.sequenceMapping[uniqueKeytip.keytip.keySequences.toString()] = uniqueKeytip.keytip;
        if (this.inKeytipMode || !this.delayUpdatingKeytipChange) {
          EventGroup.raise(this, KeytipEvents.KEYTIP_UPDATED, {
            keytip: uniqueKeytip.keytip,
            uniqueID: uniqueKeytip.uniqueID
          });
        }
      }
    };
    KeytipManager2.prototype.unregister = function(keytipToRemove, uniqueID, persisted) {
      if (persisted === void 0) {
        persisted = false;
      }
      persisted ? delete this.persistedKeytips[uniqueID] : delete this.keytips[uniqueID];
      !persisted && delete this.sequenceMapping[keytipToRemove.keySequences.toString()];
      var event = persisted ? KeytipEvents.PERSISTED_KEYTIP_REMOVED : KeytipEvents.KEYTIP_REMOVED;
      if (this.inKeytipMode || !this.delayUpdatingKeytipChange) {
        EventGroup.raise(this, event, {
          keytip: keytipToRemove,
          uniqueID
        });
      }
    };
    KeytipManager2.prototype.enterKeytipMode = function() {
      EventGroup.raise(this, KeytipEvents.ENTER_KEYTIP_MODE);
    };
    KeytipManager2.prototype.exitKeytipMode = function() {
      EventGroup.raise(this, KeytipEvents.EXIT_KEYTIP_MODE);
    };
    KeytipManager2.prototype.getKeytips = function() {
      var _this = this;
      return Object.keys(this.keytips).map(function(key) {
        return _this.keytips[key].keytip;
      });
    };
    KeytipManager2.prototype.addParentOverflow = function(keytipProps) {
      var fullSequence = __spreadArray([], keytipProps.keySequences, true);
      fullSequence.pop();
      if (fullSequence.length !== 0) {
        var parentKeytip = this.sequenceMapping[fullSequence.toString()];
        if (parentKeytip && parentKeytip.overflowSetSequence) {
          return __assign(__assign({}, keytipProps), { overflowSetSequence: parentKeytip.overflowSetSequence });
        }
      }
      return keytipProps;
    };
    KeytipManager2.prototype.menuExecute = function(overflowButtonSequences, keytipSequences) {
      EventGroup.raise(this, KeytipEvents.PERSISTED_KEYTIP_EXECUTE, {
        overflowButtonSequences,
        keytipSequences
      });
    };
    KeytipManager2.prototype._getUniqueKtp = function(keytipProps, uniqueID) {
      if (uniqueID === void 0) {
        uniqueID = getId();
      }
      return { keytip: __assign({}, keytipProps), uniqueID };
    };
    KeytipManager2._instance = new KeytipManager2();
    return KeytipManager2;
  }()
);

// node_modules/@fluentui/react/lib/utilities/keytips/KeytipUtils.js
function sequencesToID(keySequences) {
  return keySequences.reduce(function(prevValue, keySequence) {
    return prevValue + KTP_SEPARATOR + keySequence.split("").join(KTP_SEPARATOR);
  }, KTP_PREFIX);
}
function mergeOverflows(keySequences, overflowKeySequences) {
  var overflowSequenceLen = overflowKeySequences.length;
  var overflowSequence = __spreadArray([], overflowKeySequences, true).pop();
  var newKeySequences = __spreadArray([], keySequences, true);
  return addElementAtIndex(newKeySequences, overflowSequenceLen - 1, overflowSequence);
}
function getAriaDescribedBy(keySequences) {
  var describedby = " " + KTP_LAYER_ID;
  if (!keySequences.length) {
    return describedby;
  }
  return describedby + " " + sequencesToID(keySequences);
}

// node_modules/@fluentui/react/lib/components/KeytipData/useKeytipData.js
var React48 = __toESM(require_react());
function useKeytipData(options) {
  var uniqueId = React48.useRef();
  var keytipProps = options.keytipProps ? __assign({ disabled: options.disabled }, options.keytipProps) : void 0;
  var keytipManager = useConst(KeytipManager.getInstance());
  var prevOptions = usePrevious(options);
  useIsomorphicLayoutEffect(function() {
    if (uniqueId.current && keytipProps && ((prevOptions === null || prevOptions === void 0 ? void 0 : prevOptions.keytipProps) !== options.keytipProps || (prevOptions === null || prevOptions === void 0 ? void 0 : prevOptions.disabled) !== options.disabled)) {
      keytipManager.update(keytipProps, uniqueId.current);
    }
  });
  useIsomorphicLayoutEffect(function() {
    if (keytipProps) {
      uniqueId.current = keytipManager.register(keytipProps);
    }
    return function() {
      keytipProps && keytipManager.unregister(keytipProps, uniqueId.current);
    };
  }, []);
  var nativeKeytipProps = {
    ariaDescribedBy: void 0,
    keytipId: void 0
  };
  if (keytipProps) {
    nativeKeytipProps = getKeytipData(keytipManager, keytipProps, options.ariaDescribedBy);
  }
  return nativeKeytipProps;
}
function getKeytipData(keytipManager, keytipProps, describedByPrepend) {
  var newKeytipProps = keytipManager.addParentOverflow(keytipProps);
  var ariaDescribedBy = mergeAriaAttributeValues(describedByPrepend, getAriaDescribedBy(newKeytipProps.keySequences));
  var keySequences = __spreadArray([], newKeytipProps.keySequences, true);
  if (newKeytipProps.overflowSetSequence) {
    keySequences = mergeOverflows(keySequences, newKeytipProps.overflowSetSequence);
  }
  var keytipId = sequencesToID(keySequences);
  return {
    ariaDescribedBy,
    keytipId
  };
}

// node_modules/@fluentui/react/lib/components/KeytipData/KeytipData.js
var KeytipData = function(props) {
  var _a7;
  var children = props.children, keytipDataProps = __rest(props, ["children"]);
  var _b3 = useKeytipData(keytipDataProps), keytipId = _b3.keytipId, ariaDescribedBy = _b3.ariaDescribedBy;
  return children((_a7 = {}, _a7[DATAKTP_TARGET] = keytipId, _a7[DATAKTP_EXECUTE_TARGET] = keytipId, _a7["aria-describedby"] = ariaDescribedBy, _a7));
};

// node_modules/@fluentui/react/lib/components/KeytipData/useKeytipRef.js
var React49 = __toESM(require_react());

// node_modules/@fluentui/react/lib/components/ContextualMenu/ContextualMenuItemWrapper/ContextualMenuAnchor.js
var ContextualMenuAnchor = (
  /** @class */
  function(_super) {
    __extends(ContextualMenuAnchor2, _super);
    function ContextualMenuAnchor2() {
      var _this = _super !== null && _super.apply(this, arguments) || this;
      _this._anchor = React50.createRef();
      _this._getMemoizedMenuButtonKeytipProps = memoizeFunction(function(keytipProps) {
        return __assign(__assign({}, keytipProps), { hasMenu: true });
      });
      _this._getSubmenuTarget = function() {
        return _this._anchor.current ? _this._anchor.current : void 0;
      };
      _this._onItemClick = function(ev) {
        var _a7 = _this.props, item = _a7.item, onItemClick = _a7.onItemClick;
        if (onItemClick) {
          onItemClick(item, ev);
        }
      };
      _this._renderAriaDescription = function(ariaDescription, className) {
        return ariaDescription ? React50.createElement("span", { id: _this._ariaDescriptionId, className }, ariaDescription) : null;
      };
      return _this;
    }
    ContextualMenuAnchor2.prototype.render = function() {
      var _this = this;
      var _a7 = this.props, item = _a7.item, classNames2 = _a7.classNames, index = _a7.index, focusableElementIndex = _a7.focusableElementIndex, totalItemCount = _a7.totalItemCount, hasCheckmarks = _a7.hasCheckmarks, hasIcons = _a7.hasIcons, expandedMenuItemKey = _a7.expandedMenuItemKey, onItemClick = _a7.onItemClick, openSubMenu = _a7.openSubMenu, dismissSubMenu = _a7.dismissSubMenu, dismissMenu = _a7.dismissMenu;
      var ChildrenRenderer = ContextualMenuItem;
      if (this.props.item.contextualMenuItemAs) {
        ChildrenRenderer = composeComponentAs(this.props.item.contextualMenuItemAs, ChildrenRenderer);
      }
      if (this.props.contextualMenuItemAs) {
        ChildrenRenderer = composeComponentAs(this.props.contextualMenuItemAs, ChildrenRenderer);
      }
      var anchorRel = item.rel;
      if (item.target && item.target.toLowerCase() === "_blank") {
        anchorRel = anchorRel ? anchorRel : "nofollow noopener noreferrer";
      }
      var itemHasSubmenu = hasSubmenu(item);
      var nativeProps = getNativeProps(item, anchorProperties);
      var disabled = isItemDisabled(item);
      var itemProps = item.itemProps, ariaDescription = item.ariaDescription;
      var keytipProps = item.keytipProps;
      if (keytipProps && itemHasSubmenu) {
        keytipProps = this._getMemoizedMenuButtonKeytipProps(keytipProps);
      }
      if (ariaDescription) {
        this._ariaDescriptionId = getId();
      }
      var ariaDescribedByIds = mergeAriaAttributeValues(item.ariaDescribedBy, ariaDescription ? this._ariaDescriptionId : void 0, nativeProps["aria-describedby"]);
      var additionalItemProperties = {
        "aria-describedby": ariaDescribedByIds
      };
      return React50.createElement(
        "div",
        null,
        React50.createElement(KeytipData, { keytipProps: item.keytipProps, ariaDescribedBy: ariaDescribedByIds, disabled }, function(keytipAttributes) {
          return React50.createElement(
            "a",
            __assign({}, additionalItemProperties, nativeProps, keytipAttributes, {
              ref: _this._anchor,
              href: item.href,
              target: item.target,
              rel: anchorRel,
              className: classNames2.root,
              role: "menuitem",
              "aria-haspopup": itemHasSubmenu || void 0,
              "aria-expanded": itemHasSubmenu ? item.key === expandedMenuItemKey : void 0,
              "aria-posinset": focusableElementIndex + 1,
              "aria-setsize": totalItemCount,
              "aria-disabled": isItemDisabled(item),
              // eslint-disable-next-line deprecation/deprecation
              style: item.style,
              onClick: _this._onItemClick,
              onMouseEnter: _this._onItemMouseEnter,
              onMouseLeave: _this._onItemMouseLeave,
              onMouseMove: _this._onItemMouseMove,
              onKeyDown: itemHasSubmenu ? _this._onItemKeyDown : void 0
            }),
            React50.createElement(ChildrenRenderer, __assign({ componentRef: item.componentRef, item, classNames: classNames2, index, onCheckmarkClick: hasCheckmarks && onItemClick ? onItemClick : void 0, hasIcons, openSubMenu, dismissSubMenu, dismissMenu, getSubmenuTarget: _this._getSubmenuTarget }, itemProps)),
            _this._renderAriaDescription(ariaDescription, classNames2.screenReaderText)
          );
        })
      );
    };
    return ContextualMenuAnchor2;
  }(ContextualMenuItemWrapper)
);

// node_modules/@fluentui/react/lib/components/ContextualMenu/ContextualMenuItemWrapper/ContextualMenuButton.js
var React51 = __toESM(require_react());
var ContextualMenuButton = (
  /** @class */
  function(_super) {
    __extends(ContextualMenuButton2, _super);
    function ContextualMenuButton2() {
      var _this = _super !== null && _super.apply(this, arguments) || this;
      _this._btn = React51.createRef();
      _this._getMemoizedMenuButtonKeytipProps = memoizeFunction(function(keytipProps) {
        return __assign(__assign({}, keytipProps), { hasMenu: true });
      });
      _this._renderAriaDescription = function(ariaDescription, className) {
        return ariaDescription ? React51.createElement("span", { id: _this._ariaDescriptionId, className }, ariaDescription) : null;
      };
      _this._getSubmenuTarget = function() {
        return _this._btn.current ? _this._btn.current : void 0;
      };
      return _this;
    }
    ContextualMenuButton2.prototype.render = function() {
      var _this = this;
      var _a7 = this.props, item = _a7.item, classNames2 = _a7.classNames, index = _a7.index, focusableElementIndex = _a7.focusableElementIndex, totalItemCount = _a7.totalItemCount, hasCheckmarks = _a7.hasCheckmarks, hasIcons = _a7.hasIcons, contextualMenuItemAs = _a7.contextualMenuItemAs, expandedMenuItemKey = _a7.expandedMenuItemKey, onItemMouseDown2 = _a7.onItemMouseDown, onItemClick = _a7.onItemClick, openSubMenu = _a7.openSubMenu, dismissSubMenu = _a7.dismissSubMenu, dismissMenu = _a7.dismissMenu;
      var ChildrenRenderer = ContextualMenuItem;
      if (item.contextualMenuItemAs) {
        ChildrenRenderer = composeComponentAs(item.contextualMenuItemAs, ChildrenRenderer);
      }
      if (contextualMenuItemAs) {
        ChildrenRenderer = composeComponentAs(contextualMenuItemAs, ChildrenRenderer);
      }
      var isChecked = getIsChecked(item);
      var canCheck = isChecked !== null;
      var defaultRole = getMenuItemAriaRole(item);
      var itemHasSubmenu = hasSubmenu(item);
      var itemProps = item.itemProps, ariaLabel = item.ariaLabel, ariaDescription = item.ariaDescription;
      var buttonNativeProperties = getNativeProps(item, buttonProperties);
      delete buttonNativeProperties.disabled;
      var itemRole = item.role || defaultRole;
      if (ariaDescription) {
        this._ariaDescriptionId = getId();
      }
      var ariaDescribedByIds = mergeAriaAttributeValues(item.ariaDescribedBy, ariaDescription ? this._ariaDescriptionId : void 0, buttonNativeProperties["aria-describedby"]);
      var itemButtonProperties = {
        className: classNames2.root,
        onClick: this._onItemClick,
        onKeyDown: itemHasSubmenu ? this._onItemKeyDown : void 0,
        onMouseEnter: this._onItemMouseEnter,
        onMouseLeave: this._onItemMouseLeave,
        onMouseDown: function(ev) {
          return onItemMouseDown2 ? onItemMouseDown2(item, ev) : void 0;
        },
        onMouseMove: this._onItemMouseMove,
        href: item.href,
        title: item.title,
        "aria-label": ariaLabel,
        "aria-describedby": ariaDescribedByIds,
        "aria-haspopup": itemHasSubmenu || void 0,
        "aria-expanded": itemHasSubmenu ? item.key === expandedMenuItemKey : void 0,
        "aria-posinset": focusableElementIndex + 1,
        "aria-setsize": totalItemCount,
        "aria-disabled": isItemDisabled(item),
        "aria-checked": (itemRole === "menuitemcheckbox" || itemRole === "menuitemradio") && canCheck ? !!isChecked : void 0,
        "aria-selected": itemRole === "menuitem" && canCheck ? !!isChecked : void 0,
        role: itemRole,
        // eslint-disable-next-line deprecation/deprecation
        style: item.style
      };
      var keytipProps = item.keytipProps;
      if (keytipProps && itemHasSubmenu) {
        keytipProps = this._getMemoizedMenuButtonKeytipProps(keytipProps);
      }
      return React51.createElement(KeytipData, { keytipProps, ariaDescribedBy: ariaDescribedByIds, disabled: isItemDisabled(item) }, function(keytipAttributes) {
        return React51.createElement(
          "button",
          __assign({ ref: _this._btn }, buttonNativeProperties, itemButtonProperties, keytipAttributes),
          React51.createElement(ChildrenRenderer, __assign({ componentRef: item.componentRef, item, classNames: classNames2, index, onCheckmarkClick: hasCheckmarks && onItemClick ? onItemClick : void 0, hasIcons, openSubMenu, dismissSubMenu, dismissMenu, getSubmenuTarget: _this._getSubmenuTarget }, itemProps)),
          _this._renderAriaDescription(ariaDescription, classNames2.screenReaderText)
        );
      });
    };
    return ContextualMenuButton2;
  }(ContextualMenuItemWrapper)
);

// node_modules/@fluentui/react/lib/components/ContextualMenu/ContextualMenuItemWrapper/ContextualMenuSplitButton.js
var React53 = __toESM(require_react());

// node_modules/@fluentui/react/lib/components/Divider/VerticalDivider.styles.js
var getStyles6 = function(props) {
  var theme = props.theme, getClassNames13 = props.getClassNames, className = props.className;
  if (!theme) {
    throw new Error("Theme is undefined or null.");
  }
  if (getClassNames13) {
    var names = getClassNames13(theme);
    return {
      wrapper: [names.wrapper],
      divider: [names.divider]
    };
  }
  return {
    wrapper: [
      {
        display: "inline-flex",
        height: "100%",
        alignItems: "center"
      },
      className
    ],
    divider: [
      {
        width: 1,
        height: "100%",
        backgroundColor: theme.palette.neutralTertiaryAlt
      }
    ]
  };
};

// node_modules/@fluentui/react/lib/components/Divider/VerticalDivider.base.js
var React52 = __toESM(require_react());
var getClassNames6 = classNamesFunction();
var VerticalDividerBase = React52.forwardRef(function(props, ref) {
  var styles = props.styles, theme = props.theme, deprecatedGetClassNames = props.getClassNames, className = props.className;
  var classNames2 = getClassNames6(styles, { theme, getClassNames: deprecatedGetClassNames, className });
  return React52.createElement(
    "span",
    { className: classNames2.wrapper, ref },
    React52.createElement("span", { className: classNames2.divider })
  );
});
VerticalDividerBase.displayName = "VerticalDividerBase";

// node_modules/@fluentui/react/lib/components/Divider/VerticalDivider.js
var VerticalDivider = styled(VerticalDividerBase, getStyles6, void 0, {
  scope: "VerticalDivider"
});

// node_modules/@fluentui/react/lib/components/ContextualMenu/ContextualMenuItemWrapper/ContextualMenuSplitButton.js
var TouchIdleDelay = 500;
var ContextualMenuSplitButton = (
  /** @class */
  function(_super) {
    __extends(ContextualMenuSplitButton2, _super);
    function ContextualMenuSplitButton2(props) {
      var _this = _super.call(this, props) || this;
      _this._getMemoizedMenuButtonKeytipProps = memoizeFunction(function(keytipProps) {
        return __assign(__assign({}, keytipProps), { hasMenu: true });
      });
      _this._onItemKeyDown = function(ev) {
        var _a7 = _this.props, item = _a7.item, onItemKeyDown = _a7.onItemKeyDown;
        if (ev.which === KeyCodes.enter) {
          _this._executeItemClick(ev);
          ev.preventDefault();
          ev.stopPropagation();
        } else if (onItemKeyDown) {
          onItemKeyDown(item, ev);
        }
      };
      _this._getSubmenuTarget = function() {
        return _this._splitButton;
      };
      _this._renderAriaDescription = function(ariaDescription, className) {
        return ariaDescription ? React53.createElement("span", { id: _this._ariaDescriptionId, className }, ariaDescription) : null;
      };
      _this._onItemMouseEnterPrimary = function(ev) {
        var _a7 = _this.props, item = _a7.item, onItemMouseEnter = _a7.onItemMouseEnter;
        if (onItemMouseEnter) {
          onItemMouseEnter(__assign(__assign({}, item), { subMenuProps: void 0, items: void 0 }), ev, _this._splitButton);
        }
      };
      _this._onItemMouseEnterIcon = function(ev) {
        var _a7 = _this.props, item = _a7.item, onItemMouseEnter = _a7.onItemMouseEnter;
        if (onItemMouseEnter) {
          onItemMouseEnter(item, ev, _this._splitButton);
        }
      };
      _this._onItemMouseMovePrimary = function(ev) {
        var _a7 = _this.props, item = _a7.item, onItemMouseMove = _a7.onItemMouseMove;
        if (onItemMouseMove) {
          onItemMouseMove(__assign(__assign({}, item), { subMenuProps: void 0, items: void 0 }), ev, _this._splitButton);
        }
      };
      _this._onItemMouseMoveIcon = function(ev) {
        var _a7 = _this.props, item = _a7.item, onItemMouseMove = _a7.onItemMouseMove;
        if (onItemMouseMove) {
          onItemMouseMove(item, ev, _this._splitButton);
        }
      };
      _this._onIconItemClick = function(ev) {
        var _a7 = _this.props, item = _a7.item, onItemClickBase = _a7.onItemClickBase;
        if (onItemClickBase) {
          onItemClickBase(item, ev, _this._splitButton ? _this._splitButton : ev.currentTarget);
        }
      };
      _this._executeItemClick = function(ev) {
        var _a7 = _this.props, item = _a7.item, executeItemClick = _a7.executeItemClick, onItemClick = _a7.onItemClick;
        if (item.disabled || item.isDisabled) {
          return;
        }
        if (_this._processingTouch && !item.canCheck && onItemClick) {
          return onItemClick(item, ev);
        }
        if (executeItemClick) {
          executeItemClick(item, ev);
        }
      };
      _this._onTouchStart = function(ev) {
        if (_this._splitButton && !("onpointerdown" in _this._splitButton)) {
          _this._handleTouchAndPointerEvent(ev);
        }
      };
      _this._onPointerDown = function(ev) {
        if (ev.pointerType === "touch") {
          _this._handleTouchAndPointerEvent(ev);
          ev.preventDefault();
          ev.stopImmediatePropagation();
        }
      };
      _this._async = new Async(_this);
      _this._events = new EventGroup(_this);
      _this._dismissLabelId = getId();
      return _this;
    }
    ContextualMenuSplitButton2.prototype.componentDidMount = function() {
      if (this._splitButton && "onpointerdown" in this._splitButton) {
        this._events.on(this._splitButton, "pointerdown", this._onPointerDown, true);
      }
    };
    ContextualMenuSplitButton2.prototype.componentWillUnmount = function() {
      this._async.dispose();
      this._events.dispose();
    };
    ContextualMenuSplitButton2.prototype.render = function() {
      var _this = this;
      var _a7;
      var _b3 = this.props, item = _b3.item, classNames2 = _b3.classNames, index = _b3.index, focusableElementIndex = _b3.focusableElementIndex, totalItemCount = _b3.totalItemCount, hasCheckmarks = _b3.hasCheckmarks, hasIcons = _b3.hasIcons, onItemMouseLeave = _b3.onItemMouseLeave, expandedMenuItemKey = _b3.expandedMenuItemKey;
      var itemHasSubmenu = hasSubmenu(item);
      var keytipProps = item.keytipProps;
      if (keytipProps) {
        keytipProps = this._getMemoizedMenuButtonKeytipProps(keytipProps);
      }
      var ariaDescription = item.ariaDescription;
      if (ariaDescription) {
        this._ariaDescriptionId = getId();
      }
      var ariaChecked = (_a7 = getIsChecked(item)) !== null && _a7 !== void 0 ? _a7 : void 0;
      return React53.createElement(KeytipData, { keytipProps, disabled: isItemDisabled(item) }, function(keytipAttributes) {
        return React53.createElement(
          "div",
          { "data-ktp-target": keytipAttributes["data-ktp-target"], ref: function(splitButton) {
            return _this._splitButton = splitButton;
          }, role: getMenuItemAriaRole(item), "aria-label": item.ariaLabel, className: classNames2.splitContainer, "aria-disabled": isItemDisabled(item), "aria-expanded": itemHasSubmenu ? item.key === expandedMenuItemKey : void 0, "aria-haspopup": true, "aria-describedby": mergeAriaAttributeValues(item.ariaDescribedBy, ariaDescription ? _this._ariaDescriptionId : void 0, keytipAttributes["aria-describedby"]), "aria-checked": ariaChecked, "aria-posinset": focusableElementIndex + 1, "aria-setsize": totalItemCount, onMouseEnter: _this._onItemMouseEnterPrimary, onMouseLeave: onItemMouseLeave ? onItemMouseLeave.bind(_this, __assign(__assign({}, item), { subMenuProps: null, items: null })) : void 0, onMouseMove: _this._onItemMouseMovePrimary, onKeyDown: _this._onItemKeyDown, onClick: _this._executeItemClick, onTouchStart: _this._onTouchStart, tabIndex: 0, "data-is-focusable": true, "aria-roledescription": item["aria-roledescription"] },
          _this._renderSplitPrimaryButton(item, classNames2, index, hasCheckmarks, hasIcons),
          _this._renderSplitDivider(item),
          _this._renderSplitIconButton(item, classNames2, index, keytipAttributes),
          _this._renderAriaDescription(ariaDescription, classNames2.screenReaderText)
        );
      });
    };
    ContextualMenuSplitButton2.prototype._renderSplitPrimaryButton = function(item, classNames2, index, hasCheckmarks, hasIcons) {
      var _a7 = this.props, _b3 = _a7.contextualMenuItemAs, ChildrenRenderer = _b3 === void 0 ? ContextualMenuItem : _b3, onItemClick = _a7.onItemClick;
      var itemProps = {
        key: item.key,
        disabled: isItemDisabled(item) || item.primaryDisabled,
        /* eslint-disable deprecation/deprecation */
        name: item.name,
        text: item.text || item.name,
        secondaryText: item.secondaryText,
        /* eslint-enable deprecation/deprecation */
        className: classNames2.splitPrimary,
        canCheck: item.canCheck,
        isChecked: item.isChecked,
        checked: item.checked,
        iconProps: item.iconProps,
        id: this._dismissLabelId,
        onRenderIcon: item.onRenderIcon,
        data: item.data,
        "data-is-focusable": false
      };
      var itemComponentProps = item.itemProps;
      return React53.createElement(
        "button",
        __assign({}, getNativeProps(itemProps, buttonProperties)),
        React53.createElement(ChildrenRenderer, __assign({ "data-is-focusable": false, item: itemProps, classNames: classNames2, index, onCheckmarkClick: hasCheckmarks && onItemClick ? onItemClick : void 0, hasIcons }, itemComponentProps))
      );
    };
    ContextualMenuSplitButton2.prototype._renderSplitDivider = function(item) {
      var getDividerClassNames2 = item.getSplitButtonVerticalDividerClassNames || getSplitButtonVerticalDividerClassNames;
      return React53.createElement(VerticalDivider, { getClassNames: getDividerClassNames2 });
    };
    ContextualMenuSplitButton2.prototype._renderSplitIconButton = function(item, classNames2, index, keytipAttributes) {
      var _a7 = this.props, onItemMouseLeave = _a7.onItemMouseLeave, onItemMouseDown2 = _a7.onItemMouseDown, openSubMenu = _a7.openSubMenu, dismissSubMenu = _a7.dismissSubMenu, dismissMenu = _a7.dismissMenu;
      var ChildrenRenderer = ContextualMenuItem;
      if (this.props.item.contextualMenuItemAs) {
        ChildrenRenderer = composeComponentAs(this.props.item.contextualMenuItemAs, ChildrenRenderer);
      }
      if (this.props.contextualMenuItemAs) {
        ChildrenRenderer = composeComponentAs(this.props.contextualMenuItemAs, ChildrenRenderer);
      }
      var itemProps = {
        onClick: this._onIconItemClick,
        disabled: isItemDisabled(item),
        className: classNames2.splitMenu,
        subMenuProps: item.subMenuProps,
        submenuIconProps: item.submenuIconProps,
        split: true,
        key: item.key,
        "aria-labelledby": this._dismissLabelId
      };
      var buttonProps = __assign(__assign({}, getNativeProps(itemProps, buttonProperties)), {
        onMouseEnter: this._onItemMouseEnterIcon,
        onMouseLeave: onItemMouseLeave ? onItemMouseLeave.bind(this, item) : void 0,
        onMouseDown: function(ev) {
          return onItemMouseDown2 ? onItemMouseDown2(item, ev) : void 0;
        },
        onMouseMove: this._onItemMouseMoveIcon,
        "data-is-focusable": false,
        "data-ktp-execute-target": keytipAttributes["data-ktp-execute-target"],
        "aria-haspopup": true
      });
      var itemComponentProps = item.itemProps;
      return React53.createElement(
        "button",
        __assign({}, buttonProps),
        React53.createElement(ChildrenRenderer, __assign({ componentRef: item.componentRef, item: itemProps, classNames: classNames2, index, hasIcons: false, openSubMenu, dismissSubMenu, dismissMenu, getSubmenuTarget: this._getSubmenuTarget }, itemComponentProps))
      );
    };
    ContextualMenuSplitButton2.prototype._handleTouchAndPointerEvent = function(ev) {
      var _this = this;
      var onTap = this.props.onTap;
      if (onTap) {
        onTap(ev);
      }
      if (this._lastTouchTimeoutId) {
        this._async.clearTimeout(this._lastTouchTimeoutId);
        this._lastTouchTimeoutId = void 0;
      }
      this._processingTouch = true;
      this._lastTouchTimeoutId = this._async.setTimeout(function() {
        _this._processingTouch = false;
        _this._lastTouchTimeoutId = void 0;
      }, TouchIdleDelay);
    };
    return ContextualMenuSplitButton2;
  }(ContextualMenuItemWrapper)
);

// node_modules/@fluentui/react/lib/utilities/hooks/useResponsiveMode.js
var React56 = __toESM(require_react());

// node_modules/@fluentui/react/lib/utilities/decorators/withResponsiveMode.js
var React55 = __toESM(require_react());

// node_modules/@fluentui/react/lib/utilities/decorators/BaseDecorator.js
var React54 = __toESM(require_react());
var BaseDecorator = (
  /** @class */
  function(_super) {
    __extends(BaseDecorator2, _super);
    function BaseDecorator2(props) {
      var _this = _super.call(this, props) || this;
      _this._updateComposedComponentRef = _this._updateComposedComponentRef.bind(_this);
      return _this;
    }
    BaseDecorator2.prototype._updateComposedComponentRef = function(composedComponentInstance) {
      this._composedComponentInstance = composedComponentInstance;
      if (composedComponentInstance) {
        this._hoisted = hoistMethods(this, composedComponentInstance);
      } else if (this._hoisted) {
        unhoistMethods(this, this._hoisted);
      }
    };
    return BaseDecorator2;
  }(React54.Component)
);

// node_modules/@fluentui/react/lib/utilities/decorators/withResponsiveMode.js
var ResponsiveMode;
(function(ResponsiveMode2) {
  ResponsiveMode2[ResponsiveMode2["small"] = 0] = "small";
  ResponsiveMode2[ResponsiveMode2["medium"] = 1] = "medium";
  ResponsiveMode2[ResponsiveMode2["large"] = 2] = "large";
  ResponsiveMode2[ResponsiveMode2["xLarge"] = 3] = "xLarge";
  ResponsiveMode2[ResponsiveMode2["xxLarge"] = 4] = "xxLarge";
  ResponsiveMode2[ResponsiveMode2["xxxLarge"] = 5] = "xxxLarge";
  ResponsiveMode2[ResponsiveMode2["unknown"] = 999] = "unknown";
})(ResponsiveMode || (ResponsiveMode = {}));
var RESPONSIVE_MAX_CONSTRAINT = [479, 639, 1023, 1365, 1919, 99999999];
var _defaultMode;
var _lastMode;
function getInitialResponsiveMode() {
  var _a7;
  return (_a7 = _defaultMode !== null && _defaultMode !== void 0 ? _defaultMode : _lastMode) !== null && _a7 !== void 0 ? _a7 : ResponsiveMode.large;
}
function getWidthOfCurrentWindow(currentWindow) {
  try {
    return currentWindow.document.documentElement.clientWidth;
  } catch (e) {
    return currentWindow.innerWidth;
  }
}
function getResponsiveMode(currentWindow) {
  var responsiveMode = ResponsiveMode.small;
  if (currentWindow) {
    try {
      while (getWidthOfCurrentWindow(currentWindow) > RESPONSIVE_MAX_CONSTRAINT[responsiveMode]) {
        responsiveMode++;
      }
    } catch (e) {
      responsiveMode = getInitialResponsiveMode();
    }
    _lastMode = responsiveMode;
  } else {
    if (_defaultMode !== void 0) {
      responsiveMode = _defaultMode;
    } else {
      throw new Error("Content was rendered in a server environment without providing a default responsive mode. Call setResponsiveMode to define what the responsive mode is.");
    }
  }
  return responsiveMode;
}

// node_modules/@fluentui/react/lib/utilities/hooks/useResponsiveMode.js
var useResponsiveMode = function(elementRef, overrideResponsiveMode) {
  var _a7 = React56.useState(getInitialResponsiveMode()), lastResponsiveMode = _a7[0], setLastResponsiveMode = _a7[1];
  var onResize = React56.useCallback(function() {
    var newResponsiveMode = getResponsiveMode(getWindow(elementRef.current));
    if (lastResponsiveMode !== newResponsiveMode) {
      setLastResponsiveMode(newResponsiveMode);
    }
  }, [elementRef, lastResponsiveMode]);
  var win = useWindow();
  useOnEvent(win, "resize", onResize);
  React56.useEffect(function() {
    if (overrideResponsiveMode === void 0) {
      onResize();
    }
  }, [overrideResponsiveMode]);
  return overrideResponsiveMode !== null && overrideResponsiveMode !== void 0 ? overrideResponsiveMode : lastResponsiveMode;
};

// node_modules/@fluentui/react/lib/utilities/MenuContext/MenuContext.js
var React57 = __toESM(require_react());
var MenuContext = React57.createContext({});

// node_modules/@fluentui/react/lib/components/ContextualMenu/ContextualMenu.base.js
var getClassNames7 = classNamesFunction();
var getContextualMenuItemClassNames = classNamesFunction();
var DEFAULT_PROPS3 = {
  items: [],
  shouldFocusOnMount: true,
  gapSpace: 0,
  directionalHint: DirectionalHint.bottomAutoEdge,
  beakWidth: 16
};
function getItemCount(items) {
  var totalItemCount = 0;
  for (var _i = 0, items_1 = items; _i < items_1.length; _i++) {
    var item = items_1[_i];
    if (item.itemType !== ContextualMenuItemType.Divider && item.itemType !== ContextualMenuItemType.Header) {
      var itemCount = item.customOnRenderListLength ? item.customOnRenderListLength : 1;
      totalItemCount += itemCount;
    }
  }
  return totalItemCount;
}
function getSubmenuItems(item, options) {
  var target = options === null || options === void 0 ? void 0 : options.target;
  var items = item.subMenuProps ? item.subMenuProps.items : item.items;
  if (items) {
    var overrideItems = [];
    for (var _i = 0, items_2 = items; _i < items_2.length; _i++) {
      var subItem = items_2[_i];
      if (subItem.preferMenuTargetAsEventTarget) {
        var onClick = subItem.onClick, contextItem = __rest(subItem, ["onClick"]);
        overrideItems.push(__assign(__assign({}, contextItem), { onClick: getOnClickWithOverrideTarget(onClick, target) }));
      } else {
        overrideItems.push(subItem);
      }
    }
    return overrideItems;
  }
}
function canAnyMenuItemsCheck(items) {
  return items.some(function(item) {
    if (item.canCheck) {
      return true;
    }
    if (item.sectionProps && item.sectionProps.items.some(function(submenuItem) {
      return submenuItem.canCheck === true;
    })) {
      return true;
    }
    return false;
  });
}
var NavigationIdleDelay = 250;
var COMPONENT_NAME3 = "ContextualMenu";
var _getMenuItemStylesFunction = memoizeFunction(function() {
  var styles = [];
  for (var _i = 0; _i < arguments.length; _i++) {
    styles[_i] = arguments[_i];
  }
  return function(styleProps) {
    return concatStyleSetsWithProps.apply(void 0, __spreadArray([styleProps, getItemStyles], styles, false));
  };
});
function useVisibility(props, targetWindow) {
  var _a7 = props.hidden, hidden = _a7 === void 0 ? false : _a7, onMenuDismissed = props.onMenuDismissed, onMenuOpened = props.onMenuOpened;
  var previousHidden = usePrevious(hidden);
  var onMenuOpenedRef = React58.useRef(onMenuOpened);
  var onMenuClosedRef = React58.useRef(onMenuDismissed);
  var propsRef = React58.useRef(props);
  onMenuOpenedRef.current = onMenuOpened;
  onMenuClosedRef.current = onMenuDismissed;
  propsRef.current = props;
  React58.useEffect(function() {
    var _a8, _b3;
    if (hidden && previousHidden === false) {
      (_a8 = onMenuClosedRef.current) === null || _a8 === void 0 ? void 0 : _a8.call(onMenuClosedRef, propsRef.current);
    } else if (!hidden && previousHidden !== false) {
      (_b3 = onMenuOpenedRef.current) === null || _b3 === void 0 ? void 0 : _b3.call(onMenuOpenedRef, propsRef.current);
    }
  }, [hidden, previousHidden]);
  React58.useEffect(function() {
    return function() {
      var _a8;
      return (_a8 = onMenuClosedRef.current) === null || _a8 === void 0 ? void 0 : _a8.call(onMenuClosedRef, propsRef.current);
    };
  }, []);
}
function useSubMenuState(_a7, dismiss) {
  var hidden = _a7.hidden, items = _a7.items, theme = _a7.theme, className = _a7.className, id = _a7.id, menuTarget = _a7.target;
  var _b3 = React58.useState(), expandedMenuItemKey = _b3[0], setExpandedMenuItemKey = _b3[1];
  var _c3 = React58.useState(), submenuTarget = _c3[0], setSubmenuTarget = _c3[1];
  var _d3 = React58.useState(), shouldFocusOnContainer = _d3[0], setShouldFocusOnContainer = _d3[1];
  var subMenuId = useId(COMPONENT_NAME3, id);
  var closeSubMenu = React58.useCallback(function() {
    setShouldFocusOnContainer(void 0);
    setExpandedMenuItemKey(void 0);
    setSubmenuTarget(void 0);
  }, []);
  var openSubMenu = React58.useCallback(function(_a8, target, focusContainer) {
    var submenuItemKey = _a8.key;
    if (expandedMenuItemKey === submenuItemKey) {
      return;
    }
    target.focus();
    setShouldFocusOnContainer(focusContainer);
    setExpandedMenuItemKey(submenuItemKey);
    setSubmenuTarget(target);
  }, [expandedMenuItemKey]);
  React58.useEffect(function() {
    if (hidden) {
      closeSubMenu();
    }
  }, [hidden, closeSubMenu]);
  var onSubMenuDismiss = useOnSubmenuDismiss(dismiss, closeSubMenu);
  var getSubmenuProps = function() {
    var item = findItemByKeyFromItems(expandedMenuItemKey, items);
    var submenuProps = null;
    if (item) {
      submenuProps = {
        items: getSubmenuItems(item, { target: menuTarget }),
        target: submenuTarget,
        onDismiss: onSubMenuDismiss,
        isSubMenu: true,
        id: subMenuId,
        shouldFocusOnMount: true,
        shouldFocusOnContainer,
        directionalHint: getRTL2(theme) ? DirectionalHint.leftTopEdge : DirectionalHint.rightTopEdge,
        className,
        gapSpace: 0,
        isBeakVisible: false
      };
      if (item.subMenuProps) {
        assign(submenuProps, item.subMenuProps);
      }
      if (item.preferMenuTargetAsEventTarget) {
        var onItemClick = item.onItemClick;
        submenuProps.onItemClick = getOnClickWithOverrideTarget(onItemClick, menuTarget);
      }
    }
    return submenuProps;
  };
  return [expandedMenuItemKey, openSubMenu, getSubmenuProps, onSubMenuDismiss];
}
function useShouldUpdateFocusOnMouseMove(_a7) {
  var delayUpdateFocusOnHover = _a7.delayUpdateFocusOnHover, hidden = _a7.hidden;
  var shouldUpdateFocusOnMouseEvent = React58.useRef(!delayUpdateFocusOnHover);
  var gotMouseMove = React58.useRef(false);
  React58.useEffect(function() {
    shouldUpdateFocusOnMouseEvent.current = !delayUpdateFocusOnHover;
    gotMouseMove.current = hidden ? false : !delayUpdateFocusOnHover && gotMouseMove.current;
  }, [delayUpdateFocusOnHover, hidden]);
  var onMenuFocusCapture = React58.useCallback(function() {
    if (delayUpdateFocusOnHover) {
      shouldUpdateFocusOnMouseEvent.current = false;
    }
  }, [delayUpdateFocusOnHover]);
  return [shouldUpdateFocusOnMouseEvent, gotMouseMove, onMenuFocusCapture];
}
function usePreviousActiveElement(_a7, targetWindow, hostElement) {
  var hidden = _a7.hidden, onRestoreFocus = _a7.onRestoreFocus;
  var previousActiveElement = React58.useRef();
  var tryFocusPreviousActiveElement = React58.useCallback(function(options) {
    var _a8, _b3;
    if (onRestoreFocus) {
      onRestoreFocus(options);
    } else if (options === null || options === void 0 ? void 0 : options.documentContainsFocus) {
      (_b3 = (_a8 = previousActiveElement.current) === null || _a8 === void 0 ? void 0 : _a8.focus) === null || _b3 === void 0 ? void 0 : _b3.call(_a8);
    }
  }, [onRestoreFocus]);
  useIsomorphicLayoutEffect(function() {
    var _a8, _b3;
    if (!hidden) {
      var newElement = targetWindow === null || targetWindow === void 0 ? void 0 : targetWindow.document.activeElement;
      if (!((_a8 = hostElement.current) === null || _a8 === void 0 ? void 0 : _a8.contains(newElement)) && newElement.tagName !== "BODY") {
        previousActiveElement.current = newElement;
      }
    } else if (previousActiveElement.current) {
      tryFocusPreviousActiveElement({
        originalElement: previousActiveElement.current,
        containsFocus: true,
        documentContainsFocus: ((_b3 = getDocument()) === null || _b3 === void 0 ? void 0 : _b3.hasFocus()) || false
      });
      previousActiveElement.current = void 0;
    }
  }, [hidden, targetWindow === null || targetWindow === void 0 ? void 0 : targetWindow.document.activeElement, tryFocusPreviousActiveElement, hostElement]);
  return [tryFocusPreviousActiveElement];
}
function useKeyHandlers(_a7, dismiss, hostElement, openSubMenu) {
  var theme = _a7.theme, isSubMenu = _a7.isSubMenu, _b3 = _a7.focusZoneProps, _c3 = _b3 === void 0 ? {} : _b3, checkForNoWrap = _c3.checkForNoWrap, _d3 = _c3.direction, focusZoneDirection = _d3 === void 0 ? FocusZoneDirection.vertical : _d3;
  var lastKeyDownWasAltOrMeta = React58.useRef();
  var keyHandler = function(ev, shouldHandleKey, dismissAllMenus) {
    var handled = false;
    if (shouldHandleKey(ev)) {
      dismiss(ev, dismissAllMenus);
      ev.preventDefault();
      ev.stopPropagation();
      handled = true;
    }
    return handled;
  };
  var shouldCloseSubMenu = function(ev) {
    var submenuCloseKey = getRTL2(theme) ? KeyCodes.right : KeyCodes.left;
    if (ev.which !== submenuCloseKey || !isSubMenu) {
      return false;
    }
    return !!(focusZoneDirection === FocusZoneDirection.vertical || checkForNoWrap && !shouldWrapFocus(ev.target, "data-no-horizontal-wrap"));
  };
  var shouldHandleKeyDown = function(ev) {
    return (
      // eslint-disable-next-line deprecation/deprecation
      ev.which === KeyCodes.escape || shouldCloseSubMenu(ev) || // eslint-disable-next-line deprecation/deprecation
      ev.which === KeyCodes.up && (ev.altKey || ev.metaKey)
    );
  };
  var onKeyDown = function(ev) {
    lastKeyDownWasAltOrMeta.current = isAltOrMeta(ev);
    var dismissAllMenus = ev.which === KeyCodes.escape && (isMac() || isIOS());
    return keyHandler(ev, shouldHandleKeyDown, dismissAllMenus);
  };
  var shouldHandleKeyUp = function(ev) {
    var keyPressIsAltOrMetaAlone = lastKeyDownWasAltOrMeta.current && isAltOrMeta(ev);
    lastKeyDownWasAltOrMeta.current = false;
    return !!keyPressIsAltOrMetaAlone && !(isIOS() || isMac());
  };
  var onKeyUp = function(ev) {
    return keyHandler(
      ev,
      shouldHandleKeyUp,
      true
      /* dismissAllMenus */
    );
  };
  var onMenuKeyDown = function(ev) {
    var handled = onKeyDown(ev);
    if (handled || !hostElement.current) {
      return;
    }
    var hasModifier = !!(ev.altKey || ev.metaKey);
    var isUp = ev.which === KeyCodes.up;
    var isDown = ev.which === KeyCodes.down;
    if (!hasModifier && (isUp || isDown)) {
      var elementToFocus = isUp ? getLastFocusable(hostElement.current, hostElement.current.lastChild, true) : getFirstFocusable(hostElement.current, hostElement.current.firstChild, true);
      if (elementToFocus) {
        elementToFocus.focus();
        ev.preventDefault();
        ev.stopPropagation();
      }
    }
  };
  var onItemKeyDown = function(item, ev) {
    var openKey = getRTL2(theme) ? KeyCodes.left : KeyCodes.right;
    if (!item.disabled && // eslint-disable-next-line deprecation/deprecation
    (ev.which === openKey || ev.which === KeyCodes.enter || ev.which === KeyCodes.down && (ev.altKey || ev.metaKey))) {
      openSubMenu(item, ev.currentTarget);
      ev.preventDefault();
    }
  };
  return [onKeyDown, onKeyUp, onMenuKeyDown, onItemKeyDown];
}
function useScrollHandler(asyncTracker) {
  var isScrollIdle = React58.useRef(true);
  var scrollIdleTimeoutId = React58.useRef();
  var onScroll = function() {
    if (!isScrollIdle.current && scrollIdleTimeoutId.current !== void 0) {
      asyncTracker.clearTimeout(scrollIdleTimeoutId.current);
      scrollIdleTimeoutId.current = void 0;
    } else {
      isScrollIdle.current = false;
    }
    scrollIdleTimeoutId.current = asyncTracker.setTimeout(function() {
      isScrollIdle.current = true;
    }, NavigationIdleDelay);
  };
  return [onScroll, isScrollIdle];
}
function useOnSubmenuDismiss(dismiss, closeSubMenu) {
  var isMountedRef = React58.useRef(false);
  React58.useEffect(function() {
    isMountedRef.current = true;
    return function() {
      isMountedRef.current = false;
    };
  }, []);
  var onSubMenuDismiss = function(ev, dismissAll) {
    if (dismissAll) {
      dismiss(ev, dismissAll);
    } else if (isMountedRef.current) {
      closeSubMenu();
    }
  };
  return onSubMenuDismiss;
}
function useSubmenuEnterTimer(_a7, asyncTracker) {
  var _b3 = _a7.subMenuHoverDelay, subMenuHoverDelay = _b3 === void 0 ? NavigationIdleDelay : _b3;
  var enterTimerRef = React58.useRef(void 0);
  var cancelSubMenuTimer = function() {
    if (enterTimerRef.current !== void 0) {
      asyncTracker.clearTimeout(enterTimerRef.current);
      enterTimerRef.current = void 0;
    }
  };
  var startSubmenuTimer = function(onTimerExpired) {
    enterTimerRef.current = asyncTracker.setTimeout(function() {
      onTimerExpired();
      cancelSubMenuTimer();
    }, subMenuHoverDelay);
  };
  return [cancelSubMenuTimer, startSubmenuTimer, enterTimerRef];
}
function useMouseHandlers(props, isScrollIdle, subMenuEntryTimer, targetWindow, shouldUpdateFocusOnMouseEvent, gotMouseMove, expandedMenuItemKey, hostElement, startSubmenuTimer, cancelSubMenuTimer, openSubMenu, onSubMenuDismiss, dismiss) {
  var menuTarget = props.target;
  var onItemMouseEnterBase = function(item, ev, target) {
    if (shouldUpdateFocusOnMouseEvent.current) {
      gotMouseMove.current = true;
    }
    if (shouldIgnoreMouseEvent()) {
      return;
    }
    updateFocusOnMouseEvent(item, ev, target);
  };
  var onItemMouseMoveBase = function(item, ev, target) {
    var targetElement = ev.currentTarget;
    if (shouldUpdateFocusOnMouseEvent.current) {
      gotMouseMove.current = true;
    } else {
      return;
    }
    if (!isScrollIdle.current || subMenuEntryTimer.current !== void 0 || targetElement === (targetWindow === null || targetWindow === void 0 ? void 0 : targetWindow.document.activeElement)) {
      return;
    }
    updateFocusOnMouseEvent(item, ev, target);
  };
  var shouldIgnoreMouseEvent = function() {
    return !isScrollIdle.current || !gotMouseMove.current;
  };
  var onMouseItemLeave = function(item, ev) {
    var _a7;
    if (shouldIgnoreMouseEvent()) {
      return;
    }
    cancelSubMenuTimer();
    if (expandedMenuItemKey !== void 0) {
      return;
    }
    if (hostElement.current.setActive) {
      try {
        hostElement.current.setActive();
      } catch (e) {
      }
    } else {
      (_a7 = hostElement.current) === null || _a7 === void 0 ? void 0 : _a7.focus();
    }
  };
  var updateFocusOnMouseEvent = function(item, ev, target) {
    var targetElement = target ? target : ev.currentTarget;
    if (item.key === expandedMenuItemKey) {
      return;
    }
    cancelSubMenuTimer();
    if (expandedMenuItemKey === void 0) {
      targetElement.focus();
    }
    if (hasSubmenu(item)) {
      ev.stopPropagation();
      startSubmenuTimer(function() {
        targetElement.focus();
        openSubMenu(item, targetElement, true);
      });
    } else {
      startSubmenuTimer(function() {
        onSubMenuDismiss(ev);
        targetElement.focus();
      });
    }
  };
  var onItemClick = function(item, ev) {
    onItemClickBase(item, ev, ev.currentTarget);
  };
  var onItemClickBase = function(item, ev, target) {
    var items = getSubmenuItems(item, { target: menuTarget });
    cancelSubMenuTimer();
    if (!hasSubmenu(item) && (!items || !items.length)) {
      executeItemClick(item, ev);
    } else {
      if (item.key !== expandedMenuItemKey) {
        var shouldFocusOnContainer = typeof props.shouldFocusOnContainer === "boolean" ? props.shouldFocusOnContainer : ev.nativeEvent.pointerType === "mouse";
        openSubMenu(item, target, shouldFocusOnContainer);
      }
    }
    ev.stopPropagation();
    ev.preventDefault();
  };
  var onAnchorClick = function(item, ev) {
    executeItemClick(item, ev);
    ev.stopPropagation();
  };
  var executeItemClick = function(item, ev) {
    if (item.disabled || item.isDisabled) {
      return;
    }
    if (item.preferMenuTargetAsEventTarget) {
      overrideTarget(ev, menuTarget);
    }
    var shouldDismiss = false;
    if (item.onClick) {
      shouldDismiss = !!item.onClick(ev, item);
    } else if (props.onItemClick) {
      shouldDismiss = !!props.onItemClick(ev, item);
    }
    if (shouldDismiss || !ev.defaultPrevented) {
      dismiss(ev, true);
    }
  };
  return [
    onItemMouseEnterBase,
    onItemMouseMoveBase,
    onMouseItemLeave,
    onItemClick,
    onAnchorClick,
    executeItemClick,
    onItemClickBase
  ];
}
var ContextualMenuBase = React58.memo(React58.forwardRef(function(propsWithoutDefaults, forwardedRef) {
  var _a7;
  var _b3 = getPropsWithDefaults(DEFAULT_PROPS3, propsWithoutDefaults), ref = _b3.ref, props = __rest(_b3, ["ref"]);
  var hostElement = React58.useRef(null);
  var asyncTracker = useAsync();
  var menuId = useId(COMPONENT_NAME3, props.id);
  useWarnings({
    name: COMPONENT_NAME3,
    props,
    deprecations: {
      getMenuClassNames: "styles"
    }
  });
  var dismiss = function(ev, dismissAll) {
    var _a8;
    return (_a8 = props.onDismiss) === null || _a8 === void 0 ? void 0 : _a8.call(props, ev, dismissAll);
  };
  var _c3 = useTarget(props.target, hostElement), targetRef = _c3[0], targetWindow = _c3[1];
  var tryFocusPreviousActiveElement = usePreviousActiveElement(props, targetWindow, hostElement)[0];
  var _d3 = useSubMenuState(props, dismiss), expandedMenuItemKey = _d3[0], openSubMenu = _d3[1], getSubmenuProps = _d3[2], onSubMenuDismiss = _d3[3];
  var _e2 = useShouldUpdateFocusOnMouseMove(props), shouldUpdateFocusOnMouseEvent = _e2[0], gotMouseMove = _e2[1], onMenuFocusCapture = _e2[2];
  var _f = useScrollHandler(asyncTracker), onScroll = _f[0], isScrollIdle = _f[1];
  var _g = useSubmenuEnterTimer(props, asyncTracker), cancelSubMenuTimer = _g[0], startSubmenuTimer = _g[1], subMenuEntryTimer = _g[2];
  var responsiveMode = useResponsiveMode(hostElement, props.responsiveMode);
  useVisibility(props, targetWindow);
  var _h = useKeyHandlers(props, dismiss, hostElement, openSubMenu), onKeyDown = _h[0], onKeyUp = _h[1], onMenuKeyDown = _h[2], onItemKeyDown = _h[3];
  var _j = useMouseHandlers(props, isScrollIdle, subMenuEntryTimer, targetWindow, shouldUpdateFocusOnMouseEvent, gotMouseMove, expandedMenuItemKey, hostElement, startSubmenuTimer, cancelSubMenuTimer, openSubMenu, onSubMenuDismiss, dismiss), onItemMouseEnterBase = _j[0], onItemMouseMoveBase = _j[1], onMouseItemLeave = _j[2], onItemClick = _j[3], onAnchorClick = _j[4], executeItemClick = _j[5], onItemClickBase = _j[6];
  var onDefaultRenderMenuList = function(menuListProps, menuClassNames, defaultRender) {
    var indexCorrection = 0;
    var items2 = menuListProps.items, totalItemCount = menuListProps.totalItemCount, hasCheckmarks2 = menuListProps.hasCheckmarks, hasIcons2 = menuListProps.hasIcons;
    return React58.createElement("ul", { className: menuClassNames.list, onKeyDown, onKeyUp, role: "presentation" }, items2.map(function(item, index) {
      var menuItem = renderMenuItem(item, index, indexCorrection, totalItemCount, hasCheckmarks2, hasIcons2, menuClassNames);
      if (item.itemType !== ContextualMenuItemType.Divider && item.itemType !== ContextualMenuItemType.Header) {
        var indexIncrease = item.customOnRenderListLength ? item.customOnRenderListLength : 1;
        indexCorrection += indexIncrease;
      }
      return menuItem;
    }));
  };
  var renderFocusZone = function(children, adjustedFocusZoneProps2) {
    var _a8 = props.focusZoneAs, ChildrenRenderer = _a8 === void 0 ? FocusZone : _a8;
    return React58.createElement(ChildrenRenderer, __assign({}, adjustedFocusZoneProps2), children);
  };
  var renderMenuItem = function(item, index, focusableElementIndex, totalItemCount, hasCheckmarks2, hasIcons2, menuClassNames) {
    var _a8;
    var renderedItems = [];
    var iconProps = item.iconProps || { iconName: "None" };
    var getItemClassNames2 = item.getItemClassNames, itemProps = item.itemProps;
    var styles2 = itemProps ? itemProps.styles : void 0;
    var dividerClassName = item.itemType === ContextualMenuItemType.Divider ? item.className : void 0;
    var subMenuIconClassName = item.submenuIconProps ? item.submenuIconProps.className : "";
    var itemClassNames;
    if (getItemClassNames2) {
      itemClassNames = getItemClassNames2(props.theme, isItemDisabled(item), expandedMenuItemKey === item.key, !!getIsChecked(item), !!item.href, iconProps.iconName !== "None", item.className, dividerClassName, iconProps.className, subMenuIconClassName, item.primaryDisabled);
    } else {
      var itemStyleProps = {
        theme: props.theme,
        disabled: isItemDisabled(item),
        expanded: expandedMenuItemKey === item.key,
        checked: !!getIsChecked(item),
        isAnchorLink: !!item.href,
        knownIcon: iconProps.iconName !== "None",
        itemClassName: item.className,
        dividerClassName,
        iconClassName: iconProps.className,
        subMenuClassName: subMenuIconClassName,
        primaryDisabled: item.primaryDisabled
      };
      itemClassNames = getContextualMenuItemClassNames(_getMenuItemStylesFunction((_a8 = menuClassNames.subComponentStyles) === null || _a8 === void 0 ? void 0 : _a8.menuItem, styles2), itemStyleProps);
    }
    if (item.text === "-" || item.name === "-") {
      item.itemType = ContextualMenuItemType.Divider;
    }
    switch (item.itemType) {
      case ContextualMenuItemType.Divider:
        renderedItems.push(renderSeparator(index, itemClassNames));
        break;
      case ContextualMenuItemType.Header:
        renderedItems.push(renderSeparator(index, itemClassNames));
        var headerItem = renderHeaderMenuItem(item, itemClassNames, menuClassNames, index, hasCheckmarks2, hasIcons2);
        renderedItems.push(renderListItem(headerItem, item.key || index, itemClassNames, item.title));
        break;
      case ContextualMenuItemType.Section:
        renderedItems.push(renderSectionItem(item, itemClassNames, menuClassNames, index, hasCheckmarks2, hasIcons2));
        break;
      default:
        var defaultRenderNormalItem = function() {
          return renderNormalItem(item, itemClassNames, index, focusableElementIndex, totalItemCount, hasCheckmarks2, hasIcons2);
        };
        var menuItem = props.onRenderContextualMenuItem ? props.onRenderContextualMenuItem(item, defaultRenderNormalItem) : defaultRenderNormalItem();
        renderedItems.push(renderListItem(menuItem, item.key || index, itemClassNames, item.title));
        break;
    }
    return React58.createElement(React58.Fragment, { key: item.key }, renderedItems);
  };
  var defaultMenuItemRenderer = function(item, menuClassNames) {
    var index = item.index, focusableElementIndex = item.focusableElementIndex, totalItemCount = item.totalItemCount, hasCheckmarks2 = item.hasCheckmarks, hasIcons2 = item.hasIcons;
    return renderMenuItem(item, index, focusableElementIndex, totalItemCount, hasCheckmarks2, hasIcons2, menuClassNames);
  };
  var renderSectionItem = function(sectionItem, itemClassNames, menuClassNames, index, hasCheckmarks2, hasIcons2) {
    var sectionProps = sectionItem.sectionProps;
    if (!sectionProps) {
      return;
    }
    var headerItem;
    var groupProps;
    if (sectionProps.title) {
      var headerContextualMenuItem = void 0;
      var ariaLabelledby = "";
      if (typeof sectionProps.title === "string") {
        var id_1 = menuId + sectionProps.title.replace(/\s/g, "");
        headerContextualMenuItem = {
          key: "section-".concat(sectionProps.title, "-title"),
          itemType: ContextualMenuItemType.Header,
          text: sectionProps.title,
          id: id_1
        };
        ariaLabelledby = id_1;
      } else {
        var id_2 = sectionProps.title.id || menuId + sectionProps.title.key.replace(/\s/g, "");
        headerContextualMenuItem = __assign(__assign({}, sectionProps.title), { id: id_2 });
        ariaLabelledby = id_2;
      }
      if (headerContextualMenuItem) {
        groupProps = {
          role: "group",
          "aria-labelledby": ariaLabelledby
        };
        headerItem = renderHeaderMenuItem(headerContextualMenuItem, itemClassNames, menuClassNames, index, hasCheckmarks2, hasIcons2);
      }
    }
    if (sectionProps.items && sectionProps.items.length > 0) {
      var correctedIndex_1 = 0;
      return React58.createElement(
        "li",
        { role: "presentation", key: sectionProps.key || sectionItem.key || "section-".concat(index) },
        React58.createElement(
          "div",
          __assign({}, groupProps),
          React58.createElement(
            "ul",
            { className: menuClassNames.list, role: "presentation" },
            sectionProps.topDivider && renderSeparator(index, itemClassNames, true, true),
            headerItem && renderListItem(headerItem, sectionItem.key || index, itemClassNames, sectionItem.title),
            sectionProps.items.map(function(contextualMenuItem, itemsIndex) {
              var menuItem = renderMenuItem(contextualMenuItem, itemsIndex, correctedIndex_1, getItemCount(sectionProps.items), hasCheckmarks2, hasIcons2, menuClassNames);
              if (contextualMenuItem.itemType !== ContextualMenuItemType.Divider && contextualMenuItem.itemType !== ContextualMenuItemType.Header) {
                var indexIncrease = contextualMenuItem.customOnRenderListLength ? contextualMenuItem.customOnRenderListLength : 1;
                correctedIndex_1 += indexIncrease;
              }
              return menuItem;
            }),
            sectionProps.bottomDivider && renderSeparator(index, itemClassNames, false, true)
          )
        )
      );
    }
  };
  var renderListItem = function(content, key, classNames3, title2) {
    return React58.createElement("li", { role: "presentation", title: title2, key, className: classNames3.item }, content);
  };
  var renderSeparator = function(index, classNames3, top, fromSection) {
    if (fromSection || index > 0) {
      return React58.createElement("li", { role: "separator", key: "separator-" + index + (top === void 0 ? "" : top ? "-top" : "-bottom"), className: classNames3.divider, "aria-hidden": "true" });
    }
    return null;
  };
  var renderNormalItem = function(item, classNames3, index, focusableElementIndex, totalItemCount, hasCheckmarks2, hasIcons2) {
    if (item.onRender) {
      return item.onRender(__assign({ "aria-posinset": focusableElementIndex + 1, "aria-setsize": totalItemCount }, item), dismiss);
    }
    var contextualMenuItemAs = props.contextualMenuItemAs;
    var commonProps = {
      item,
      classNames: classNames3,
      index,
      focusableElementIndex,
      totalItemCount,
      hasCheckmarks: hasCheckmarks2,
      hasIcons: hasIcons2,
      contextualMenuItemAs,
      onItemMouseEnter: onItemMouseEnterBase,
      onItemMouseLeave: onMouseItemLeave,
      onItemMouseMove: onItemMouseMoveBase,
      onItemMouseDown,
      executeItemClick,
      onItemKeyDown,
      expandedMenuItemKey,
      openSubMenu,
      dismissSubMenu: onSubMenuDismiss,
      dismissMenu: dismiss
    };
    if (item.href) {
      var ContextualMenuAnchorAs = ContextualMenuAnchor;
      if (item.contextualMenuItemWrapperAs) {
        ContextualMenuAnchorAs = composeComponentAs(item.contextualMenuItemWrapperAs, ContextualMenuAnchorAs);
      }
      return React58.createElement(ContextualMenuAnchorAs, __assign({}, commonProps, { onItemClick: onAnchorClick }));
    }
    if (item.split && hasSubmenu(item)) {
      var ContextualMenuSplitButtonAs = ContextualMenuSplitButton;
      if (item.contextualMenuItemWrapperAs) {
        ContextualMenuSplitButtonAs = composeComponentAs(item.contextualMenuItemWrapperAs, ContextualMenuSplitButtonAs);
      }
      return React58.createElement(ContextualMenuSplitButtonAs, __assign({}, commonProps, { onItemClick, onItemClickBase, onTap: cancelSubMenuTimer }));
    }
    var ContextualMenuButtonAs = ContextualMenuButton;
    if (item.contextualMenuItemWrapperAs) {
      ContextualMenuButtonAs = composeComponentAs(item.contextualMenuItemWrapperAs, ContextualMenuButtonAs);
    }
    return React58.createElement(ContextualMenuButtonAs, __assign({}, commonProps, { onItemClick, onItemClickBase }));
  };
  var renderHeaderMenuItem = function(item, itemClassNames, menuClassNames, index, hasCheckmarks2, hasIcons2) {
    var ChildrenRenderer = ContextualMenuItem;
    if (item.contextualMenuItemAs) {
      ChildrenRenderer = composeComponentAs(item.contextualMenuItemAs, ChildrenRenderer);
    }
    if (props.contextualMenuItemAs) {
      ChildrenRenderer = composeComponentAs(props.contextualMenuItemAs, ChildrenRenderer);
    }
    var itemProps = item.itemProps, id2 = item.id;
    var divHtmlProperties = itemProps && getNativeProps(itemProps, divProperties);
    return (
      // eslint-disable-next-line deprecation/deprecation
      React58.createElement(
        "div",
        __assign({ id: id2, className: menuClassNames.header }, divHtmlProperties, { style: item.style }),
        React58.createElement(ChildrenRenderer, __assign({ item, classNames: itemClassNames, index, onCheckmarkClick: hasCheckmarks2 ? onItemClick : void 0, hasIcons: hasIcons2 }, itemProps))
      )
    );
  };
  var isBeakVisible = props.isBeakVisible;
  var items = props.items, labelElementId = props.labelElementId, id = props.id, className = props.className, beakWidth = props.beakWidth, directionalHint = props.directionalHint, directionalHintForRTL = props.directionalHintForRTL, alignTargetEdge = props.alignTargetEdge, gapSpace = props.gapSpace, coverTarget = props.coverTarget, ariaLabel = props.ariaLabel, doNotLayer = props.doNotLayer, target = props.target, bounds = props.bounds, useTargetWidth = props.useTargetWidth, useTargetAsMinWidth = props.useTargetAsMinWidth, directionalHintFixed = props.directionalHintFixed, shouldFocusOnMount = props.shouldFocusOnMount, shouldFocusOnContainer = props.shouldFocusOnContainer, title = props.title, styles = props.styles, theme = props.theme, calloutProps = props.calloutProps, _k = props.onRenderSubMenu, onRenderSubMenu2 = _k === void 0 ? onDefaultRenderSubMenu : _k, _l = props.onRenderMenuList, onRenderMenuList = _l === void 0 ? function(menuListProps, defaultRender) {
    return onDefaultRenderMenuList(menuListProps, classNames2, defaultRender);
  } : _l, focusZoneProps = props.focusZoneProps, getMenuClassNames = props.getMenuClassNames;
  var classNames2 = getMenuClassNames ? getMenuClassNames(theme, className) : getClassNames7(styles, {
    theme,
    className
  });
  var hasIcons = itemsHaveIcons(items);
  function itemsHaveIcons(contextualMenuItems) {
    for (var _i = 0, contextualMenuItems_1 = contextualMenuItems; _i < contextualMenuItems_1.length; _i++) {
      var item = contextualMenuItems_1[_i];
      if (item.iconProps) {
        return true;
      }
      if (item.itemType === ContextualMenuItemType.Section && item.sectionProps && itemsHaveIcons(item.sectionProps.items)) {
        return true;
      }
    }
    return false;
  }
  var adjustedFocusZoneProps = __assign(__assign({ direction: FocusZoneDirection.vertical, handleTabKey: FocusZoneTabbableElements.all, isCircularNavigation: true }, focusZoneProps), { className: css(classNames2.root, (_a7 = props.focusZoneProps) === null || _a7 === void 0 ? void 0 : _a7.className) });
  var hasCheckmarks = canAnyMenuItemsCheck(items);
  var submenuProps = expandedMenuItemKey && props.hidden !== true ? getSubmenuProps() : null;
  isBeakVisible = isBeakVisible === void 0 ? responsiveMode <= ResponsiveMode.medium : isBeakVisible;
  var contextMenuStyle;
  var targetAsHtmlElement = targetRef.current;
  if ((useTargetWidth || useTargetAsMinWidth) && targetAsHtmlElement && targetAsHtmlElement.offsetWidth) {
    var targetBoundingRect = targetAsHtmlElement.getBoundingClientRect();
    var targetWidth = targetBoundingRect.width - 2;
    if (useTargetWidth) {
      contextMenuStyle = {
        width: targetWidth
      };
    } else if (useTargetAsMinWidth) {
      contextMenuStyle = {
        minWidth: targetWidth
      };
    }
  }
  if (items && items.length > 0) {
    var totalItemCount_1 = getItemCount(items);
    var calloutStyles_1 = classNames2.subComponentStyles ? classNames2.subComponentStyles.callout : void 0;
    return React58.createElement(MenuContext.Consumer, null, function(menuContext) {
      return React58.createElement(
        Callout,
        __assign({ styles: calloutStyles_1, onRestoreFocus: tryFocusPreviousActiveElement }, calloutProps, { target: target || menuContext.target, isBeakVisible, beakWidth, directionalHint, directionalHintForRTL, gapSpace, coverTarget, doNotLayer, className: css("ms-ContextualMenu-Callout", calloutProps && calloutProps.className), setInitialFocus: shouldFocusOnMount, onDismiss: props.onDismiss || menuContext.onDismiss, onScroll, bounds, directionalHintFixed, alignTargetEdge, hidden: props.hidden || menuContext.hidden, ref: forwardedRef }),
        React58.createElement(
          "div",
          { style: contextMenuStyle, ref: hostElement, id, className: classNames2.container, tabIndex: shouldFocusOnContainer ? 0 : -1, onKeyDown: onMenuKeyDown, onKeyUp, onFocusCapture: onMenuFocusCapture, "aria-label": ariaLabel, "aria-labelledby": labelElementId, role: "menu" },
          title && React58.createElement(
            "div",
            { className: classNames2.title },
            " ",
            title,
            " "
          ),
          items && items.length ? renderFocusZone(onRenderMenuList({
            ariaLabel,
            items,
            totalItemCount: totalItemCount_1,
            hasCheckmarks,
            hasIcons,
            defaultMenuItemRenderer: function(item) {
              return defaultMenuItemRenderer(item, classNames2);
            },
            labelElementId
          }, function(menuListProps, defaultRender) {
            return onDefaultRenderMenuList(menuListProps, classNames2, defaultRender);
          }), adjustedFocusZoneProps) : null,
          submenuProps && onRenderSubMenu2(submenuProps, onDefaultRenderSubMenu)
        ),
        React58.createElement(FocusRects, null)
      );
    });
  } else {
    return null;
  }
}), function(prevProps, newProps) {
  if (!newProps.shouldUpdateWhenHidden && prevProps.hidden && newProps.hidden) {
    return true;
  }
  return shallowCompare(prevProps, newProps);
});
ContextualMenuBase.displayName = "ContextualMenuBase";
function isAltOrMeta(ev) {
  return ev.which === KeyCodes.alt || ev.key === "Meta";
}
function onItemMouseDown(item, ev) {
  var _a7;
  (_a7 = item.onMouseDown) === null || _a7 === void 0 ? void 0 : _a7.call(item, item, ev);
}
function onDefaultRenderSubMenu(subMenuProps, defaultRender) {
  throw Error("ContextualMenuBase: onRenderSubMenu callback is null or undefined. Please ensure to set `onRenderSubMenu` property either manually or with `styled` helper.");
}
function findItemByKeyFromItems(key, items) {
  for (var _i = 0, items_3 = items; _i < items_3.length; _i++) {
    var item = items_3[_i];
    if (item.itemType === ContextualMenuItemType.Section && item.sectionProps) {
      var match = findItemByKeyFromItems(key, item.sectionProps.items);
      if (match) {
        return match;
      }
    } else if (item.key && item.key === key) {
      return item;
    }
  }
}
function getOnClickWithOverrideTarget(onClick, target) {
  return onClick ? function(ev, item) {
    overrideTarget(ev, target);
    return onClick(ev, item);
  } : onClick;
}
function overrideTarget(ev, target) {
  if (ev && target) {
    ev.persist();
    if (target instanceof Event) {
      ev.target = target.target;
    } else if (target instanceof Element) {
      ev.target = target;
    }
  }
}

// node_modules/@fluentui/react/lib/components/ContextualMenu/ContextualMenu.styles.js
var GlobalClassNames6 = {
  root: "ms-ContextualMenu",
  container: "ms-ContextualMenu-container",
  list: "ms-ContextualMenu-list",
  header: "ms-ContextualMenu-header",
  title: "ms-ContextualMenu-title",
  isopen: "is-open"
};
var getStyles7 = function(props) {
  var className = props.className, theme = props.theme;
  var classNames2 = getGlobalClassNames(GlobalClassNames6, theme);
  var fonts = theme.fonts, semanticColors = theme.semanticColors, effects = theme.effects;
  return {
    root: [
      theme.fonts.medium,
      classNames2.root,
      classNames2.isopen,
      {
        backgroundColor: semanticColors.menuBackground,
        minWidth: "180px"
      },
      className
    ],
    container: [
      classNames2.container,
      {
        selectors: {
          ":focus": { outline: 0 }
        }
      }
    ],
    list: [
      classNames2.list,
      classNames2.isopen,
      {
        listStyleType: "none",
        margin: "0",
        padding: "0"
      }
    ],
    header: [
      classNames2.header,
      fonts.small,
      {
        fontWeight: FontWeights.semibold,
        color: semanticColors.menuHeader,
        background: "none",
        backgroundColor: "transparent",
        border: "none",
        height: CONTEXTUAL_MENU_ITEM_HEIGHT,
        lineHeight: CONTEXTUAL_MENU_ITEM_HEIGHT,
        cursor: "default",
        padding: "0px 6px",
        userSelect: "none",
        textAlign: "left"
      }
    ],
    title: [
      classNames2.title,
      {
        fontSize: fonts.mediumPlus.fontSize,
        paddingRight: "14px",
        paddingLeft: "14px",
        paddingBottom: "5px",
        paddingTop: "5px",
        backgroundColor: semanticColors.menuItemBackgroundPressed
      }
    ],
    subComponentStyles: {
      callout: {
        root: {
          boxShadow: effects.elevation8
        }
      },
      menuItem: {}
    }
  };
};

// node_modules/@fluentui/react/lib/components/ContextualMenu/ContextualMenu.js
function onRenderSubMenu(subMenuProps) {
  return React59.createElement(LocalContextualMenu, __assign({}, subMenuProps));
}
var LocalContextualMenu = styled(ContextualMenuBase, getStyles7, function(props) {
  return {
    onRenderSubMenu: props.onRenderSubMenu ? composeRenderFunction(props.onRenderSubMenu, onRenderSubMenu) : onRenderSubMenu
  };
}, { scope: "ContextualMenu" });
var ContextualMenu = LocalContextualMenu;
ContextualMenu.displayName = "ContextualMenu";

// node_modules/@fluentui/react/lib/components/Button/BaseButton.classNames.js
var ButtonGlobalClassNames = {
  msButton: "ms-Button",
  msButtonHasMenu: "ms-Button--hasMenu",
  msButtonIcon: "ms-Button-icon",
  msButtonMenuIcon: "ms-Button-menuIcon",
  msButtonLabel: "ms-Button-label",
  msButtonDescription: "ms-Button-description",
  msButtonScreenReaderText: "ms-Button-screenReaderText",
  msButtonFlexContainer: "ms-Button-flexContainer",
  msButtonTextContainer: "ms-Button-textContainer"
};
var getBaseButtonClassNames = memoizeFunction(function(theme, styles, className, variantClassName, iconClassName, menuIconClassName, disabled, hasMenu, checked, expanded, isSplit) {
  var _a7, _b3;
  var classNames2 = getGlobalClassNames(ButtonGlobalClassNames, theme || {});
  var isExpanded = expanded && !isSplit;
  return mergeStyleSets({
    root: [
      classNames2.msButton,
      styles.root,
      variantClassName,
      checked && ["is-checked", styles.rootChecked],
      isExpanded && [
        "is-expanded",
        styles.rootExpanded,
        {
          selectors: (_a7 = {}, _a7[":hover .".concat(classNames2.msButtonIcon)] = styles.iconExpandedHovered, // menuIcon falls back to rootExpandedHovered to support original behavior
          _a7[":hover .".concat(classNames2.msButtonMenuIcon)] = styles.menuIconExpandedHovered || styles.rootExpandedHovered, _a7[":hover"] = styles.rootExpandedHovered, _a7)
        }
      ],
      hasMenu && [ButtonGlobalClassNames.msButtonHasMenu, styles.rootHasMenu],
      disabled && ["is-disabled", styles.rootDisabled],
      !disabled && !isExpanded && !checked && {
        selectors: (_b3 = {
          ":hover": styles.rootHovered
        }, _b3[":hover .".concat(classNames2.msButtonLabel)] = styles.labelHovered, _b3[":hover .".concat(classNames2.msButtonIcon)] = styles.iconHovered, _b3[":hover .".concat(classNames2.msButtonDescription)] = styles.descriptionHovered, _b3[":hover .".concat(classNames2.msButtonMenuIcon)] = styles.menuIconHovered, _b3[":focus"] = styles.rootFocused, _b3[":active"] = styles.rootPressed, _b3[":active .".concat(classNames2.msButtonIcon)] = styles.iconPressed, _b3[":active .".concat(classNames2.msButtonDescription)] = styles.descriptionPressed, _b3[":active .".concat(classNames2.msButtonMenuIcon)] = styles.menuIconPressed, _b3)
      },
      disabled && checked && [styles.rootCheckedDisabled],
      !disabled && checked && {
        selectors: {
          ":hover": styles.rootCheckedHovered,
          ":active": styles.rootCheckedPressed
        }
      },
      className
    ],
    flexContainer: [classNames2.msButtonFlexContainer, styles.flexContainer],
    textContainer: [classNames2.msButtonTextContainer, styles.textContainer],
    icon: [
      classNames2.msButtonIcon,
      iconClassName,
      styles.icon,
      isExpanded && styles.iconExpanded,
      checked && styles.iconChecked,
      disabled && styles.iconDisabled
    ],
    label: [classNames2.msButtonLabel, styles.label, checked && styles.labelChecked, disabled && styles.labelDisabled],
    menuIcon: [
      classNames2.msButtonMenuIcon,
      menuIconClassName,
      styles.menuIcon,
      checked && styles.menuIconChecked,
      disabled && !isSplit && styles.menuIconDisabled,
      !disabled && !isExpanded && !checked && {
        selectors: {
          ":hover": styles.menuIconHovered,
          ":active": styles.menuIconPressed
        }
      },
      isExpanded && ["is-expanded", styles.menuIconExpanded]
    ],
    description: [
      classNames2.msButtonDescription,
      styles.description,
      checked && styles.descriptionChecked,
      disabled && styles.descriptionDisabled
    ],
    screenReaderText: [classNames2.msButtonScreenReaderText, styles.screenReaderText]
  });
});

// node_modules/@fluentui/react/lib/components/Button/SplitButton/SplitButton.classNames.js
var getSplitButtonClassNames = memoizeFunction(function(styles, disabled, expanded, checked, primaryDisabled) {
  return {
    root: mergeStyles(styles.splitButtonMenuButton, expanded && [styles.splitButtonMenuButtonExpanded], disabled && [styles.splitButtonMenuButtonDisabled], checked && !disabled && [styles.splitButtonMenuButtonChecked], primaryDisabled && !disabled && [
      {
        selectors: {
          ":focus": styles.splitButtonMenuFocused
        }
      }
    ]),
    splitButtonContainer: mergeStyles(styles.splitButtonContainer, !disabled && checked && [
      styles.splitButtonContainerChecked,
      {
        selectors: {
          ":hover": styles.splitButtonContainerCheckedHovered
        }
      }
    ], !disabled && !checked && [
      {
        selectors: {
          ":hover": styles.splitButtonContainerHovered,
          ":focus": styles.splitButtonContainerFocused
        }
      }
    ], disabled && styles.splitButtonContainerDisabled),
    icon: mergeStyles(styles.splitButtonMenuIcon, disabled && styles.splitButtonMenuIconDisabled, !disabled && primaryDisabled && styles.splitButtonMenuIcon),
    flexContainer: mergeStyles(styles.splitButtonFlexContainer),
    divider: mergeStyles(styles.splitButtonDivider, (primaryDisabled || disabled) && styles.splitButtonDividerDisabled)
  };
});

// node_modules/@fluentui/react/lib/components/Button/BaseButton.js
var TouchIdleDelay2 = 500;
var COMPONENT_NAME4 = "BaseButton";
var BaseButton = (
  /** @class */
  function(_super) {
    __extends(BaseButton2, _super);
    function BaseButton2(props) {
      var _this = _super.call(this, props) || this;
      _this._buttonElement = React60.createRef();
      _this._splitButtonContainer = React60.createRef();
      _this._mergedRef = createMergedRef();
      _this._renderedVisibleMenu = false;
      _this._getMemoizedMenuButtonKeytipProps = memoizeFunction(function(keytipProps) {
        return __assign(__assign({}, keytipProps), { hasMenu: true });
      });
      _this._onRenderIcon = function(buttonProps, defaultRender) {
        var iconProps = _this.props.iconProps;
        if (iconProps && (iconProps.iconName !== void 0 || iconProps.imageProps)) {
          var className = iconProps.className, imageProps = iconProps.imageProps, rest = __rest(iconProps, ["className", "imageProps"]);
          if (iconProps.styles) {
            return React60.createElement(Icon, __assign({ className: css(_this._classNames.icon, className), imageProps }, rest));
          }
          if (iconProps.iconName) {
            return React60.createElement(FontIcon, __assign({ className: css(_this._classNames.icon, className) }, rest));
          }
          if (imageProps) {
            return React60.createElement(ImageIcon, __assign({ className: css(_this._classNames.icon, className), imageProps }, rest));
          }
        }
        return null;
      };
      _this._onRenderTextContents = function() {
        var _a7 = _this.props, text = _a7.text, children = _a7.children, _b3 = _a7.secondaryText, secondaryText = _b3 === void 0 ? _this.props.description : _b3, _c3 = _a7.onRenderText, onRenderText = _c3 === void 0 ? _this._onRenderText : _c3, _d3 = _a7.onRenderDescription, onRenderDescription = _d3 === void 0 ? _this._onRenderDescription : _d3;
        if (text || typeof children === "string" || secondaryText) {
          return React60.createElement(
            "span",
            { className: _this._classNames.textContainer },
            onRenderText(_this.props, _this._onRenderText),
            onRenderDescription(_this.props, _this._onRenderDescription)
          );
        }
        return [onRenderText(_this.props, _this._onRenderText), onRenderDescription(_this.props, _this._onRenderDescription)];
      };
      _this._onRenderText = function() {
        var text = _this.props.text;
        var children = _this.props.children;
        if (text === void 0 && typeof children === "string") {
          text = children;
        }
        if (_this._hasText()) {
          return React60.createElement("span", { key: _this._labelId, className: _this._classNames.label, id: _this._labelId }, text);
        }
        return null;
      };
      _this._onRenderChildren = function() {
        var children = _this.props.children;
        if (typeof children === "string") {
          return null;
        }
        return children;
      };
      _this._onRenderDescription = function(props2) {
        var _a7 = props2.secondaryText, secondaryText = _a7 === void 0 ? _this.props.description : _a7;
        return secondaryText ? React60.createElement("span", { key: _this._descriptionId, className: _this._classNames.description, id: _this._descriptionId }, secondaryText) : null;
      };
      _this._onRenderAriaDescription = function() {
        var ariaDescription = _this.props.ariaDescription;
        return ariaDescription ? React60.createElement("span", { className: _this._classNames.screenReaderText, id: _this._ariaDescriptionId }, ariaDescription) : null;
      };
      _this._onRenderMenuIcon = function(props2) {
        var menuIconProps = _this.props.menuIconProps;
        return React60.createElement(FontIcon, __assign({ iconName: "ChevronDown" }, menuIconProps, { className: _this._classNames.menuIcon }));
      };
      _this._onRenderMenu = function(menuProps) {
        var MenuType = _this.props.menuAs ? composeComponentAs(_this.props.menuAs, ContextualMenu) : ContextualMenu;
        return React60.createElement(MenuType, __assign({}, menuProps));
      };
      _this._onDismissMenu = function(ev) {
        var menuProps = _this.props.menuProps;
        if (menuProps && menuProps.onDismiss) {
          menuProps.onDismiss(ev);
        }
        if (!ev || !ev.defaultPrevented) {
          _this._dismissMenu();
        }
      };
      _this._dismissMenu = function() {
        _this._menuShouldFocusOnMount = void 0;
        _this._menuShouldFocusOnContainer = void 0;
        _this.setState({ menuHidden: true });
      };
      _this._openMenu = function(shouldFocusOnContainer, shouldFocusOnMount) {
        if (shouldFocusOnMount === void 0) {
          shouldFocusOnMount = true;
        }
        if (_this.props.menuProps) {
          _this._menuShouldFocusOnContainer = shouldFocusOnContainer;
          _this._menuShouldFocusOnMount = shouldFocusOnMount;
          _this._renderedVisibleMenu = true;
          _this.setState({ menuHidden: false });
        }
      };
      _this._onToggleMenu = function(shouldFocusOnContainer) {
        var shouldFocusOnMount = true;
        if (_this.props.menuProps && _this.props.menuProps.shouldFocusOnMount === false) {
          shouldFocusOnMount = false;
        }
        _this.state.menuHidden ? _this._openMenu(shouldFocusOnContainer, shouldFocusOnMount) : _this._dismissMenu();
      };
      _this._onSplitContainerFocusCapture = function(ev) {
        var container = _this._splitButtonContainer.current;
        if (!container || ev.target && portalContainsElement(ev.target, container)) {
          return;
        }
        container.focus();
      };
      _this._onSplitButtonPrimaryClick = function(ev) {
        if (!_this.state.menuHidden) {
          _this._dismissMenu();
        }
        var singleTouchTarget = _this._processingTouch && !_this.props.toggle;
        if (!singleTouchTarget && _this.props.onClick) {
          _this.props.onClick(ev);
        } else if (singleTouchTarget) {
          _this._onMenuClick(ev);
        }
      };
      _this._onKeyDown = function(ev) {
        if (_this.props.disabled && (ev.which === KeyCodes.enter || ev.which === KeyCodes.space)) {
          ev.preventDefault();
          ev.stopPropagation();
        } else if (!_this.props.disabled) {
          if (_this.props.menuProps) {
            _this._onMenuKeyDown(ev);
          } else if (_this.props.onKeyDown !== void 0) {
            _this.props.onKeyDown(ev);
          }
        }
      };
      _this._onKeyUp = function(ev) {
        if (!_this.props.disabled && _this.props.onKeyUp !== void 0) {
          _this.props.onKeyUp(ev);
        }
      };
      _this._onKeyPress = function(ev) {
        if (!_this.props.disabled && _this.props.onKeyPress !== void 0) {
          _this.props.onKeyPress(ev);
        }
      };
      _this._onMouseUp = function(ev) {
        if (!_this.props.disabled && _this.props.onMouseUp !== void 0) {
          _this.props.onMouseUp(ev);
        }
      };
      _this._onMouseDown = function(ev) {
        if (!_this.props.disabled && _this.props.onMouseDown !== void 0) {
          _this.props.onMouseDown(ev);
        }
      };
      _this._onClick = function(ev) {
        if (!_this.props.disabled) {
          if (_this.props.menuProps) {
            _this._onMenuClick(ev);
          } else if (_this.props.onClick !== void 0) {
            _this.props.onClick(ev);
          }
        }
      };
      _this._onSplitButtonContainerKeyDown = function(ev) {
        if (ev.which === KeyCodes.enter || ev.which === KeyCodes.space) {
          if (_this._buttonElement.current) {
            _this._buttonElement.current.click();
            ev.preventDefault();
            ev.stopPropagation();
          }
        } else {
          _this._onMenuKeyDown(ev);
        }
      };
      _this._onMenuKeyDown = function(ev) {
        var _a7;
        if (_this.props.disabled) {
          return;
        }
        if (_this.props.onKeyDown) {
          _this.props.onKeyDown(ev);
        }
        var isUp = ev.which === KeyCodes.up;
        var isDown = ev.which === KeyCodes.down;
        if (!ev.defaultPrevented && _this._isValidMenuOpenKey(ev)) {
          var onMenuClick = _this.props.onMenuClick;
          if (onMenuClick) {
            onMenuClick(ev, _this.props);
          }
          _this._onToggleMenu(false);
          ev.preventDefault();
          ev.stopPropagation();
        }
        if (ev.which === KeyCodes.enter || ev.which === KeyCodes.space) {
          setFocusVisibility(true, ev.target, (_a7 = _this.context) === null || _a7 === void 0 ? void 0 : _a7.registeredProviders);
        }
        if (!(ev.altKey || ev.metaKey) && (isUp || isDown)) {
          if (!_this.state.menuHidden && _this.props.menuProps) {
            var currentShouldFocusOnMount = _this._menuShouldFocusOnMount !== void 0 ? _this._menuShouldFocusOnMount : _this.props.menuProps.shouldFocusOnMount;
            if (!currentShouldFocusOnMount) {
              ev.preventDefault();
              ev.stopPropagation();
              _this._menuShouldFocusOnMount = true;
              _this.forceUpdate();
            }
          }
        }
      };
      _this._onTouchStart = function() {
        if (_this._isSplitButton && _this._splitButtonContainer.current && !("onpointerdown" in _this._splitButtonContainer.current)) {
          _this._handleTouchAndPointerEvent();
        }
      };
      _this._onMenuClick = function(ev) {
        var _a7 = _this.props, onMenuClick = _a7.onMenuClick, menuProps = _a7.menuProps;
        if (onMenuClick) {
          onMenuClick(ev, _this.props);
        }
        var shouldFocusOnContainer = typeof (menuProps === null || menuProps === void 0 ? void 0 : menuProps.shouldFocusOnContainer) === "boolean" ? menuProps.shouldFocusOnContainer : ev.nativeEvent.pointerType === "mouse";
        if (!ev.defaultPrevented) {
          _this._onToggleMenu(shouldFocusOnContainer);
          ev.preventDefault();
          ev.stopPropagation();
        }
      };
      initializeComponentRef(_this);
      _this._async = new Async(_this);
      _this._events = new EventGroup(_this);
      warnConditionallyRequiredProps(COMPONENT_NAME4, props, ["menuProps", "onClick"], "split", _this.props.split);
      warnDeprecations(COMPONENT_NAME4, props, {
        rootProps: void 0,
        description: "secondaryText",
        toggled: "checked"
      });
      _this._labelId = getId();
      _this._descriptionId = getId();
      _this._ariaDescriptionId = getId();
      _this.state = {
        menuHidden: true
      };
      return _this;
    }
    Object.defineProperty(BaseButton2.prototype, "_isSplitButton", {
      get: function() {
        return !!this.props.menuProps && !!this.props.onClick && this.props.split === true;
      },
      enumerable: false,
      configurable: true
    });
    BaseButton2.prototype.render = function() {
      var _a7;
      var _b3 = this.props, ariaDescription = _b3.ariaDescription, ariaLabel = _b3.ariaLabel, ariaHidden = _b3.ariaHidden, className = _b3.className, disabled = _b3.disabled, allowDisabledFocus = _b3.allowDisabledFocus, primaryDisabled = _b3.primaryDisabled, _c3 = _b3.secondaryText, secondaryText = _c3 === void 0 ? this.props.description : _c3, href = _b3.href, iconProps = _b3.iconProps, menuIconProps = _b3.menuIconProps, styles = _b3.styles, checked = _b3.checked, variantClassName = _b3.variantClassName, theme = _b3.theme, toggle = _b3.toggle, getClassNames13 = _b3.getClassNames, role = _b3.role;
      var menuHidden = this.state.menuHidden;
      var isPrimaryButtonDisabled = disabled || primaryDisabled;
      this._classNames = getClassNames13 ? getClassNames13(theme, className, variantClassName, iconProps && iconProps.className, menuIconProps && menuIconProps.className, isPrimaryButtonDisabled, checked, !menuHidden, !!this.props.menuProps, this.props.split, !!allowDisabledFocus) : getBaseButtonClassNames(theme, styles, className, variantClassName, iconProps && iconProps.className, menuIconProps && menuIconProps.className, isPrimaryButtonDisabled, !!this.props.menuProps, checked, !menuHidden, this.props.split);
      var _d3 = this, _ariaDescriptionId = _d3._ariaDescriptionId, _labelId = _d3._labelId, _descriptionId = _d3._descriptionId;
      var renderAsAnchor = !isPrimaryButtonDisabled && !!href;
      var tag = renderAsAnchor ? "a" : "button";
      var nativeProps = getNativeProps(
        // eslint-disable-next-line deprecation/deprecation
        assign(renderAsAnchor ? {} : { type: "button" }, this.props.rootProps, this.props),
        renderAsAnchor ? anchorProperties : buttonProperties,
        [
          "disabled"
          // let disabled buttons be focused and styled as disabled.
        ]
      );
      var resolvedAriaLabel = ariaLabel || nativeProps["aria-label"];
      var ariaDescribedBy = void 0;
      if (ariaDescription) {
        ariaDescribedBy = _ariaDescriptionId;
      } else if (secondaryText && this.props.onRenderDescription !== nullRender) {
        ariaDescribedBy = _descriptionId;
      } else if (nativeProps["aria-describedby"]) {
        ariaDescribedBy = nativeProps["aria-describedby"];
      }
      var ariaLabelledBy = void 0;
      if (nativeProps["aria-labelledby"]) {
        ariaLabelledBy = nativeProps["aria-labelledby"];
      } else if (ariaDescribedBy && !resolvedAriaLabel) {
        ariaLabelledBy = this._hasText() ? _labelId : void 0;
      }
      var dataIsFocusable = this.props["data-is-focusable"] === false || disabled && !allowDisabledFocus || this._isSplitButton ? false : true;
      var isCheckboxTypeRole = role === "menuitemcheckbox" || role === "checkbox";
      var checkedOrPressedValue = isCheckboxTypeRole ? !!checked : toggle === true ? !!checked : void 0;
      var buttonProps = assign(nativeProps, (_a7 = {
        className: this._classNames.root,
        // eslint-disable-next-line deprecation/deprecation
        ref: this._mergedRef(this.props.elementRef, this._buttonElement),
        disabled: isPrimaryButtonDisabled && !allowDisabledFocus,
        onKeyDown: this._onKeyDown,
        onKeyPress: this._onKeyPress,
        onKeyUp: this._onKeyUp,
        onMouseDown: this._onMouseDown,
        onMouseUp: this._onMouseUp,
        onClick: this._onClick,
        "aria-label": resolvedAriaLabel,
        "aria-labelledby": ariaLabelledBy,
        "aria-describedby": ariaDescribedBy,
        "aria-disabled": isPrimaryButtonDisabled,
        "data-is-focusable": dataIsFocusable
      }, // aria-pressed attribute should only be present for toggle buttons
      // aria-checked attribute should only be present for toggle buttons with checkbox type role
      _a7[isCheckboxTypeRole ? "aria-checked" : "aria-pressed"] = checkedOrPressedValue, _a7));
      if (ariaHidden) {
        buttonProps["aria-hidden"] = true;
      }
      if (this._isSplitButton) {
        return this._onRenderSplitButtonContent(tag, buttonProps);
      } else if (this.props.menuProps) {
        var _e2 = this.props.menuProps.id, id = _e2 === void 0 ? "".concat(this._labelId, "-menu") : _e2;
        assign(buttonProps, {
          "aria-expanded": !menuHidden,
          "aria-controls": !menuHidden ? id : null,
          "aria-haspopup": true
        });
      }
      return this._onRenderContent(tag, buttonProps);
    };
    BaseButton2.prototype.componentDidMount = function() {
      if (this._isSplitButton && this._splitButtonContainer.current) {
        if ("onpointerdown" in this._splitButtonContainer.current) {
          this._events.on(this._splitButtonContainer.current, "pointerdown", this._onPointerDown, true);
        }
        if ("onpointerup" in this._splitButtonContainer.current && this.props.onPointerUp) {
          this._events.on(this._splitButtonContainer.current, "pointerup", this.props.onPointerUp, true);
        }
      }
    };
    BaseButton2.prototype.componentDidUpdate = function(prevProps, prevState) {
      if (this.props.onAfterMenuDismiss && !prevState.menuHidden && this.state.menuHidden) {
        this.props.onAfterMenuDismiss();
      }
    };
    BaseButton2.prototype.componentWillUnmount = function() {
      this._async.dispose();
      this._events.dispose();
    };
    BaseButton2.prototype.focus = function() {
      var _a7, _b3;
      if (this._isSplitButton && this._splitButtonContainer.current) {
        setFocusVisibility(true, void 0, (_a7 = this.context) === null || _a7 === void 0 ? void 0 : _a7.registeredProviders);
        this._splitButtonContainer.current.focus();
      } else if (this._buttonElement.current) {
        setFocusVisibility(true, void 0, (_b3 = this.context) === null || _b3 === void 0 ? void 0 : _b3.registeredProviders);
        this._buttonElement.current.focus();
      }
    };
    BaseButton2.prototype.dismissMenu = function() {
      this._dismissMenu();
    };
    BaseButton2.prototype.openMenu = function(shouldFocusOnContainer, shouldFocusOnMount) {
      this._openMenu(shouldFocusOnContainer, shouldFocusOnMount);
    };
    BaseButton2.prototype._onRenderContent = function(tag, buttonProps) {
      var _this = this;
      var props = this.props;
      var Tag = tag;
      var menuIconProps = props.menuIconProps, menuProps = props.menuProps, _a7 = props.onRenderIcon, onRenderIcon = _a7 === void 0 ? this._onRenderIcon : _a7, _b3 = props.onRenderAriaDescription, onRenderAriaDescription = _b3 === void 0 ? this._onRenderAriaDescription : _b3, _c3 = props.onRenderChildren, onRenderChildren = _c3 === void 0 ? this._onRenderChildren : _c3, _d3 = props.onRenderMenu, onRenderMenu = _d3 === void 0 ? this._onRenderMenu : _d3, _e2 = props.onRenderMenuIcon, onRenderMenuIcon = _e2 === void 0 ? this._onRenderMenuIcon : _e2, disabled = props.disabled;
      var keytipProps = props.keytipProps;
      if (keytipProps && menuProps) {
        keytipProps = this._getMemoizedMenuButtonKeytipProps(keytipProps);
      }
      var Button2 = function(keytipAttributes) {
        return React60.createElement(
          Tag,
          __assign({}, buttonProps, keytipAttributes),
          React60.createElement(
            "span",
            { className: _this._classNames.flexContainer, "data-automationid": "splitbuttonprimary" },
            onRenderIcon(props, _this._onRenderIcon),
            _this._onRenderTextContents(),
            onRenderAriaDescription(props, _this._onRenderAriaDescription),
            onRenderChildren(props, _this._onRenderChildren),
            !_this._isSplitButton && (menuProps || menuIconProps || _this.props.onRenderMenuIcon) && onRenderMenuIcon(_this.props, _this._onRenderMenuIcon),
            menuProps && !menuProps.doNotLayer && _this._shouldRenderMenu() && onRenderMenu(_this._getMenuProps(menuProps), _this._onRenderMenu)
          )
        );
      };
      var Content = keytipProps ? (
        // If we're making a split button, we won't put the keytip here
        React60.createElement(KeytipData, { keytipProps: !this._isSplitButton ? keytipProps : void 0, ariaDescribedBy: buttonProps["aria-describedby"], disabled }, function(keytipAttributes) {
          return Button2(keytipAttributes);
        })
      ) : Button2();
      if (menuProps && menuProps.doNotLayer) {
        return React60.createElement(
          React60.Fragment,
          null,
          Content,
          this._shouldRenderMenu() && onRenderMenu(this._getMenuProps(menuProps), this._onRenderMenu)
        );
      }
      return React60.createElement(
        React60.Fragment,
        null,
        Content,
        React60.createElement(FocusRects, null)
      );
    };
    BaseButton2.prototype._shouldRenderMenu = function() {
      var menuHidden = this.state.menuHidden;
      var _a7 = this.props, persistMenu = _a7.persistMenu, renderPersistedMenuHiddenOnMount = _a7.renderPersistedMenuHiddenOnMount;
      if (!menuHidden) {
        return true;
      } else if (persistMenu && (this._renderedVisibleMenu || renderPersistedMenuHiddenOnMount)) {
        return true;
      }
      return false;
    };
    BaseButton2.prototype._hasText = function() {
      return this.props.text !== null && (this.props.text !== void 0 || typeof this.props.children === "string");
    };
    BaseButton2.prototype._getMenuProps = function(menuProps) {
      var persistMenu = this.props.persistMenu;
      var menuHidden = this.state.menuHidden;
      if (!menuProps.ariaLabel && !menuProps.labelElementId && this._hasText()) {
        menuProps = __assign(__assign({}, menuProps), { labelElementId: this._labelId });
      }
      return __assign(__assign({ id: this._labelId + "-menu", directionalHint: DirectionalHint.bottomLeftEdge }, menuProps), { shouldFocusOnContainer: this._menuShouldFocusOnContainer, shouldFocusOnMount: this._menuShouldFocusOnMount, hidden: persistMenu ? menuHidden : void 0, className: css("ms-BaseButton-menuhost", menuProps.className), target: this._isSplitButton ? this._splitButtonContainer.current : this._buttonElement.current, onDismiss: this._onDismissMenu });
    };
    BaseButton2.prototype._onRenderSplitButtonContent = function(tag, buttonProps) {
      var _this = this;
      var _a7 = this.props, _b3 = _a7.styles, styles = _b3 === void 0 ? {} : _b3, disabled = _a7.disabled, allowDisabledFocus = _a7.allowDisabledFocus, checked = _a7.checked, getSplitButtonClassNames2 = _a7.getSplitButtonClassNames, primaryDisabled = _a7.primaryDisabled, menuProps = _a7.menuProps, toggle = _a7.toggle, role = _a7.role, primaryActionButtonProps = _a7.primaryActionButtonProps;
      var keytipProps = this.props.keytipProps;
      var menuHidden = this.state.menuHidden;
      var classNames2 = getSplitButtonClassNames2 ? getSplitButtonClassNames2(!!disabled, !menuHidden, !!checked, !!allowDisabledFocus) : styles && getSplitButtonClassNames(styles, !!disabled, !menuHidden, !!checked, !!primaryDisabled);
      assign(buttonProps, {
        onClick: void 0,
        onPointerDown: void 0,
        onPointerUp: void 0,
        tabIndex: -1,
        "data-is-focusable": false
      });
      if (keytipProps && menuProps) {
        keytipProps = this._getMemoizedMenuButtonKeytipProps(keytipProps);
      }
      var containerProps = getNativeProps(buttonProps, [], ["disabled"]);
      if (primaryActionButtonProps) {
        assign(buttonProps, primaryActionButtonProps);
      }
      var SplitButton = function(keytipAttributes) {
        return React60.createElement(
          "div",
          __assign({}, containerProps, { "data-ktp-target": keytipAttributes ? keytipAttributes["data-ktp-target"] : void 0, role: role ? role : "button", "aria-disabled": disabled, "aria-haspopup": true, "aria-expanded": !menuHidden, "aria-pressed": toggle ? !!checked : void 0, "aria-describedby": mergeAriaAttributeValues(buttonProps["aria-describedby"], keytipAttributes ? keytipAttributes["aria-describedby"] : void 0), className: classNames2 && classNames2.splitButtonContainer, onKeyDown: _this._onSplitButtonContainerKeyDown, onTouchStart: _this._onTouchStart, ref: _this._splitButtonContainer, "data-is-focusable": true, onClick: !disabled && !primaryDisabled ? _this._onSplitButtonPrimaryClick : void 0, tabIndex: !disabled && !primaryDisabled || allowDisabledFocus ? 0 : void 0, "aria-roledescription": buttonProps["aria-roledescription"], onFocusCapture: _this._onSplitContainerFocusCapture }),
          React60.createElement(
            "span",
            { style: { display: "flex", width: "100%" } },
            _this._onRenderContent(tag, buttonProps),
            _this._onRenderSplitButtonMenuButton(classNames2, keytipAttributes),
            _this._onRenderSplitButtonDivider(classNames2)
          )
        );
      };
      return keytipProps ? React60.createElement(KeytipData, { keytipProps, disabled }, function(keytipAttributes) {
        return SplitButton(keytipAttributes);
      }) : SplitButton();
    };
    BaseButton2.prototype._onRenderSplitButtonDivider = function(classNames2) {
      if (classNames2 && classNames2.divider) {
        var onClick = function(ev) {
          ev.stopPropagation();
        };
        return React60.createElement("span", { className: classNames2.divider, "aria-hidden": true, onClick });
      }
      return null;
    };
    BaseButton2.prototype._onRenderSplitButtonMenuButton = function(classNames2, keytipAttributes) {
      var _a7 = this.props, allowDisabledFocus = _a7.allowDisabledFocus, checked = _a7.checked, disabled = _a7.disabled, splitButtonMenuProps = _a7.splitButtonMenuProps, splitButtonAriaLabel = _a7.splitButtonAriaLabel, primaryDisabled = _a7.primaryDisabled;
      var menuHidden = this.state.menuHidden;
      var menuIconProps = this.props.menuIconProps;
      if (menuIconProps === void 0) {
        menuIconProps = {
          iconName: "ChevronDown"
        };
      }
      var splitButtonProps = __assign(__assign({}, splitButtonMenuProps), { styles: classNames2, checked, disabled, allowDisabledFocus, onClick: this._onMenuClick, menuProps: void 0, iconProps: __assign(__assign({}, menuIconProps), { className: this._classNames.menuIcon }), ariaLabel: splitButtonAriaLabel, "aria-haspopup": true, "aria-expanded": !menuHidden, "data-is-focusable": false });
      return React60.createElement(BaseButton2, __assign({}, splitButtonProps, { "data-ktp-execute-target": keytipAttributes ? keytipAttributes["data-ktp-execute-target"] : keytipAttributes, onMouseDown: this._onMouseDown, tabIndex: primaryDisabled && !allowDisabledFocus ? 0 : -1 }));
    };
    BaseButton2.prototype._onPointerDown = function(ev) {
      var onPointerDown = this.props.onPointerDown;
      if (onPointerDown) {
        onPointerDown(ev);
      }
      if (ev.pointerType === "touch") {
        this._handleTouchAndPointerEvent();
        ev.preventDefault();
        ev.stopImmediatePropagation();
      }
    };
    BaseButton2.prototype._handleTouchAndPointerEvent = function() {
      var _this = this;
      if (this._lastTouchTimeoutId !== void 0) {
        this._async.clearTimeout(this._lastTouchTimeoutId);
        this._lastTouchTimeoutId = void 0;
      }
      this._processingTouch = true;
      this._lastTouchTimeoutId = this._async.setTimeout(function() {
        _this._processingTouch = false;
        _this._lastTouchTimeoutId = void 0;
        if (_this.state.menuHidden) {
          _this.focus();
        }
      }, TouchIdleDelay2);
    };
    BaseButton2.prototype._isValidMenuOpenKey = function(ev) {
      if (this.props.menuTriggerKeyCode) {
        return ev.which === this.props.menuTriggerKeyCode;
      } else if (this.props.menuProps) {
        return ev.which === KeyCodes.down && (ev.altKey || ev.metaKey);
      }
      return false;
    };
    BaseButton2.defaultProps = {
      baseClassName: "ms-Button",
      styles: {},
      split: false
    };
    BaseButton2.contextType = FocusRectsContext;
    return BaseButton2;
  }(React60.Component)
);

// node_modules/@fluentui/react/lib/components/Button/Button.types.js
var ElementType;
(function(ElementType2) {
  ElementType2[ElementType2["button"] = 0] = "button";
  ElementType2[ElementType2["anchor"] = 1] = "anchor";
})(ElementType || (ElementType = {}));
var ButtonType;
(function(ButtonType2) {
  ButtonType2[ButtonType2["normal"] = 0] = "normal";
  ButtonType2[ButtonType2["primary"] = 1] = "primary";
  ButtonType2[ButtonType2["hero"] = 2] = "hero";
  ButtonType2[ButtonType2["compound"] = 3] = "compound";
  ButtonType2[ButtonType2["command"] = 4] = "command";
  ButtonType2[ButtonType2["icon"] = 5] = "icon";
  ButtonType2[ButtonType2["default"] = 6] = "default";
})(ButtonType || (ButtonType = {}));

// node_modules/@fluentui/react/lib/components/Button/Button.js
var React66 = __toESM(require_react());

// node_modules/@fluentui/react/lib/components/Button/DefaultButton/DefaultButton.js
var React61 = __toESM(require_react());

// node_modules/@fluentui/react/lib/components/Button/BaseButton.styles.js
var noOutline = {
  outline: 0
};
var iconStyle = function(fontSize) {
  return {
    fontSize,
    margin: "0 4px",
    height: "16px",
    lineHeight: "16px",
    textAlign: "center",
    flexShrink: 0
  };
};
var getStyles8 = memoizeFunction(function(theme) {
  var _a7, _b3;
  var semanticColors = theme.semanticColors, effects = theme.effects, fonts = theme.fonts;
  var border = semanticColors.buttonBorder;
  var disabledBackground = semanticColors.disabledBackground;
  var disabledText = semanticColors.disabledText;
  var buttonHighContrastFocus = {
    left: -2,
    top: -2,
    bottom: -2,
    right: -2,
    outlineColor: "ButtonText"
  };
  return {
    root: [
      getFocusStyle(theme, { inset: 1, highContrastStyle: buttonHighContrastFocus, borderColor: "transparent" }),
      theme.fonts.medium,
      {
        border: "1px solid " + border,
        borderRadius: effects.roundedCorner2,
        boxSizing: "border-box",
        cursor: "pointer",
        display: "inline-block",
        padding: "0 16px",
        textDecoration: "none",
        textAlign: "center",
        userSelect: "none",
        selectors: {
          // IE11 workaround for preventing shift of child elements of a button when active.
          ":active > span": {
            position: "relative",
            left: 0,
            top: 0
          }
        }
      }
    ],
    rootDisabled: [
      getFocusStyle(theme, { inset: 1, highContrastStyle: buttonHighContrastFocus, borderColor: "transparent" }),
      {
        backgroundColor: disabledBackground,
        borderColor: disabledBackground,
        color: disabledText,
        cursor: "default",
        selectors: {
          ":hover": noOutline,
          ":focus": noOutline
        }
      }
    ],
    iconDisabled: {
      color: disabledText,
      selectors: (_a7 = {}, _a7[HighContrastSelector] = {
        color: "GrayText"
      }, _a7)
    },
    menuIconDisabled: {
      color: disabledText,
      selectors: (_b3 = {}, _b3[HighContrastSelector] = {
        color: "GrayText"
      }, _b3)
    },
    flexContainer: {
      display: "flex",
      height: "100%",
      flexWrap: "nowrap",
      justifyContent: "center",
      alignItems: "center"
    },
    description: {
      display: "block"
    },
    textContainer: {
      flexGrow: 1,
      display: "block"
    },
    icon: iconStyle(fonts.mediumPlus.fontSize),
    menuIcon: iconStyle(fonts.small.fontSize),
    label: {
      margin: "0 4px",
      lineHeight: "100%",
      display: "block"
    },
    screenReaderText: hiddenContentStyle
  };
});

// node_modules/@fluentui/react/lib/components/Button/SplitButton/SplitButton.styles.js
var getStyles9 = memoizeFunction(function(theme, customStyles) {
  var _a7, _b3, _c3, _d3, _e2, _f, _g, _h, _j, _k, _l, _m, _o;
  var effects = theme.effects, palette = theme.palette, semanticColors = theme.semanticColors;
  var buttonHighContrastFocus = {
    left: -2,
    top: -2,
    bottom: -2,
    right: -2,
    border: "none"
  };
  var splitButtonDividerBaseStyles2 = {
    position: "absolute",
    width: 1,
    right: 31,
    top: 8,
    bottom: 8
  };
  var splitButtonStyles = {
    splitButtonContainer: [
      getFocusStyle(theme, { highContrastStyle: buttonHighContrastFocus, inset: 2, pointerEvents: "none" }),
      {
        display: "inline-flex",
        selectors: {
          ".ms-Button--default": {
            borderTopRightRadius: "0",
            borderBottomRightRadius: "0",
            borderRight: "none",
            flexGrow: "1"
          },
          ".ms-Button--primary": {
            borderTopRightRadius: "0",
            borderBottomRightRadius: "0",
            border: "none",
            flexGrow: "1",
            selectors: (_a7 = {}, _a7[HighContrastSelector] = __assign({ color: "WindowText", backgroundColor: "Window", border: "1px solid WindowText", borderRightWidth: "0" }, getHighContrastNoAdjustStyle()), _a7[":hover"] = {
              border: "none"
            }, _a7[":active"] = {
              border: "none"
            }, _a7)
          },
          ".ms-Button--primary + .ms-Button": {
            border: "none",
            selectors: (_b3 = {}, _b3[HighContrastSelector] = {
              border: "1px solid WindowText",
              borderLeftWidth: "0"
            }, _b3)
          }
        }
      }
    ],
    splitButtonContainerHovered: {
      selectors: {
        ".ms-Button--primary": {
          selectors: (_c3 = {}, _c3[HighContrastSelector] = {
            color: "Window",
            backgroundColor: "Highlight"
          }, _c3)
        },
        ".ms-Button.is-disabled": {
          color: semanticColors.buttonTextDisabled,
          selectors: (_d3 = {}, _d3[HighContrastSelector] = {
            color: "GrayText",
            borderColor: "GrayText",
            backgroundColor: "Window"
          }, _d3)
        }
      }
    },
    splitButtonContainerChecked: {
      selectors: {
        ".ms-Button--primary": {
          selectors: (_e2 = {}, _e2[HighContrastSelector] = __assign({ color: "Window", backgroundColor: "WindowText" }, getHighContrastNoAdjustStyle()), _e2)
        }
      }
    },
    splitButtonContainerCheckedHovered: {
      selectors: {
        ".ms-Button--primary": {
          selectors: (_f = {}, _f[HighContrastSelector] = __assign({ color: "Window", backgroundColor: "WindowText" }, getHighContrastNoAdjustStyle()), _f)
        }
      }
    },
    splitButtonContainerFocused: {
      outline: "none!important"
    },
    splitButtonMenuButton: (_g = {
      padding: 6,
      height: "auto",
      boxSizing: "border-box",
      borderRadius: 0,
      borderTopRightRadius: effects.roundedCorner2,
      borderBottomRightRadius: effects.roundedCorner2,
      border: "1px solid ".concat(palette.neutralSecondaryAlt),
      borderLeft: "none",
      outline: "transparent",
      userSelect: "none",
      display: "inline-block",
      textDecoration: "none",
      textAlign: "center",
      cursor: "pointer",
      verticalAlign: "top",
      width: 32,
      marginLeft: -1,
      marginTop: 0,
      marginRight: 0,
      marginBottom: 0
    }, _g[HighContrastSelector] = {
      ".ms-Button-menuIcon": {
        color: "WindowText"
      }
    }, _g),
    splitButtonDivider: __assign(__assign({}, splitButtonDividerBaseStyles2), { selectors: (_h = {}, _h[HighContrastSelector] = {
      backgroundColor: "WindowText"
    }, _h) }),
    splitButtonDividerDisabled: __assign(__assign({}, splitButtonDividerBaseStyles2), { selectors: (_j = {}, _j[HighContrastSelector] = {
      backgroundColor: "GrayText"
    }, _j) }),
    splitButtonMenuButtonDisabled: {
      pointerEvents: "none",
      border: "none",
      selectors: (_k = {
        ":hover": {
          cursor: "default"
        },
        ".ms-Button--primary": {
          selectors: (_l = {}, _l[HighContrastSelector] = {
            color: "GrayText",
            borderColor: "GrayText",
            backgroundColor: "Window"
          }, _l)
        },
        ".ms-Button-menuIcon": {
          selectors: (_m = {}, _m[HighContrastSelector] = {
            color: "GrayText"
          }, _m)
        }
      }, _k[HighContrastSelector] = {
        color: "GrayText",
        border: "1px solid GrayText",
        backgroundColor: "Window"
      }, _k)
    },
    splitButtonFlexContainer: {
      display: "flex",
      height: "100%",
      flexWrap: "nowrap",
      justifyContent: "center",
      alignItems: "center"
    },
    splitButtonContainerDisabled: {
      outline: "none",
      border: "none",
      selectors: (_o = {}, _o[HighContrastSelector] = __assign({ color: "GrayText", borderColor: "GrayText", backgroundColor: "Window" }, getHighContrastNoAdjustStyle()), _o)
    },
    splitButtonMenuFocused: __assign({}, getFocusStyle(theme, { highContrastStyle: buttonHighContrastFocus, inset: 2 }))
  };
  return concatStyleSets(splitButtonStyles, customStyles);
});

// node_modules/@fluentui/react/lib/components/Button/ButtonThemes.js
var splitButtonDividerBaseStyles = function() {
  return {
    position: "absolute",
    width: 1,
    right: 31,
    top: 8,
    bottom: 8
  };
};
function standardStyles(theme) {
  var _a7, _b3, _c3, _d3, _e2;
  var s = theme.semanticColors, p = theme.palette;
  var buttonBackground = s.buttonBackground;
  var buttonBackgroundPressed = s.buttonBackgroundPressed;
  var buttonBackgroundHovered = s.buttonBackgroundHovered;
  var buttonBackgroundDisabled = s.buttonBackgroundDisabled;
  var buttonText = s.buttonText;
  var buttonTextHovered = s.buttonTextHovered;
  var buttonTextDisabled = s.buttonTextDisabled;
  var buttonTextChecked = s.buttonTextChecked;
  var buttonTextCheckedHovered = s.buttonTextCheckedHovered;
  return {
    root: {
      backgroundColor: buttonBackground,
      color: buttonText
    },
    rootHovered: {
      backgroundColor: buttonBackgroundHovered,
      color: buttonTextHovered,
      selectors: (_a7 = {}, _a7[HighContrastSelector] = {
        borderColor: "Highlight",
        color: "Highlight"
      }, _a7)
    },
    rootPressed: {
      backgroundColor: buttonBackgroundPressed,
      color: buttonTextChecked
    },
    rootExpanded: {
      backgroundColor: buttonBackgroundPressed,
      color: buttonTextChecked
    },
    rootChecked: {
      backgroundColor: buttonBackgroundPressed,
      color: buttonTextChecked
    },
    rootCheckedHovered: {
      backgroundColor: buttonBackgroundPressed,
      color: buttonTextCheckedHovered
    },
    rootDisabled: {
      color: buttonTextDisabled,
      backgroundColor: buttonBackgroundDisabled,
      selectors: (_b3 = {}, _b3[HighContrastSelector] = {
        color: "GrayText",
        borderColor: "GrayText",
        backgroundColor: "Window"
      }, _b3)
    },
    // Split button styles
    splitButtonContainer: {
      selectors: (_c3 = {}, _c3[HighContrastSelector] = {
        border: "none"
      }, _c3)
    },
    splitButtonMenuButton: {
      color: p.white,
      backgroundColor: "transparent",
      selectors: {
        ":hover": {
          backgroundColor: p.neutralLight,
          selectors: (_d3 = {}, _d3[HighContrastSelector] = {
            color: "Highlight"
          }, _d3)
        }
      }
    },
    splitButtonMenuButtonDisabled: {
      backgroundColor: s.buttonBackgroundDisabled,
      selectors: {
        ":hover": {
          backgroundColor: s.buttonBackgroundDisabled
        }
      }
    },
    splitButtonDivider: __assign(__assign({}, splitButtonDividerBaseStyles()), { backgroundColor: p.neutralTertiaryAlt, selectors: (_e2 = {}, _e2[HighContrastSelector] = {
      backgroundColor: "WindowText"
    }, _e2) }),
    splitButtonDividerDisabled: {
      backgroundColor: theme.palette.neutralTertiaryAlt
    },
    splitButtonMenuButtonChecked: {
      backgroundColor: p.neutralQuaternaryAlt,
      selectors: {
        ":hover": {
          backgroundColor: p.neutralQuaternaryAlt
        }
      }
    },
    splitButtonMenuButtonExpanded: {
      backgroundColor: p.neutralQuaternaryAlt,
      selectors: {
        ":hover": {
          backgroundColor: p.neutralQuaternaryAlt
        }
      }
    },
    splitButtonMenuIcon: {
      color: s.buttonText
    },
    splitButtonMenuIconDisabled: {
      color: s.buttonTextDisabled
    }
  };
}
function primaryStyles(theme) {
  var _a7, _b3, _c3, _d3, _e2, _f, _g, _h, _j;
  var p = theme.palette, s = theme.semanticColors;
  return {
    root: {
      backgroundColor: s.primaryButtonBackground,
      border: "1px solid ".concat(s.primaryButtonBackground),
      color: s.primaryButtonText,
      selectors: (_a7 = {}, _a7[HighContrastSelector] = __assign({ color: "Window", backgroundColor: "WindowText", borderColor: "WindowText" }, getHighContrastNoAdjustStyle()), _a7[".".concat(IsFocusVisibleClassName, " &:focus")] = {
        selectors: {
          ":after": {
            border: "none",
            outlineColor: p.white
          }
        }
      }, _a7)
    },
    rootHovered: {
      backgroundColor: s.primaryButtonBackgroundHovered,
      border: "1px solid ".concat(s.primaryButtonBackgroundHovered),
      color: s.primaryButtonTextHovered,
      selectors: (_b3 = {}, _b3[HighContrastSelector] = {
        color: "Window",
        backgroundColor: "Highlight",
        borderColor: "Highlight"
      }, _b3)
    },
    rootPressed: {
      backgroundColor: s.primaryButtonBackgroundPressed,
      border: "1px solid ".concat(s.primaryButtonBackgroundPressed),
      color: s.primaryButtonTextPressed,
      selectors: (_c3 = {}, _c3[HighContrastSelector] = __assign({ color: "Window", backgroundColor: "WindowText", borderColor: "WindowText" }, getHighContrastNoAdjustStyle()), _c3)
    },
    rootExpanded: {
      backgroundColor: s.primaryButtonBackgroundPressed,
      color: s.primaryButtonTextPressed
    },
    rootChecked: {
      backgroundColor: s.primaryButtonBackgroundPressed,
      color: s.primaryButtonTextPressed
    },
    rootCheckedHovered: {
      backgroundColor: s.primaryButtonBackgroundPressed,
      color: s.primaryButtonTextPressed
    },
    rootDisabled: {
      color: s.primaryButtonTextDisabled,
      backgroundColor: s.primaryButtonBackgroundDisabled,
      selectors: (_d3 = {}, _d3[HighContrastSelector] = {
        color: "GrayText",
        borderColor: "GrayText",
        backgroundColor: "Window"
      }, _d3)
    },
    // Split button styles
    splitButtonContainer: {
      selectors: (_e2 = {}, _e2[HighContrastSelector] = {
        border: "none"
      }, _e2)
    },
    splitButtonDivider: __assign(__assign({}, splitButtonDividerBaseStyles()), { backgroundColor: p.white, selectors: (_f = {}, _f[HighContrastSelector] = {
      backgroundColor: "Window"
    }, _f) }),
    splitButtonMenuButton: {
      backgroundColor: s.primaryButtonBackground,
      color: s.primaryButtonText,
      selectors: (_g = {}, _g[HighContrastSelector] = {
        backgroundColor: "Canvas"
      }, _g[":hover"] = {
        backgroundColor: s.primaryButtonBackgroundHovered,
        selectors: (_h = {}, _h[HighContrastSelector] = {
          color: "Highlight"
        }, _h)
      }, _g)
    },
    splitButtonMenuButtonDisabled: {
      backgroundColor: s.primaryButtonBackgroundDisabled,
      selectors: {
        ":hover": {
          backgroundColor: s.primaryButtonBackgroundDisabled
        }
      }
    },
    splitButtonMenuButtonChecked: {
      backgroundColor: s.primaryButtonBackgroundPressed,
      selectors: {
        ":hover": {
          backgroundColor: s.primaryButtonBackgroundPressed
        }
      }
    },
    splitButtonMenuButtonExpanded: {
      backgroundColor: s.primaryButtonBackgroundPressed,
      selectors: {
        ":hover": {
          backgroundColor: s.primaryButtonBackgroundPressed
        }
      }
    },
    splitButtonMenuIcon: {
      color: s.primaryButtonText
    },
    splitButtonMenuIconDisabled: {
      color: p.neutralTertiary,
      selectors: (_j = {}, _j[HighContrastSelector] = {
        color: "GrayText"
      }, _j)
    }
  };
}

// node_modules/@fluentui/react/lib/components/Button/DefaultButton/DefaultButton.styles.js
var DEFAULT_BUTTON_HEIGHT = "32px";
var DEFAULT_BUTTON_MIN_WIDTH = "80px";
var getStyles10 = memoizeFunction(function(theme, customStyles, primary) {
  var baseButtonStyles = getStyles8(theme);
  var splitButtonStyles = getStyles9(theme);
  var defaultButtonStyles = {
    root: {
      minWidth: DEFAULT_BUTTON_MIN_WIDTH,
      height: DEFAULT_BUTTON_HEIGHT
    },
    label: {
      fontWeight: FontWeights.semibold
    }
  };
  return concatStyleSets(baseButtonStyles, defaultButtonStyles, primary ? primaryStyles(theme) : standardStyles(theme), splitButtonStyles, customStyles);
});

// node_modules/@fluentui/react/lib/components/Button/DefaultButton/DefaultButton.js
var DefaultButton = (
  /** @class */
  function(_super) {
    __extends(DefaultButton2, _super);
    function DefaultButton2() {
      return _super !== null && _super.apply(this, arguments) || this;
    }
    DefaultButton2.prototype.render = function() {
      var _a7 = this.props, _b3 = _a7.primary, primary = _b3 === void 0 ? false : _b3, styles = _a7.styles, theme = _a7.theme;
      return React61.createElement(BaseButton, __assign({}, this.props, { variantClassName: primary ? "ms-Button--primary" : "ms-Button--default", styles: getStyles10(theme, styles, primary), onRenderDescription: nullRender }));
    };
    DefaultButton2 = __decorate([
      customizable("DefaultButton", ["theme", "styles"], true)
    ], DefaultButton2);
    return DefaultButton2;
  }(React61.Component)
);

// node_modules/@fluentui/react/lib/components/Button/ActionButton/ActionButton.js
var React62 = __toESM(require_react());

// node_modules/@fluentui/react/lib/components/Button/ActionButton/ActionButton.styles.js
var DEFAULT_BUTTON_HEIGHT2 = "40px";
var DEFAULT_PADDING = "0 4px";
var getStyles11 = memoizeFunction(function(theme, customStyles) {
  var _a7, _b3, _c3;
  var baseButtonStyles = getStyles8(theme);
  var actionButtonStyles = {
    root: {
      padding: DEFAULT_PADDING,
      height: DEFAULT_BUTTON_HEIGHT2,
      color: theme.palette.neutralPrimary,
      backgroundColor: "transparent",
      border: "1px solid transparent",
      selectors: (_a7 = {}, _a7[HighContrastSelector] = {
        borderColor: "Window"
      }, _a7)
    },
    rootHovered: {
      color: theme.palette.themePrimary,
      selectors: (_b3 = {}, _b3[HighContrastSelector] = {
        color: "Highlight"
      }, _b3)
    },
    iconHovered: {
      color: theme.palette.themePrimary
    },
    rootPressed: {
      color: theme.palette.black
    },
    rootExpanded: {
      color: theme.palette.themePrimary
    },
    iconPressed: {
      color: theme.palette.themeDarker
    },
    rootDisabled: {
      color: theme.palette.neutralTertiary,
      backgroundColor: "transparent",
      borderColor: "transparent",
      selectors: (_c3 = {}, _c3[HighContrastSelector] = {
        color: "GrayText"
      }, _c3)
    },
    rootChecked: {
      color: theme.palette.black
    },
    iconChecked: {
      color: theme.palette.themeDarker
    },
    flexContainer: {
      justifyContent: "flex-start"
    },
    icon: {
      color: theme.palette.themeDarkAlt
    },
    iconDisabled: {
      color: "inherit"
    },
    menuIcon: {
      color: theme.palette.neutralSecondary
    },
    textContainer: {
      flexGrow: 0
    }
  };
  return concatStyleSets(baseButtonStyles, actionButtonStyles, customStyles);
});

// node_modules/@fluentui/react/lib/components/Button/ActionButton/ActionButton.js
var ActionButton = (
  /** @class */
  function(_super) {
    __extends(ActionButton2, _super);
    function ActionButton2() {
      return _super !== null && _super.apply(this, arguments) || this;
    }
    ActionButton2.prototype.render = function() {
      var _a7 = this.props, styles = _a7.styles, theme = _a7.theme;
      return React62.createElement(BaseButton, __assign({}, this.props, { variantClassName: "ms-Button--action ms-Button--command", styles: getStyles11(theme, styles), onRenderDescription: nullRender }));
    };
    ActionButton2 = __decorate([
      customizable("ActionButton", ["theme", "styles"], true)
    ], ActionButton2);
    return ActionButton2;
  }(React62.Component)
);

// node_modules/@fluentui/react/lib/components/Button/CompoundButton/CompoundButton.js
var React63 = __toESM(require_react());

// node_modules/@fluentui/react/lib/components/Button/CompoundButton/CompoundButton.styles.js
var getStyles12 = memoizeFunction(function(theme, customStyles, primary) {
  var _a7, _b3, _c3, _d3, _e2;
  var fonts = theme.fonts, palette = theme.palette;
  var baseButtonStyles = getStyles8(theme);
  var splitButtonStyles = getStyles9(theme);
  var compoundButtonStyles = {
    root: {
      maxWidth: "280px",
      minHeight: "72px",
      height: "auto",
      padding: "16px 12px"
    },
    flexContainer: {
      flexDirection: "row",
      alignItems: "flex-start",
      minWidth: "100%",
      margin: ""
    },
    textContainer: {
      textAlign: "left"
    },
    icon: {
      fontSize: "2em",
      lineHeight: "1em",
      height: "1em",
      margin: "0px 8px 0px 0px",
      flexBasis: "1em",
      flexShrink: "0"
    },
    label: {
      margin: "0 0 5px",
      lineHeight: "100%",
      fontWeight: FontWeights.semibold
    },
    description: [
      fonts.small,
      {
        lineHeight: "100%"
      }
    ]
  };
  var standardCompoundTheme = {
    description: {
      color: palette.neutralSecondary
    },
    descriptionHovered: {
      color: palette.neutralDark
    },
    descriptionPressed: {
      color: "inherit"
    },
    descriptionChecked: {
      color: "inherit"
    },
    descriptionDisabled: {
      color: "inherit"
    }
  };
  var primaryCompoundTheme = {
    description: {
      color: palette.white,
      selectors: (_a7 = {}, _a7[HighContrastSelector] = __assign({ backgroundColor: "WindowText", color: "Window" }, getHighContrastNoAdjustStyle()), _a7)
    },
    descriptionHovered: {
      color: palette.white,
      selectors: (_b3 = {}, _b3[HighContrastSelector] = {
        backgroundColor: "Highlight",
        color: "Window"
      }, _b3)
    },
    descriptionPressed: {
      color: "inherit",
      selectors: (_c3 = {}, _c3[HighContrastSelector] = __assign({ color: "Window", backgroundColor: "WindowText" }, getHighContrastNoAdjustStyle()), _c3)
    },
    descriptionChecked: {
      color: "inherit",
      selectors: (_d3 = {}, _d3[HighContrastSelector] = __assign({ color: "Window", backgroundColor: "WindowText" }, getHighContrastNoAdjustStyle()), _d3)
    },
    descriptionDisabled: {
      color: "inherit",
      selectors: (_e2 = {}, _e2[HighContrastSelector] = {
        color: "inherit"
      }, _e2)
    }
  };
  return concatStyleSets(baseButtonStyles, compoundButtonStyles, primary ? primaryStyles(theme) : standardStyles(theme), primary ? primaryCompoundTheme : standardCompoundTheme, splitButtonStyles, customStyles);
});

// node_modules/@fluentui/react/lib/components/Button/CompoundButton/CompoundButton.js
var CompoundButton = (
  /** @class */
  function(_super) {
    __extends(CompoundButton2, _super);
    function CompoundButton2() {
      return _super !== null && _super.apply(this, arguments) || this;
    }
    CompoundButton2.prototype.render = function() {
      var _a7 = this.props, _b3 = _a7.primary, primary = _b3 === void 0 ? false : _b3, styles = _a7.styles, theme = _a7.theme;
      return React63.createElement(BaseButton, __assign({}, this.props, { variantClassName: primary ? "ms-Button--compoundPrimary" : "ms-Button--compound", styles: getStyles12(theme, styles, primary) }));
    };
    CompoundButton2 = __decorate([
      customizable("CompoundButton", ["theme", "styles"], true)
    ], CompoundButton2);
    return CompoundButton2;
  }(React63.Component)
);

// node_modules/@fluentui/react/lib/components/Button/IconButton/IconButton.js
var React64 = __toESM(require_react());

// node_modules/@fluentui/react/lib/components/Button/IconButton/IconButton.styles.js
var getStyles13 = memoizeFunction(function(theme, customStyles) {
  var _a7;
  var baseButtonStyles = getStyles8(theme);
  var splitButtonStyles = getStyles9(theme);
  var palette = theme.palette, semanticColors = theme.semanticColors;
  var iconButtonStyles = {
    root: {
      padding: "0 4px",
      width: "32px",
      height: "32px",
      backgroundColor: "transparent",
      border: "none",
      color: semanticColors.link
    },
    rootHovered: {
      color: palette.themeDarkAlt,
      backgroundColor: palette.neutralLighter,
      selectors: (_a7 = {}, _a7[HighContrastSelector] = {
        borderColor: "Highlight",
        color: "Highlight"
      }, _a7)
    },
    rootHasMenu: {
      width: "auto"
    },
    rootPressed: {
      color: palette.themeDark,
      backgroundColor: palette.neutralLight
    },
    rootExpanded: {
      color: palette.themeDark,
      backgroundColor: palette.neutralLight
    },
    rootChecked: {
      color: palette.themeDark,
      backgroundColor: palette.neutralLight
    },
    rootCheckedHovered: {
      color: palette.themeDark,
      backgroundColor: palette.neutralQuaternaryAlt
    },
    rootDisabled: {
      color: palette.neutralTertiaryAlt
    }
  };
  return concatStyleSets(baseButtonStyles, iconButtonStyles, splitButtonStyles, customStyles);
});

// node_modules/@fluentui/react/lib/components/Button/IconButton/IconButton.js
var IconButton = (
  /** @class */
  function(_super) {
    __extends(IconButton2, _super);
    function IconButton2() {
      return _super !== null && _super.apply(this, arguments) || this;
    }
    IconButton2.prototype.render = function() {
      var _a7 = this.props, styles = _a7.styles, theme = _a7.theme;
      return React64.createElement(BaseButton, __assign({}, this.props, { variantClassName: "ms-Button--icon", styles: getStyles13(theme, styles), onRenderText: nullRender, onRenderDescription: nullRender }));
    };
    IconButton2 = __decorate([
      customizable("IconButton", ["theme", "styles"], true)
    ], IconButton2);
    return IconButton2;
  }(React64.Component)
);

// node_modules/@fluentui/react/lib/components/Button/PrimaryButton/PrimaryButton.js
var React65 = __toESM(require_react());
var PrimaryButton = (
  /** @class */
  function(_super) {
    __extends(PrimaryButton2, _super);
    function PrimaryButton2() {
      return _super !== null && _super.apply(this, arguments) || this;
    }
    PrimaryButton2.prototype.render = function() {
      return React65.createElement(DefaultButton, __assign({}, this.props, { primary: true, onRenderDescription: nullRender }));
    };
    PrimaryButton2 = __decorate([
      customizable("PrimaryButton", ["theme", "styles"], true)
    ], PrimaryButton2);
    return PrimaryButton2;
  }(React65.Component)
);

// node_modules/@fluentui/react/lib/components/Button/Button.js
var Button = (
  /** @class */
  function(_super) {
    __extends(Button2, _super);
    function Button2(props) {
      var _this = _super.call(this, props) || this;
      warn("The Button component has been deprecated. Use specific variants instead. (PrimaryButton, DefaultButton, IconButton, ActionButton, etc.)");
      return _this;
    }
    Button2.prototype.render = function() {
      var props = this.props;
      switch (props.buttonType) {
        case ButtonType.command:
          return React66.createElement(ActionButton, __assign({}, props));
        case ButtonType.compound:
          return React66.createElement(CompoundButton, __assign({}, props));
        case ButtonType.icon:
          return React66.createElement(IconButton, __assign({}, props));
        case ButtonType.primary:
          return React66.createElement(PrimaryButton, __assign({}, props));
        default:
          return React66.createElement(DefaultButton, __assign({}, props));
      }
    };
    return Button2;
  }(React66.Component)
);

// node_modules/@fluentui/react/lib/components/Button/CommandBarButton/CommandBarButton.js
var React67 = __toESM(require_react());

// node_modules/@fluentui/react/lib/components/Button/CommandBarButton/CommandBarButton.styles.js
var getStyles14 = memoizeFunction(function(theme, customStyles, focusInset, focusColor) {
  var _a7, _b3, _c3, _d3, _e2, _f, _g, _h, _j, _k, _l, _m, _o;
  var baseButtonStyles = getStyles8(theme);
  var baseSplitButtonStyles = getStyles9(theme);
  var p = theme.palette, semanticColors = theme.semanticColors;
  var commandButtonHighContrastFocus = {
    left: 4,
    top: 4,
    bottom: 4,
    right: 4,
    border: "none"
  };
  var commandButtonStyles = {
    root: [
      getFocusStyle(theme, {
        inset: 2,
        highContrastStyle: commandButtonHighContrastFocus,
        borderColor: "transparent"
      }),
      theme.fonts.medium,
      {
        minWidth: "40px",
        backgroundColor: p.white,
        color: p.neutralPrimary,
        padding: "0 4px",
        border: "none",
        borderRadius: 0,
        selectors: (_a7 = {}, _a7[HighContrastSelector] = {
          border: "none"
        }, _a7)
      }
    ],
    rootHovered: {
      backgroundColor: p.neutralLighter,
      color: p.neutralDark,
      selectors: (_b3 = {}, _b3[HighContrastSelector] = {
        color: "Highlight"
      }, _b3[".".concat(ButtonGlobalClassNames.msButtonIcon)] = {
        color: p.themeDarkAlt
      }, _b3[".".concat(ButtonGlobalClassNames.msButtonMenuIcon)] = {
        color: p.neutralPrimary
      }, _b3)
    },
    rootPressed: {
      backgroundColor: p.neutralLight,
      color: p.neutralDark,
      selectors: (_c3 = {}, _c3[".".concat(ButtonGlobalClassNames.msButtonIcon)] = {
        color: p.themeDark
      }, _c3[".".concat(ButtonGlobalClassNames.msButtonMenuIcon)] = {
        color: p.neutralPrimary
      }, _c3)
    },
    rootChecked: {
      backgroundColor: p.neutralLight,
      color: p.neutralDark,
      selectors: (_d3 = {}, _d3[".".concat(ButtonGlobalClassNames.msButtonIcon)] = {
        color: p.themeDark
      }, _d3[".".concat(ButtonGlobalClassNames.msButtonMenuIcon)] = {
        color: p.neutralPrimary
      }, _d3)
    },
    rootCheckedHovered: {
      backgroundColor: p.neutralQuaternaryAlt,
      selectors: (_e2 = {}, _e2[".".concat(ButtonGlobalClassNames.msButtonIcon)] = {
        color: p.themeDark
      }, _e2[".".concat(ButtonGlobalClassNames.msButtonMenuIcon)] = {
        color: p.neutralPrimary
      }, _e2)
    },
    rootExpanded: {
      backgroundColor: p.neutralLight,
      color: p.neutralDark,
      selectors: (_f = {}, _f[".".concat(ButtonGlobalClassNames.msButtonIcon)] = {
        color: p.themeDark
      }, _f[".".concat(ButtonGlobalClassNames.msButtonMenuIcon)] = {
        color: p.neutralPrimary
      }, _f)
    },
    rootExpandedHovered: {
      backgroundColor: p.neutralQuaternaryAlt
    },
    rootDisabled: {
      backgroundColor: p.white,
      selectors: (_g = {}, _g[".".concat(ButtonGlobalClassNames.msButtonIcon)] = {
        color: semanticColors.disabledBodySubtext,
        selectors: (_h = {}, _h[HighContrastSelector] = __assign({ color: "GrayText" }, getHighContrastNoAdjustStyle()), _h)
      }, _g[HighContrastSelector] = __assign({ color: "GrayText", backgroundColor: "Window" }, getHighContrastNoAdjustStyle()), _g)
    },
    // Split button styles
    splitButtonContainer: {
      height: "100%",
      selectors: (_j = {}, _j[HighContrastSelector] = {
        border: "none"
      }, _j)
    },
    splitButtonDividerDisabled: {
      selectors: (_k = {}, _k[HighContrastSelector] = {
        backgroundColor: "Window"
      }, _k)
    },
    splitButtonDivider: {
      backgroundColor: p.neutralTertiaryAlt
    },
    splitButtonMenuButton: {
      backgroundColor: p.white,
      border: "none",
      borderTopRightRadius: "0",
      borderBottomRightRadius: "0",
      color: p.neutralSecondary,
      selectors: {
        ":hover": {
          backgroundColor: p.neutralLighter,
          color: p.neutralDark,
          selectors: (_l = {}, _l[HighContrastSelector] = {
            color: "Highlight"
          }, _l[".".concat(ButtonGlobalClassNames.msButtonIcon)] = {
            color: p.neutralPrimary
          }, _l)
        },
        ":active": {
          backgroundColor: p.neutralLight,
          selectors: (_m = {}, _m[".".concat(ButtonGlobalClassNames.msButtonIcon)] = {
            color: p.neutralPrimary
          }, _m)
        }
      }
    },
    splitButtonMenuButtonDisabled: {
      backgroundColor: p.white,
      selectors: (_o = {}, _o[HighContrastSelector] = __assign({ color: "GrayText", border: "none", backgroundColor: "Window" }, getHighContrastNoAdjustStyle()), _o)
    },
    splitButtonMenuButtonChecked: {
      backgroundColor: p.neutralLight,
      color: p.neutralDark,
      selectors: {
        ":hover": {
          backgroundColor: p.neutralQuaternaryAlt
        }
      }
    },
    splitButtonMenuButtonExpanded: {
      backgroundColor: p.neutralLight,
      color: p.black,
      selectors: {
        ":hover": {
          backgroundColor: p.neutralQuaternaryAlt
        }
      }
    },
    splitButtonMenuIcon: {
      color: p.neutralPrimary
    },
    splitButtonMenuIconDisabled: {
      color: p.neutralTertiary
    },
    label: {
      fontWeight: "normal"
      // theme.fontWeights.semibold,
    },
    icon: {
      color: p.themePrimary
    },
    menuIcon: {
      color: p.neutralSecondary
    }
  };
  return concatStyleSets(baseButtonStyles, baseSplitButtonStyles, commandButtonStyles, customStyles);
});

// node_modules/@fluentui/react/lib/components/Button/CommandBarButton/CommandBarButton.js
var CommandBarButton = (
  /** @class */
  function(_super) {
    __extends(CommandBarButton2, _super);
    function CommandBarButton2() {
      return _super !== null && _super.apply(this, arguments) || this;
    }
    CommandBarButton2.prototype.render = function() {
      var _a7 = this.props, styles = _a7.styles, theme = _a7.theme;
      return React67.createElement(BaseButton, __assign({}, this.props, { variantClassName: "ms-Button--commandBar", styles: getStyles14(theme, styles), onRenderDescription: nullRender }));
    };
    CommandBarButton2 = __decorate([
      customizable("CommandBarButton", ["theme", "styles"], true)
    ], CommandBarButton2);
    return CommandBarButton2;
  }(React67.Component)
);

// node_modules/@fluentui/react/lib/components/Button/CommandButton/CommandButton.js
var CommandButton = ActionButton;

// node_modules/@fluentui/react/lib/components/Button/MessageBarButton/MessageBarButton.js
var React68 = __toESM(require_react());

// node_modules/@fluentui/react/lib/components/Button/MessageBarButton/MessageBarButton.styles.js
var getStyles15 = memoizeFunction(function(theme, customStyles) {
  return concatStyleSets({
    root: [
      getFocusStyle(theme, {
        inset: 1,
        highContrastStyle: {
          outlineOffset: "-4px",
          outline: "1px solid Window"
        },
        borderColor: "transparent"
      }),
      {
        height: 24
      }
    ]
  }, customStyles);
});

// node_modules/@fluentui/react/lib/components/Button/MessageBarButton/MessageBarButton.js
var MessageBarButton = (
  /** @class */
  function(_super) {
    __extends(MessageBarButton2, _super);
    function MessageBarButton2() {
      return _super !== null && _super.apply(this, arguments) || this;
    }
    MessageBarButton2.prototype.render = function() {
      var _a7 = this.props, styles = _a7.styles, theme = _a7.theme;
      return React68.createElement(DefaultButton, __assign({}, this.props, { styles: getStyles15(theme, styles), onRenderDescription: nullRender }));
    };
    MessageBarButton2 = __decorate([
      customizable("MessageBarButton", ["theme", "styles"], true)
    ], MessageBarButton2);
    return MessageBarButton2;
  }(React68.Component)
);

// node_modules/@fluentui/react/lib/utilities/selectableOption/SelectableOption.js
function getAllSelectedOptions(options, selectedIndices) {
  var selectedOptions = [];
  for (var _i = 0, selectedIndices_1 = selectedIndices; _i < selectedIndices_1.length; _i++) {
    var index = selectedIndices_1[_i];
    var option = options[index];
    if (option) {
      selectedOptions.push(option);
    }
  }
  return selectedOptions;
}

// node_modules/@fluentui/react/lib/utilities/selectableOption/SelectableOption.types.js
var SelectableOptionMenuItemType;
(function(SelectableOptionMenuItemType2) {
  SelectableOptionMenuItemType2[SelectableOptionMenuItemType2["Normal"] = 0] = "Normal";
  SelectableOptionMenuItemType2[SelectableOptionMenuItemType2["Divider"] = 1] = "Divider";
  SelectableOptionMenuItemType2[SelectableOptionMenuItemType2["Header"] = 2] = "Header";
  SelectableOptionMenuItemType2[SelectableOptionMenuItemType2["SelectAll"] = 3] = "SelectAll";
})(SelectableOptionMenuItemType || (SelectableOptionMenuItemType = {}));

// node_modules/@fluentui/react/lib/components/Dropdown/utilities/DropdownSizePosCache.js
var DropdownSizePosCache = (
  /** @class */
  function() {
    function DropdownSizePosCache2() {
      this._size = 0;
    }
    DropdownSizePosCache2.prototype.updateOptions = function(options) {
      var displayOnlyOptionsCache = [];
      var notSelectableOptionsCache = [];
      var size = 0;
      for (var i = 0; i < options.length; i++) {
        var _a7 = options[i], itemType = _a7.itemType, hidden = _a7.hidden;
        if (itemType === SelectableOptionMenuItemType.Divider || itemType === SelectableOptionMenuItemType.Header) {
          displayOnlyOptionsCache.push(i);
          notSelectableOptionsCache.push(i);
        } else if (hidden) {
          notSelectableOptionsCache.push(i);
        } else {
          size++;
        }
      }
      this._size = size;
      this._displayOnlyOptionsCache = displayOnlyOptionsCache;
      this._notSelectableOptionsCache = notSelectableOptionsCache;
      this._cachedOptions = __spreadArray([], options, true);
    };
    Object.defineProperty(DropdownSizePosCache2.prototype, "optionSetSize", {
      /**
       * The size of all the selectable options.
       */
      get: function() {
        return this._size;
      },
      enumerable: false,
      configurable: true
    });
    Object.defineProperty(DropdownSizePosCache2.prototype, "cachedOptions", {
      /**
       * The chached options array.
       */
      get: function() {
        return this._cachedOptions;
      },
      enumerable: false,
      configurable: true
    });
    DropdownSizePosCache2.prototype.positionInSet = function(index) {
      if (index === void 0) {
        return void 0;
      }
      var offset = 0;
      while (index > this._notSelectableOptionsCache[offset]) {
        offset++;
      }
      if (this._displayOnlyOptionsCache[offset] === index) {
        throw new Error("Unexpected: Option at index ".concat(index, " is not a selectable element."));
      }
      if (this._notSelectableOptionsCache[offset] === index) {
        return void 0;
      }
      return index - offset + 1;
    };
    return DropdownSizePosCache2;
  }()
);

// node_modules/@fluentui/react/lib/components/Label/Label.base.js
var React69 = __toESM(require_react());
var getClassNames8 = classNamesFunction({
  // Label is used a lot by other components.
  // It's likely to see expected cases which pass different className to the Label.
  // Therefore setting a larger cache size.
  cacheSize: 100
});
var LabelBase = (
  /** @class */
  function(_super) {
    __extends(LabelBase2, _super);
    function LabelBase2() {
      return _super !== null && _super.apply(this, arguments) || this;
    }
    LabelBase2.prototype.render = function() {
      var _a7 = this.props, _b3 = _a7.as, RootType = _b3 === void 0 ? "label" : _b3, children = _a7.children, className = _a7.className, disabled = _a7.disabled, styles = _a7.styles, required = _a7.required, theme = _a7.theme;
      var classNames2 = getClassNames8(styles, {
        className,
        disabled,
        required,
        theme
      });
      return React69.createElement(RootType, __assign({}, getNativeProps(this.props, divProperties), { className: classNames2.root }), children);
    };
    return LabelBase2;
  }(React69.Component)
);

// node_modules/@fluentui/react/lib/components/Label/Label.styles.js
var getStyles16 = function(props) {
  var _a7;
  var theme = props.theme, className = props.className, disabled = props.disabled, required = props.required;
  var semanticColors = theme.semanticColors;
  var labelFontWeight = FontWeights.semibold;
  var labelColor = semanticColors.bodyText;
  var labelDisabledColor = semanticColors.disabledBodyText;
  var labelRequiredStarColor = semanticColors.errorText;
  return {
    root: [
      "ms-Label",
      theme.fonts.medium,
      {
        fontWeight: labelFontWeight,
        color: labelColor,
        boxSizing: "border-box",
        boxShadow: "none",
        margin: 0,
        display: "block",
        padding: "5px 0",
        wordWrap: "break-word",
        overflowWrap: "break-word"
      },
      disabled && {
        color: labelDisabledColor,
        selectors: (_a7 = {}, _a7[HighContrastSelector] = __assign({ color: "GrayText" }, getHighContrastNoAdjustStyle()), _a7)
      },
      required && {
        selectors: {
          "::after": {
            content: "' *'",
            color: labelRequiredStarColor,
            paddingRight: 12
          }
        }
      },
      className
    ]
  };
};

// node_modules/@fluentui/react/lib/components/Label/Label.js
var Label = styled(LabelBase, getStyles16, void 0, {
  scope: "Label"
});

// node_modules/@fluentui/react/lib/components/Panel/Panel.base.js
var React71 = __toESM(require_react());

// node_modules/@fluentui/react/lib/components/Overlay/Overlay.base.js
var React70 = __toESM(require_react());
var getClassNames9 = classNamesFunction();
var OverlayBase = (
  /** @class */
  function(_super) {
    __extends(OverlayBase2, _super);
    function OverlayBase2(props) {
      var _this = _super.call(this, props) || this;
      initializeComponentRef(_this);
      var _a7 = _this.props.allowTouchBodyScroll, allowTouchBodyScroll = _a7 === void 0 ? false : _a7;
      _this._allowTouchBodyScroll = allowTouchBodyScroll;
      return _this;
    }
    OverlayBase2.prototype.componentDidMount = function() {
      !this._allowTouchBodyScroll && disableBodyScroll();
    };
    OverlayBase2.prototype.componentWillUnmount = function() {
      !this._allowTouchBodyScroll && enableBodyScroll();
    };
    OverlayBase2.prototype.render = function() {
      var _a7 = this.props, isDark = _a7.isDarkThemed, className = _a7.className, theme = _a7.theme, styles = _a7.styles;
      var divProps = getNativeProps(this.props, divProperties);
      var classNames2 = getClassNames9(styles, {
        theme,
        className,
        isDark
      });
      return React70.createElement("div", __assign({}, divProps, { className: classNames2.root }));
    };
    return OverlayBase2;
  }(React70.Component)
);

// node_modules/@fluentui/react/lib/components/Overlay/Overlay.styles.js
var GlobalClassNames7 = {
  root: "ms-Overlay",
  rootDark: "ms-Overlay--dark"
};
var getStyles17 = function(props) {
  var _a7;
  var className = props.className, theme = props.theme, isNone = props.isNone, isDark = props.isDark;
  var palette = theme.palette;
  var classNames2 = getGlobalClassNames(GlobalClassNames7, theme);
  return {
    root: [
      classNames2.root,
      theme.fonts.medium,
      {
        backgroundColor: palette.whiteTranslucent40,
        top: 0,
        right: 0,
        bottom: 0,
        left: 0,
        position: "absolute",
        selectors: (_a7 = {}, _a7[HighContrastSelector] = {
          border: "1px solid WindowText",
          opacity: 0
        }, _a7)
      },
      isNone && {
        visibility: "hidden"
      },
      isDark && [
        classNames2.rootDark,
        {
          backgroundColor: palette.blackTranslucent40
        }
      ],
      className
    ]
  };
};

// node_modules/@fluentui/react/lib/components/Overlay/Overlay.js
var Overlay = styled(OverlayBase, getStyles17, void 0, {
  scope: "Overlay"
});

// node_modules/@fluentui/react/lib/components/Panel/Panel.types.js
var PanelType;
(function(PanelType2) {
  PanelType2[PanelType2["smallFluid"] = 0] = "smallFluid";
  PanelType2[PanelType2["smallFixedFar"] = 1] = "smallFixedFar";
  PanelType2[PanelType2["smallFixedNear"] = 2] = "smallFixedNear";
  PanelType2[PanelType2["medium"] = 3] = "medium";
  PanelType2[PanelType2["large"] = 4] = "large";
  PanelType2[PanelType2["largeFixed"] = 5] = "largeFixed";
  PanelType2[PanelType2["extraLarge"] = 6] = "extraLarge";
  PanelType2[PanelType2["custom"] = 7] = "custom";
  PanelType2[PanelType2["customNear"] = 8] = "customNear";
})(PanelType || (PanelType = {}));

// node_modules/@fluentui/react/lib/components/Panel/Panel.base.js
var getClassNames10 = classNamesFunction();
var COMPONENT_NAME5 = "Panel";
var PanelVisibilityState;
(function(PanelVisibilityState2) {
  PanelVisibilityState2[PanelVisibilityState2["closed"] = 0] = "closed";
  PanelVisibilityState2[PanelVisibilityState2["animatingOpen"] = 1] = "animatingOpen";
  PanelVisibilityState2[PanelVisibilityState2["open"] = 2] = "open";
  PanelVisibilityState2[PanelVisibilityState2["animatingClosed"] = 3] = "animatingClosed";
})(PanelVisibilityState || (PanelVisibilityState = {}));
var PanelBase = (
  /** @class */
  function(_super) {
    __extends(PanelBase2, _super);
    function PanelBase2(props) {
      var _this = _super.call(this, props) || this;
      _this._panel = React71.createRef();
      _this._animationCallback = null;
      _this._hasCustomNavigation = !!(_this.props.onRenderNavigation || _this.props.onRenderNavigationContent);
      _this.dismiss = function(ev) {
        if (_this.props.onDismiss && _this.isActive) {
          _this.props.onDismiss(ev);
        }
        if (!ev || ev && !ev.defaultPrevented) {
          _this.close();
        }
      };
      _this._allowScrollOnPanel = function(elt) {
        if (elt) {
          if (_this._allowTouchBodyScroll) {
            allowOverscrollOnElement(elt, _this._events);
          } else {
            allowScrollOnElement(elt, _this._events);
          }
        } else {
          _this._events.off(_this._scrollableContent);
        }
        _this._scrollableContent = elt;
      };
      _this._onRenderNavigation = function(props2) {
        if (!_this.props.onRenderNavigationContent && !_this.props.onRenderNavigation && !_this.props.hasCloseButton) {
          return null;
        }
        var _a8 = _this.props.onRenderNavigationContent, onRenderNavigationContent = _a8 === void 0 ? _this._onRenderNavigationContent : _a8;
        return React71.createElement("div", { className: _this._classNames.navigation }, onRenderNavigationContent(props2, _this._onRenderNavigationContent));
      };
      _this._onRenderNavigationContent = function(props2) {
        var _a8;
        var closeButtonAriaLabel = props2.closeButtonAriaLabel, hasCloseButton = props2.hasCloseButton, _b3 = props2.onRenderHeader, onRenderHeader = _b3 === void 0 ? _this._onRenderHeader : _b3;
        if (hasCloseButton) {
          var iconButtonStyles = (_a8 = _this._classNames.subComponentStyles) === null || _a8 === void 0 ? void 0 : _a8.closeButton();
          return React71.createElement(
            React71.Fragment,
            null,
            !_this._hasCustomNavigation && onRenderHeader(_this.props, _this._onRenderHeader, _this._headerTextId),
            React71.createElement(IconButton, { styles: iconButtonStyles, className: _this._classNames.closeButton, onClick: _this._onPanelClick, ariaLabel: closeButtonAriaLabel, title: closeButtonAriaLabel, "data-is-visible": true, iconProps: { iconName: "Cancel" } })
          );
        }
        return null;
      };
      _this._onRenderHeader = function(props2, defaultRender, headerTextId) {
        var headerText = props2.headerText, _a8 = props2.headerTextProps, headerTextProps = _a8 === void 0 ? {} : _a8;
        if (headerText) {
          return React71.createElement(
            "div",
            { className: _this._classNames.header },
            React71.createElement("div", __assign({ id: headerTextId, role: "heading", "aria-level": 1 }, headerTextProps, { className: css(_this._classNames.headerText, headerTextProps.className) }), headerText)
          );
        }
        return null;
      };
      _this._onRenderBody = function(props2) {
        return React71.createElement("div", { className: _this._classNames.content }, props2.children);
      };
      _this._onRenderFooter = function(props2) {
        var _a8 = _this.props.onRenderFooterContent, onRenderFooterContent = _a8 === void 0 ? null : _a8;
        if (onRenderFooterContent) {
          return React71.createElement(
            "div",
            { className: _this._classNames.footer },
            React71.createElement("div", { className: _this._classNames.footerInner }, onRenderFooterContent())
          );
        }
        return null;
      };
      _this._animateTo = function(newVisibilityState) {
        if (newVisibilityState === PanelVisibilityState.open && _this.props.onOpen) {
          _this.props.onOpen();
        }
        _this._animationCallback = _this._async.setTimeout(function() {
          _this.setState({ visibility: newVisibilityState });
          _this._onTransitionComplete(newVisibilityState);
        }, 200);
      };
      _this._clearExistingAnimationTimer = function() {
        if (_this._animationCallback !== null) {
          _this._async.clearTimeout(_this._animationCallback);
        }
      };
      _this._onPanelClick = function(ev) {
        _this.dismiss(ev);
      };
      _this._onTransitionComplete = function(newVisibilityState) {
        _this._updateFooterPosition();
        if (newVisibilityState === PanelVisibilityState.open && _this.props.onOpened) {
          _this.props.onOpened();
        }
        if (newVisibilityState === PanelVisibilityState.closed && _this.props.onDismissed) {
          _this.props.onDismissed();
        }
      };
      var _a7 = _this.props.allowTouchBodyScroll, allowTouchBodyScroll = _a7 === void 0 ? false : _a7;
      _this._allowTouchBodyScroll = allowTouchBodyScroll;
      initializeComponentRef(_this);
      warnDeprecations(COMPONENT_NAME5, props, {
        ignoreExternalFocusing: "focusTrapZoneProps",
        forceFocusInsideTrap: "focusTrapZoneProps",
        firstFocusableSelector: "focusTrapZoneProps"
      });
      _this.state = {
        isFooterSticky: false,
        // intentionally ignore props so animation takes place during componentDidMount
        visibility: PanelVisibilityState.closed,
        id: getId("Panel")
      };
      return _this;
    }
    PanelBase2.getDerivedStateFromProps = function(nextProps, prevState) {
      if (nextProps.isOpen === void 0) {
        return null;
      }
      if (nextProps.isOpen && (prevState.visibility === PanelVisibilityState.closed || prevState.visibility === PanelVisibilityState.animatingClosed)) {
        return { visibility: PanelVisibilityState.animatingOpen };
      }
      if (!nextProps.isOpen && (prevState.visibility === PanelVisibilityState.open || prevState.visibility === PanelVisibilityState.animatingOpen)) {
        return { visibility: PanelVisibilityState.animatingClosed };
      }
      return null;
    };
    PanelBase2.prototype.componentDidMount = function() {
      this._async = new Async(this);
      this._events = new EventGroup(this);
      var win = getWindowEx(this.context);
      var doc = getDocumentEx(this.context);
      this._events.on(win, "resize", this._updateFooterPosition);
      if (this._shouldListenForOuterClick(this.props)) {
        this._events.on(doc === null || doc === void 0 ? void 0 : doc.body, "mousedown", this._dismissOnOuterClick, true);
      }
      if (this.props.isOpen) {
        this.setState({ visibility: PanelVisibilityState.animatingOpen });
      }
    };
    PanelBase2.prototype.componentDidUpdate = function(previousProps, previousState) {
      var shouldListenOnOuterClick = this._shouldListenForOuterClick(this.props);
      var previousShouldListenOnOuterClick = this._shouldListenForOuterClick(previousProps);
      if (this.state.visibility !== previousState.visibility) {
        this._clearExistingAnimationTimer();
        if (this.state.visibility === PanelVisibilityState.animatingOpen) {
          this._animateTo(PanelVisibilityState.open);
        } else if (this.state.visibility === PanelVisibilityState.animatingClosed) {
          this._animateTo(PanelVisibilityState.closed);
        }
      }
      var doc = getDocumentEx(this.context);
      if (shouldListenOnOuterClick && !previousShouldListenOnOuterClick) {
        this._events.on(doc === null || doc === void 0 ? void 0 : doc.body, "mousedown", this._dismissOnOuterClick, true);
      } else if (!shouldListenOnOuterClick && previousShouldListenOnOuterClick) {
        this._events.off(doc === null || doc === void 0 ? void 0 : doc.body, "mousedown", this._dismissOnOuterClick, true);
      }
    };
    PanelBase2.prototype.componentWillUnmount = function() {
      this._async.dispose();
      this._events.dispose();
    };
    PanelBase2.prototype.render = function() {
      var _a7 = this.props, _b3 = _a7.className, className = _b3 === void 0 ? "" : _b3, elementToFocusOnDismiss = _a7.elementToFocusOnDismiss, firstFocusableSelector = _a7.firstFocusableSelector, focusTrapZoneProps = _a7.focusTrapZoneProps, forceFocusInsideTrap = _a7.forceFocusInsideTrap, hasCloseButton = _a7.hasCloseButton, headerText = _a7.headerText, _c3 = _a7.headerClassName, headerClassName = _c3 === void 0 ? "" : _c3, ignoreExternalFocusing = _a7.ignoreExternalFocusing, isBlocking = _a7.isBlocking, isFooterAtBottom = _a7.isFooterAtBottom, isLightDismiss = _a7.isLightDismiss, isHiddenOnDismiss = _a7.isHiddenOnDismiss, layerProps = _a7.layerProps, overlayProps = _a7.overlayProps, popupProps = _a7.popupProps, type = _a7.type, styles = _a7.styles, theme = _a7.theme, customWidth = _a7.customWidth, _d3 = _a7.onLightDismissClick, onLightDismissClick = _d3 === void 0 ? this._onPanelClick : _d3, _e2 = _a7.onRenderNavigation, onRenderNavigation = _e2 === void 0 ? this._onRenderNavigation : _e2, _f = _a7.onRenderHeader, onRenderHeader = _f === void 0 ? this._onRenderHeader : _f, _g = _a7.onRenderBody, onRenderBody = _g === void 0 ? this._onRenderBody : _g, _h = _a7.onRenderFooter, onRenderFooter = _h === void 0 ? this._onRenderFooter : _h;
      var _j = this.state, isFooterSticky = _j.isFooterSticky, visibility = _j.visibility, id = _j.id;
      var isLeft = type === PanelType.smallFixedNear || type === PanelType.customNear ? true : false;
      var isRTL = getRTL2(theme);
      var isOnRightSide = isRTL ? isLeft : !isLeft;
      var customWidthStyles = type === PanelType.custom || type === PanelType.customNear ? { width: customWidth } : {};
      var nativeProps = getNativeProps(this.props, divProperties);
      var isOpen = this.isActive;
      var isAnimating = visibility === PanelVisibilityState.animatingClosed || visibility === PanelVisibilityState.animatingOpen;
      this._headerTextId = headerText && id + "-headerText";
      if (!isOpen && !isAnimating && !isHiddenOnDismiss) {
        return null;
      }
      this._classNames = getClassNames10(styles, {
        theme,
        className,
        focusTrapZoneClassName: focusTrapZoneProps ? focusTrapZoneProps.className : void 0,
        hasCloseButton,
        headerClassName,
        isAnimating,
        isFooterSticky,
        isFooterAtBottom,
        isOnRightSide,
        isOpen,
        isHiddenOnDismiss,
        type,
        hasCustomNavigation: this._hasCustomNavigation
      });
      var _k = this, _classNames = _k._classNames, _allowTouchBodyScroll = _k._allowTouchBodyScroll;
      var overlay;
      if (isBlocking && isOpen) {
        overlay = React71.createElement(Overlay, __assign({ className: _classNames.overlay, isDarkThemed: false, onClick: isLightDismiss ? onLightDismissClick : void 0, allowTouchBodyScroll: _allowTouchBodyScroll }, overlayProps));
      }
      return React71.createElement(
        Layer,
        __assign({}, layerProps),
        React71.createElement(
          Popup,
          __assign({ role: "dialog", "aria-modal": isBlocking ? "true" : void 0, ariaLabelledBy: this._headerTextId ? this._headerTextId : void 0, onDismiss: this.dismiss, className: _classNames.hiddenPanel, enableAriaHiddenSiblings: isOpen ? true : false }, popupProps),
          React71.createElement(
            "div",
            __assign({ "aria-hidden": !isOpen && isAnimating }, nativeProps, { ref: this._panel, className: _classNames.root }),
            overlay,
            React71.createElement(
              FocusTrapZone,
              __assign({ ignoreExternalFocusing, forceFocusInsideTrap: !isBlocking || isHiddenOnDismiss && !isOpen ? false : forceFocusInsideTrap, firstFocusableSelector, isClickableOutsideFocusTrap: true }, focusTrapZoneProps, { className: _classNames.main, style: customWidthStyles, elementToFocusOnDismiss }),
              React71.createElement(
                "div",
                { className: _classNames.contentInner },
                React71.createElement(
                  "div",
                  { ref: this._allowScrollOnPanel, className: _classNames.scrollableContent, "data-is-scrollable": true },
                  React71.createElement("div", { className: _classNames.commands, "data-is-visible": true }, onRenderNavigation(this.props, this._onRenderNavigation)),
                  (this._hasCustomNavigation || !hasCloseButton) && onRenderHeader(this.props, this._onRenderHeader, this._headerTextId),
                  onRenderBody(this.props, this._onRenderBody),
                  onRenderFooter(this.props, this._onRenderFooter)
                )
              )
            )
          )
        )
      );
    };
    PanelBase2.prototype.open = function() {
      if (this.props.isOpen !== void 0) {
        return;
      }
      if (this.isActive) {
        return;
      }
      this.setState({ visibility: PanelVisibilityState.animatingOpen });
    };
    PanelBase2.prototype.close = function() {
      if (this.props.isOpen !== void 0) {
        return;
      }
      if (!this.isActive) {
        return;
      }
      this.setState({ visibility: PanelVisibilityState.animatingClosed });
    };
    Object.defineProperty(PanelBase2.prototype, "isActive", {
      /** isActive is true when panel is open or opening. */
      get: function() {
        return this.state.visibility === PanelVisibilityState.open || this.state.visibility === PanelVisibilityState.animatingOpen;
      },
      enumerable: false,
      configurable: true
    });
    PanelBase2.prototype._shouldListenForOuterClick = function(props) {
      return !!props.isBlocking && !!props.isOpen;
    };
    PanelBase2.prototype._updateFooterPosition = function() {
      var scrollableContent = this._scrollableContent;
      if (scrollableContent) {
        var height = scrollableContent.clientHeight;
        var innerHeight_1 = scrollableContent.scrollHeight;
        this.setState({
          isFooterSticky: height < innerHeight_1 ? true : false
        });
      }
    };
    PanelBase2.prototype._dismissOnOuterClick = function(ev) {
      var panel = this._panel.current;
      if (this.isActive && panel && !ev.defaultPrevented) {
        if (!elementContains(panel, ev.target)) {
          if (this.props.onOuterClick) {
            this.props.onOuterClick(ev);
          } else {
            this.dismiss(ev);
          }
        }
      }
    };
    PanelBase2.defaultProps = {
      isHiddenOnDismiss: false,
      isOpen: void 0,
      isBlocking: true,
      hasCloseButton: true,
      type: PanelType.smallFixedFar
    };
    PanelBase2.contextType = WindowContext;
    return PanelBase2;
  }(React71.Component)
);

// node_modules/@fluentui/react/lib/components/Panel/Panel.styles.js
var _a5;
var _b;
var _c;
var _d;
var _e;
var GlobalClassNames8 = {
  root: "ms-Panel",
  main: "ms-Panel-main",
  commands: "ms-Panel-commands",
  contentInner: "ms-Panel-contentInner",
  scrollableContent: "ms-Panel-scrollableContent",
  navigation: "ms-Panel-navigation",
  closeButton: "ms-Panel-closeButton ms-PanelAction-close",
  header: "ms-Panel-header",
  headerText: "ms-Panel-headerText",
  content: "ms-Panel-content",
  footer: "ms-Panel-footer",
  footerInner: "ms-Panel-footerInner",
  isOpen: "is-open",
  hasCloseButton: "ms-Panel--hasCloseButton",
  smallFluid: "ms-Panel--smFluid",
  smallFixedNear: "ms-Panel--smLeft",
  smallFixedFar: "ms-Panel--sm",
  medium: "ms-Panel--md",
  large: "ms-Panel--lg",
  largeFixed: "ms-Panel--fixed",
  extraLarge: "ms-Panel--xl",
  custom: "ms-Panel--custom",
  customNear: "ms-Panel--customLeft"
};
var panelWidth = {
  full: "100%",
  auto: "auto",
  xs: 272,
  sm: 340,
  md1: 592,
  md2: 644,
  lg: 940
};
var panelMargin = {
  auto: "auto",
  none: 0,
  md: 48,
  lg: 428,
  xl: 176
};
var smallPanelSelectors = (_a5 = {}, _a5["@media (min-width: ".concat(ScreenWidthMinMedium, "px)")] = {
  width: panelWidth.sm
}, _a5);
var mediumPanelSelectors = (_b = {}, _b["@media (min-width: ".concat(ScreenWidthMinLarge, "px)")] = {
  width: panelWidth.md1
}, _b["@media (min-width: ".concat(ScreenWidthMinXLarge, "px)")] = {
  width: panelWidth.md2
}, _b);
var largePanelSelectors = (_c = {}, _c["@media (min-width: ".concat(ScreenWidthMinUhfMobile, "px)")] = {
  left: panelMargin.md,
  width: panelWidth.auto
}, _c["@media (min-width: ".concat(ScreenWidthMinXXLarge, "px)")] = {
  left: panelMargin.lg
}, _c);
var largeFixedPanelSelectors = (_d = {}, _d["@media (min-width: ".concat(ScreenWidthMinXXLarge, "px)")] = {
  left: panelMargin.auto,
  width: panelWidth.lg
}, _d);
var extraLargePanelSelectors = (_e = {}, _e["@media (min-width: ".concat(ScreenWidthMinXXLarge, "px)")] = {
  left: panelMargin.xl
}, _e);
var getPanelBreakpoints = function(type) {
  var selectors;
  switch (type) {
    case PanelType.smallFixedFar:
      selectors = __assign({}, smallPanelSelectors);
      break;
    case PanelType.medium:
      selectors = __assign(__assign({}, smallPanelSelectors), mediumPanelSelectors);
      break;
    case PanelType.large:
      selectors = __assign(__assign(__assign({}, smallPanelSelectors), mediumPanelSelectors), largePanelSelectors);
      break;
    case PanelType.largeFixed:
      selectors = __assign(__assign(__assign(__assign({}, smallPanelSelectors), mediumPanelSelectors), largePanelSelectors), largeFixedPanelSelectors);
      break;
    case PanelType.extraLarge:
      selectors = __assign(__assign(__assign(__assign({}, smallPanelSelectors), mediumPanelSelectors), largePanelSelectors), extraLargePanelSelectors);
      break;
    default:
      break;
  }
  return selectors;
};
var commandBarHeight = "44px";
var sharedPaddingStyles = {
  paddingLeft: "24px",
  paddingRight: "24px"
};
var getStyles18 = function(props) {
  var _a7, _b3, _c3, _d3;
  var className = props.className, focusTrapZoneClassName = props.focusTrapZoneClassName, hasCloseButton = props.hasCloseButton, headerClassName = props.headerClassName, isAnimating = props.isAnimating, isFooterSticky = props.isFooterSticky, isFooterAtBottom = props.isFooterAtBottom, isOnRightSide = props.isOnRightSide, isOpen = props.isOpen, isHiddenOnDismiss = props.isHiddenOnDismiss, hasCustomNavigation = props.hasCustomNavigation, theme = props.theme, _e2 = props.type, type = _e2 === void 0 ? PanelType.smallFixedFar : _e2;
  var effects = theme.effects, fonts = theme.fonts, semanticColors = theme.semanticColors;
  var classNames2 = getGlobalClassNames(GlobalClassNames8, theme);
  var isCustomPanel = type === PanelType.custom || type === PanelType.customNear;
  return {
    root: [
      classNames2.root,
      theme.fonts.medium,
      isOpen && classNames2.isOpen,
      hasCloseButton && classNames2.hasCloseButton,
      {
        pointerEvents: "none",
        position: "absolute",
        top: 0,
        left: 0,
        right: 0,
        bottom: 0
      },
      isCustomPanel && isOnRightSide && classNames2.custom,
      isCustomPanel && !isOnRightSide && classNames2.customNear,
      className
    ],
    overlay: [
      {
        pointerEvents: "auto",
        cursor: "pointer"
      },
      isOpen && isAnimating && AnimationClassNames.fadeIn100,
      !isOpen && isAnimating && AnimationClassNames.fadeOut100
    ],
    hiddenPanel: [
      !isOpen && !isAnimating && isHiddenOnDismiss && {
        visibility: "hidden"
      }
    ],
    main: [
      classNames2.main,
      {
        backgroundColor: semanticColors.bodyBackground,
        boxShadow: effects.elevation64,
        pointerEvents: "auto",
        position: "absolute",
        display: "flex",
        flexDirection: "column",
        overflowX: "hidden",
        overflowY: "auto",
        WebkitOverflowScrolling: "touch",
        bottom: 0,
        top: 0,
        // left, right, width are overridden depending on the type of the Panel and the screen breakpoint.
        left: panelMargin.auto,
        right: panelMargin.none,
        width: panelWidth.full,
        selectors: __assign((_a7 = {}, _a7[HighContrastSelector] = {
          borderLeft: "3px solid ".concat(semanticColors.variantBorder),
          borderRight: "3px solid ".concat(semanticColors.variantBorder)
        }, _a7), getPanelBreakpoints(type))
      },
      type === PanelType.smallFluid && {
        left: panelMargin.none
      },
      type === PanelType.smallFixedNear && {
        left: panelMargin.none,
        right: panelMargin.auto,
        width: panelWidth.xs
      },
      type === PanelType.customNear && {
        right: "auto",
        left: 0
      },
      isCustomPanel && {
        maxWidth: "100vw"
      },
      isOpen && isAnimating && !isOnRightSide && AnimationClassNames.slideRightIn40,
      isOpen && isAnimating && isOnRightSide && AnimationClassNames.slideLeftIn40,
      !isOpen && isAnimating && !isOnRightSide && AnimationClassNames.slideLeftOut40,
      !isOpen && isAnimating && isOnRightSide && AnimationClassNames.slideRightOut40,
      focusTrapZoneClassName
    ],
    commands: [
      classNames2.commands,
      {
        // Ensures that the sticky header always has a background to prevent overlaps on scroll.
        backgroundColor: semanticColors.bodyBackground,
        paddingTop: 18,
        selectors: (_b3 = {}, _b3["@media (min-height: ".concat(ScreenWidthMinMedium, "px)")] = {
          position: "sticky",
          top: 0,
          zIndex: 1
        }, _b3)
      },
      hasCustomNavigation && {
        paddingTop: "inherit"
      }
    ],
    navigation: [
      classNames2.navigation,
      {
        display: "flex",
        justifyContent: "flex-end"
      },
      hasCustomNavigation && {
        height: commandBarHeight
      }
    ],
    contentInner: [
      classNames2.contentInner,
      {
        display: "flex",
        flexDirection: "column",
        flexGrow: 1,
        overflowY: "hidden"
      }
    ],
    header: [
      classNames2.header,
      sharedPaddingStyles,
      {
        alignSelf: "flex-start"
      },
      hasCloseButton && !hasCustomNavigation && {
        flexGrow: 1
      },
      hasCustomNavigation && {
        // Ensure that title doesn't shrink if screen is too small
        flexShrink: 0
      }
    ],
    headerText: [
      classNames2.headerText,
      fonts.xLarge,
      {
        color: semanticColors.bodyText,
        lineHeight: "27px",
        overflowWrap: "break-word",
        wordWrap: "break-word",
        wordBreak: "break-word",
        hyphens: "auto"
      },
      headerClassName
    ],
    scrollableContent: [
      classNames2.scrollableContent,
      {
        overflowY: "auto"
      },
      isFooterAtBottom && {
        flexGrow: 1,
        display: "inherit",
        flexDirection: "inherit"
      }
    ],
    content: [
      classNames2.content,
      sharedPaddingStyles,
      {
        paddingBottom: 20
      },
      isFooterAtBottom && {
        selectors: (_c3 = {}, _c3["@media (min-height: ".concat(ScreenWidthMinMedium, "px)")] = {
          flexGrow: 1
        }, _c3)
      }
    ],
    footer: [
      classNames2.footer,
      {
        // Ensure that footer doesn't shrink if screen is too small
        flexShrink: 0,
        borderTop: "1px solid transparent",
        transition: "opacity ".concat(AnimationVariables.durationValue3, " ").concat(AnimationVariables.easeFunction2),
        selectors: (_d3 = {}, _d3["@media (min-height: ".concat(ScreenWidthMinMedium, "px)")] = {
          position: "sticky",
          bottom: 0
        }, _d3)
      },
      isFooterSticky && {
        backgroundColor: semanticColors.bodyBackground,
        borderTopColor: semanticColors.variantBorder
      }
    ],
    footerInner: [
      classNames2.footerInner,
      sharedPaddingStyles,
      {
        paddingBottom: 16,
        paddingTop: 16
      }
    ],
    subComponentStyles: {
      closeButton: {
        root: [
          classNames2.closeButton,
          {
            marginRight: 14,
            color: theme.palette.neutralSecondary,
            fontSize: IconFontSizes.large
          },
          hasCustomNavigation && {
            marginRight: 0,
            height: "auto",
            width: "44px"
          }
        ],
        rootHovered: {
          color: theme.palette.neutralPrimary
        }
      }
    }
  };
};

// node_modules/@fluentui/react/lib/components/Panel/Panel.js
var Panel = styled(PanelBase, getStyles18, void 0, {
  scope: "Panel"
});

// node_modules/@fluentui/react/lib/components/Checkbox/Checkbox.base.js
var React72 = __toESM(require_react());
var getClassNames11 = classNamesFunction();
var CheckboxBase = React72.forwardRef(function(props, forwardedRef) {
  var disabled = props.disabled, required = props.required, inputProps = props.inputProps, name = props.name, ariaLabel = props.ariaLabel, ariaLabelledBy = props.ariaLabelledBy, ariaDescribedBy = props.ariaDescribedBy, ariaPositionInSet = props.ariaPositionInSet, ariaSetSize = props.ariaSetSize, title = props.title, checkmarkIconProps = props.checkmarkIconProps, styles = props.styles, theme = props.theme, className = props.className, _a7 = props.boxSide, boxSide = _a7 === void 0 ? "start" : _a7;
  var id = useId("checkbox-", props.id);
  var rootRef = React72.useRef(null);
  var mergedRootRefs = useMergedRefs(rootRef, forwardedRef);
  var inputRef = React72.useRef(null);
  var _b3 = useControllableValue(props.checked, props.defaultChecked, props.onChange), isChecked = _b3[0], setIsChecked = _b3[1];
  var _c3 = useControllableValue(props.indeterminate, props.defaultIndeterminate), isIndeterminate = _c3[0], setIsIndeterminate = _c3[1];
  useFocusRects(rootRef);
  useDebugWarning(props);
  var classNames2 = getClassNames11(styles, {
    theme,
    className,
    disabled,
    indeterminate: isIndeterminate,
    checked: isChecked,
    reversed: boxSide !== "start",
    isUsingCustomLabelRender: !!props.onRenderLabel
  });
  var onChange = React72.useCallback(function(event) {
    if (isIndeterminate) {
      setIsChecked(!!isChecked, event);
      setIsIndeterminate(false);
    } else {
      setIsChecked(!isChecked, event);
    }
  }, [setIsChecked, setIsIndeterminate, isIndeterminate, isChecked]);
  var defaultLabelRenderer = React72.useCallback(function(checkboxProps) {
    if (!checkboxProps) {
      return null;
    }
    return checkboxProps.label ? React72.createElement("span", { className: classNames2.text, title: checkboxProps.title }, checkboxProps.label) : null;
  }, [classNames2.text]);
  var setNativeIndeterminate = React72.useCallback(function(indeterminate) {
    if (!inputRef.current) {
      return;
    }
    var value = !!indeterminate;
    inputRef.current.indeterminate = value;
    setIsIndeterminate(value);
  }, [setIsIndeterminate]);
  useComponentRef2(props, isChecked, isIndeterminate, setNativeIndeterminate, inputRef);
  React72.useEffect(function() {
    return setNativeIndeterminate(isIndeterminate);
  }, [setNativeIndeterminate, isIndeterminate]);
  var onRenderLabel = props.onRenderLabel || defaultLabelRenderer;
  var ariaChecked = isIndeterminate ? "mixed" : void 0;
  var mergedInputProps = __assign(__assign({ className: classNames2.input, type: "checkbox" }, inputProps), { checked: !!isChecked, disabled, required, name, id, title, onChange, "aria-disabled": disabled, "aria-label": ariaLabel, "aria-labelledby": ariaLabelledBy, "aria-describedby": ariaDescribedBy, "aria-posinset": ariaPositionInSet, "aria-setsize": ariaSetSize, "aria-checked": ariaChecked });
  return React72.createElement(
    "div",
    { className: classNames2.root, title, ref: mergedRootRefs },
    React72.createElement("input", __assign({}, mergedInputProps, { ref: inputRef, title, "data-ktp-execute-target": true })),
    React72.createElement(
      "label",
      { className: classNames2.label, htmlFor: id },
      React72.createElement(
        "div",
        { className: classNames2.checkbox, "data-ktp-target": true },
        React72.createElement(Icon, __assign({ iconName: "CheckMark" }, checkmarkIconProps, { className: classNames2.checkmark }))
      ),
      onRenderLabel(props, defaultLabelRenderer)
    )
  );
});
CheckboxBase.displayName = "CheckboxBase";
function useDebugWarning(props) {
  if (true) {
    useWarnings({
      name: "Checkbox",
      props,
      mutuallyExclusive: {
        checked: "defaultChecked",
        indeterminate: "defaultIndeterminate"
      }
    });
  }
}
function useComponentRef2(props, isChecked, isIndeterminate, setIndeterminate, checkBoxRef) {
  React72.useImperativeHandle(props.componentRef, function() {
    return {
      get checked() {
        return !!isChecked;
      },
      get indeterminate() {
        return !!isIndeterminate;
      },
      set indeterminate(indeterminate) {
        setIndeterminate(indeterminate);
      },
      focus: function() {
        if (checkBoxRef.current) {
          checkBoxRef.current.focus();
        }
      }
    };
  }, [checkBoxRef, isChecked, isIndeterminate, setIndeterminate]);
}

// node_modules/@fluentui/react/lib/components/Checkbox/Checkbox.styles.js
var GlobalClassNames9 = {
  root: "ms-Checkbox",
  label: "ms-Checkbox-label",
  checkbox: "ms-Checkbox-checkbox",
  checkmark: "ms-Checkbox-checkmark",
  text: "ms-Checkbox-text"
};
var MS_CHECKBOX_LABEL_SIZE = "20px";
var MS_CHECKBOX_TRANSITION_DURATION = "200ms";
var MS_CHECKBOX_TRANSITION_TIMING = "cubic-bezier(.4, 0, .23, 1)";
var getStyles19 = function(props) {
  var _a7, _b3, _c3, _d3, _e2, _f, _g, _h, _j, _k, _l, _m, _o, _p, _q, _r, _s, _t;
  var className = props.className, theme = props.theme, reversed = props.reversed, checked = props.checked, disabled = props.disabled, isUsingCustomLabelRender = props.isUsingCustomLabelRender, indeterminate = props.indeterminate;
  var semanticColors = theme.semanticColors, effects = theme.effects, palette = theme.palette, fonts = theme.fonts;
  var classNames2 = getGlobalClassNames(GlobalClassNames9, theme);
  var checkmarkFontColor = semanticColors.inputForegroundChecked;
  var checkmarkFontColorHovered = palette.neutralSecondary;
  var checkboxBorderColor = palette.neutralPrimary;
  var checkboxBorderIndeterminateColor = semanticColors.inputBackgroundChecked;
  var checkboxBorderColorChecked = semanticColors.inputBackgroundChecked;
  var checkboxBorderColorDisabled = semanticColors.disabledBodySubtext;
  var checkboxBorderHoveredColor = semanticColors.inputBorderHovered;
  var checkboxBorderIndeterminateHoveredColor = semanticColors.inputBackgroundCheckedHovered;
  var checkboxBackgroundChecked = semanticColors.inputBackgroundChecked;
  var checkboxBackgroundCheckedHovered = semanticColors.inputBackgroundCheckedHovered;
  var checkboxBorderColorCheckedHovered = semanticColors.inputBackgroundCheckedHovered;
  var checkboxHoveredTextColor = semanticColors.inputTextHovered;
  var checkboxBackgroundDisabledChecked = semanticColors.disabledBodySubtext;
  var checkboxTextColor = semanticColors.bodyText;
  var checkboxTextColorDisabled = semanticColors.disabledText;
  var indeterminateDotStyles = [
    (_a7 = {
      content: '""',
      borderRadius: effects.roundedCorner2,
      position: "absolute",
      width: 10,
      height: 10,
      top: 4,
      left: 4,
      boxSizing: "border-box",
      borderWidth: 5,
      borderStyle: "solid",
      borderColor: disabled ? checkboxBorderColorDisabled : checkboxBorderIndeterminateColor,
      transitionProperty: "border-width, border, border-color",
      transitionDuration: MS_CHECKBOX_TRANSITION_DURATION,
      transitionTimingFunction: MS_CHECKBOX_TRANSITION_TIMING
    }, _a7[HighContrastSelector] = {
      borderColor: "WindowText"
    }, _a7)
  ];
  return {
    root: [
      classNames2.root,
      {
        position: "relative",
        display: "flex"
      },
      reversed && "reversed",
      checked && "is-checked",
      !disabled && "is-enabled",
      disabled && "is-disabled",
      !disabled && [
        !checked && (_b3 = {}, _b3[":hover .".concat(classNames2.checkbox)] = (_c3 = {
          borderColor: checkboxBorderHoveredColor
        }, _c3[HighContrastSelector] = {
          borderColor: "Highlight"
        }, _c3), _b3[":focus .".concat(classNames2.checkbox)] = { borderColor: checkboxBorderHoveredColor }, _b3[":hover .".concat(classNames2.checkmark)] = (_d3 = {
          color: checkmarkFontColorHovered,
          opacity: "1"
        }, _d3[HighContrastSelector] = {
          color: "Highlight"
        }, _d3), _b3),
        checked && !indeterminate && (_e2 = {}, _e2[":hover .".concat(classNames2.checkbox)] = {
          background: checkboxBackgroundCheckedHovered,
          borderColor: checkboxBorderColorCheckedHovered
        }, _e2[":focus .".concat(classNames2.checkbox)] = {
          background: checkboxBackgroundCheckedHovered,
          borderColor: checkboxBorderColorCheckedHovered
        }, _e2[HighContrastSelector] = (_f = {}, _f[":hover .".concat(classNames2.checkbox)] = {
          background: "Highlight",
          borderColor: "Highlight"
        }, _f[":focus .".concat(classNames2.checkbox)] = {
          background: "Highlight"
        }, _f[":focus:hover .".concat(classNames2.checkbox)] = {
          background: "Highlight"
        }, _f[":focus:hover .".concat(classNames2.checkmark)] = {
          color: "Window"
        }, _f[":hover .".concat(classNames2.checkmark)] = {
          color: "Window"
        }, _f), _e2),
        indeterminate && (_g = {}, _g[":hover .".concat(classNames2.checkbox, ", :hover .").concat(classNames2.checkbox, ":after")] = (_h = {
          borderColor: checkboxBorderIndeterminateHoveredColor
        }, _h[HighContrastSelector] = {
          borderColor: "WindowText"
        }, _h), _g[":focus .".concat(classNames2.checkbox)] = {
          borderColor: checkboxBorderIndeterminateHoveredColor
        }, _g[":hover .".concat(classNames2.checkmark)] = {
          opacity: "0"
        }, _g),
        (_j = {}, _j[":hover .".concat(classNames2.text, ", :focus .").concat(classNames2.text)] = (_k = {
          color: checkboxHoveredTextColor
        }, _k[HighContrastSelector] = {
          color: disabled ? "GrayText" : "WindowText"
        }, _k), _j)
      ],
      className
    ],
    input: (_l = {
      position: "absolute",
      background: "none",
      opacity: 0
    }, _l[".".concat(IsFocusVisibleClassName, " &:focus + label::before")] = (_m = {
      outline: "1px solid " + theme.palette.neutralSecondary,
      outlineOffset: "2px"
    }, _m[HighContrastSelector] = {
      outline: "1px solid WindowText"
    }, _m), _l),
    label: [
      classNames2.label,
      theme.fonts.medium,
      {
        display: "flex",
        alignItems: isUsingCustomLabelRender ? "center" : "flex-start",
        cursor: disabled ? "default" : "pointer",
        position: "relative",
        userSelect: "none"
      },
      reversed && {
        flexDirection: "row-reverse",
        justifyContent: "flex-end"
      },
      {
        "&::before": {
          position: "absolute",
          left: 0,
          right: 0,
          top: 0,
          bottom: 0,
          content: '""',
          pointerEvents: "none"
        }
      }
    ],
    checkbox: [
      classNames2.checkbox,
      (_o = {
        position: "relative",
        display: "flex",
        flexShrink: 0,
        alignItems: "center",
        justifyContent: "center",
        height: MS_CHECKBOX_LABEL_SIZE,
        width: MS_CHECKBOX_LABEL_SIZE,
        border: "1px solid ".concat(checkboxBorderColor),
        borderRadius: effects.roundedCorner2,
        boxSizing: "border-box",
        transitionProperty: "background, border, border-color",
        transitionDuration: MS_CHECKBOX_TRANSITION_DURATION,
        transitionTimingFunction: MS_CHECKBOX_TRANSITION_TIMING,
        /* in case the icon is bigger than the box */
        overflow: "hidden",
        ":after": indeterminate ? indeterminateDotStyles : null
      }, _o[HighContrastSelector] = __assign({ borderColor: "WindowText" }, getHighContrastNoAdjustStyle()), _o),
      indeterminate && {
        borderColor: checkboxBorderIndeterminateColor
      },
      !reversed ? (
        // This margin on the checkbox is for backwards compat. Notably it has the effect where a customRender
        // is used, there will be only a 4px margin from checkbox to label. The label by default would have
        // another 4px margin for a total of 8px margin between checkbox and label. We don't combine the two
        // (and move it into the text) to not incur a breaking change for everyone using custom render atm.
        {
          marginRight: 4
        }
      ) : {
        marginLeft: 4
      },
      !disabled && !indeterminate && checked && (_p = {
        background: checkboxBackgroundChecked,
        borderColor: checkboxBorderColorChecked
      }, _p[HighContrastSelector] = {
        background: "Highlight",
        borderColor: "Highlight"
      }, _p),
      disabled && (_q = {
        borderColor: checkboxBorderColorDisabled
      }, _q[HighContrastSelector] = {
        borderColor: "GrayText"
      }, _q),
      checked && disabled && (_r = {
        background: checkboxBackgroundDisabledChecked,
        borderColor: checkboxBorderColorDisabled
      }, _r[HighContrastSelector] = {
        background: "Window"
      }, _r)
    ],
    checkmark: [
      classNames2.checkmark,
      (_s = {
        opacity: checked && !indeterminate ? "1" : "0",
        color: checkmarkFontColor
      }, _s[HighContrastSelector] = __assign({ color: disabled ? "GrayText" : "Window" }, getHighContrastNoAdjustStyle()), _s)
    ],
    text: [
      classNames2.text,
      (_t = {
        color: disabled ? checkboxTextColorDisabled : checkboxTextColor,
        fontSize: fonts.medium.fontSize,
        lineHeight: "20px"
      }, _t[HighContrastSelector] = __assign({ color: disabled ? "GrayText" : "WindowText" }, getHighContrastNoAdjustStyle()), _t),
      !reversed ? {
        marginLeft: 4
      } : {
        marginRight: 4
      }
    ]
  };
};

// node_modules/@fluentui/react/lib/components/Checkbox/Checkbox.js
var Checkbox = styled(CheckboxBase, getStyles19, void 0, { scope: "Checkbox" });

// node_modules/@fluentui/react/lib/components/Dropdown/Dropdown.base.js
var COMPONENT_NAME6 = "Dropdown";
var getClassNames12 = classNamesFunction();
var DEFAULT_PROPS4 = {
  options: []
};
function useSelectedItemsState(_a7) {
  var defaultSelectedKeys = _a7.defaultSelectedKeys, selectedKeys = _a7.selectedKeys, defaultSelectedKey = _a7.defaultSelectedKey, selectedKey = _a7.selectedKey, options = _a7.options, multiSelect = _a7.multiSelect;
  var oldOptions = usePrevious(options);
  var _b3 = React73.useState([]), selectedIndices = _b3[0], setSelectedIndices = _b3[1];
  var selectedKeyPropToUse;
  var didOptionsChange = options !== oldOptions;
  if (multiSelect) {
    if (didOptionsChange && defaultSelectedKeys !== void 0) {
      selectedKeyPropToUse = defaultSelectedKeys;
    } else {
      selectedKeyPropToUse = selectedKeys;
    }
  } else {
    if (didOptionsChange && defaultSelectedKey !== void 0) {
      selectedKeyPropToUse = defaultSelectedKey;
    } else {
      selectedKeyPropToUse = selectedKey;
    }
  }
  var oldSelectedKeyProp = usePrevious(selectedKeyPropToUse);
  React73.useEffect(function() {
    var getSelectedIndexes = function() {
      if (selectedKeyPropToUse === void 0) {
        if (multiSelect) {
          return getAllSelectedIndices();
        }
        var selectedIndex = getSelectedIndex(null);
        return selectedIndex !== -1 ? [selectedIndex] : [];
      } else if (!Array.isArray(selectedKeyPropToUse)) {
        var selectedIndex = getSelectedIndex(selectedKeyPropToUse);
        return selectedIndex !== -1 ? [selectedIndex] : [];
      }
      var returnValue = [];
      for (var _i = 0, selectedKeyPropToUse_1 = selectedKeyPropToUse; _i < selectedKeyPropToUse_1.length; _i++) {
        var key = selectedKeyPropToUse_1[_i];
        var selectedIndex = getSelectedIndex(key);
        selectedIndex !== -1 && returnValue.push(selectedIndex);
      }
      return returnValue;
    };
    var getAllSelectedIndices = function() {
      return options.map(function(option, index) {
        return option.selected ? index : -1;
      }).filter(function(index) {
        return index !== -1;
      });
    };
    var getSelectedIndex = function(searchKey) {
      return findIndex(options, function(option) {
        if (searchKey != null) {
          return option.key === searchKey;
        } else {
          return !!option.selected || !!option.isSelected;
        }
      });
    };
    if ((selectedKeyPropToUse !== void 0 || !oldOptions) && (selectedKeyPropToUse !== oldSelectedKeyProp || didOptionsChange)) {
      setSelectedIndices(getSelectedIndexes());
    }
  }, [didOptionsChange, multiSelect, oldOptions, oldSelectedKeyProp, options, selectedKeyPropToUse]);
  return [selectedIndices, setSelectedIndices];
}
var DropdownBase = React73.forwardRef(function(propsWithoutDefaults, forwardedRef) {
  var props = getPropsWithDefaults(DEFAULT_PROPS4, propsWithoutDefaults);
  var rootRef = React73.useRef(null);
  var mergedRootRef = useMergedRefs(forwardedRef, rootRef);
  var responsiveMode = useResponsiveMode(rootRef, props.responsiveMode);
  var _a7 = useSelectedItemsState(props), selectedIndices = _a7[0], setSelectedIndices = _a7[1];
  return React73.createElement(DropdownInternal, __assign({}, props, { responsiveMode, hoisted: { rootRef: mergedRootRef, selectedIndices, setSelectedIndices } }));
});
DropdownBase.displayName = "DropdownBase";
var DropdownInternal = (
  /** @class */
  function(_super) {
    __extends(DropdownInternal2, _super);
    function DropdownInternal2(props) {
      var _this = _super.call(this, props) || this;
      _this._host = React73.createRef();
      _this._focusZone = React73.createRef();
      _this._dropDown = React73.createRef();
      _this._scrollIdleDelay = 250;
      _this._sizePosCache = new DropdownSizePosCache();
      _this._requestAnimationFrame = safeRequestAnimationFrame(_this);
      _this.dismissMenu = function() {
        var isOpen = _this.state.isOpen;
        isOpen && _this.setState({ isOpen: false });
      };
      _this._onChange = function(event, options2, index, checked, multiSelect2) {
        var _a7 = _this.props, onChange = _a7.onChange, onChanged = _a7.onChanged;
        if (onChange || onChanged) {
          var changedOpt = multiSelect2 ? __assign(__assign({}, options2[index]), { selected: !checked }) : options2[index];
          onChange && onChange(__assign(__assign({}, event), { target: _this._dropDown.current }), changedOpt, index);
          onChanged && onChanged(changedOpt, index);
        }
      };
      _this._getPlaceholder = function() {
        return _this.props.placeholder || _this.props.placeHolder;
      };
      _this._getTitle = function(items, _unused) {
        var _a7 = _this.props.multiSelectDelimiter, multiSelectDelimiter = _a7 === void 0 ? ", " : _a7;
        return items.map(function(i) {
          return i.text;
        }).join(multiSelectDelimiter);
      };
      _this._onRenderTitle = function(items) {
        return React73.createElement(React73.Fragment, null, _this._getTitle(items));
      };
      _this._onRenderPlaceholder = function(props2) {
        if (!_this._getPlaceholder()) {
          return null;
        }
        return React73.createElement(React73.Fragment, null, _this._getPlaceholder());
      };
      _this._onRenderContainer = function(props2) {
        var calloutProps = props2.calloutProps, panelProps = props2.panelProps;
        var _a7 = _this.props, responsiveMode = _a7.responsiveMode, dropdownWidth = _a7.dropdownWidth;
        var isSmall = responsiveMode <= ResponsiveMode.medium;
        var focusTrapZoneProps = { firstFocusableTarget: "#".concat(_this._listId, "1") };
        var panelStyles = _this._classNames.subComponentStyles ? _this._classNames.subComponentStyles.panel : void 0;
        var calloutWidth = void 0;
        var calloutMinWidth = void 0;
        if (dropdownWidth === "auto") {
          calloutMinWidth = _this._dropDown.current ? _this._dropDown.current.clientWidth : 0;
        } else {
          calloutWidth = dropdownWidth || (_this._dropDown.current ? _this._dropDown.current.clientWidth : 0);
        }
        return isSmall ? React73.createElement(Panel, __assign({ closeButtonAriaLabel: "Close", focusTrapZoneProps, hasCloseButton: true, isOpen: true, isLightDismiss: true, onDismiss: _this._onDismiss, styles: panelStyles }, panelProps), _this._renderFocusableList(props2)) : React73.createElement(Callout, __assign({ isBeakVisible: false, gapSpace: 0, doNotLayer: false, directionalHintFixed: false, directionalHint: DirectionalHint.bottomLeftEdge, calloutWidth, calloutMinWidth }, calloutProps, { className: _this._classNames.callout, target: _this._dropDown.current, onDismiss: _this._onDismiss, onScroll: _this._onScroll, onPositioned: _this._onPositioned }), _this._renderFocusableList(props2));
      };
      _this._onRenderCaretDown = function(props2) {
        return React73.createElement(Icon, { className: _this._classNames.caretDown, iconName: "ChevronDown", "aria-hidden": true });
      };
      _this._onRenderList = function(props2) {
        var _a7 = props2.onRenderItem, onRenderItem = _a7 === void 0 ? _this._onRenderItem : _a7;
        var queue = { items: [] };
        var renderedList = [];
        var emptyQueue = function() {
          var newGroup = queue.id ? [
            React73.createElement("div", { role: "group", key: queue.id, "aria-labelledby": queue.id }, queue.items)
          ] : queue.items;
          renderedList = __spreadArray(__spreadArray([], renderedList, true), newGroup, true);
          queue = { items: [] };
        };
        var placeRenderedOptionIntoQueue = function(item, index) {
          switch (item.itemType) {
            case SelectableOptionMenuItemType.Header:
              queue.items.length > 0 && emptyQueue();
              var id = _this._id + item.key;
              queue.items.push(onRenderItem(__assign(__assign({ id }, item), { index }), _this._onRenderItem));
              queue.id = id;
              break;
            case SelectableOptionMenuItemType.Divider:
              index > 0 && queue.items.push(onRenderItem(__assign(__assign({}, item), { index }), _this._onRenderItem));
              queue.items.length > 0 && emptyQueue();
              break;
            default:
              queue.items.push(onRenderItem(__assign(__assign({}, item), { index }), _this._onRenderItem));
          }
        };
        props2.options.forEach(function(item, index) {
          placeRenderedOptionIntoQueue(item, index);
        });
        queue.items.length > 0 && emptyQueue();
        return React73.createElement(React73.Fragment, null, renderedList);
      };
      _this._onRenderItem = function(item) {
        switch (item.itemType) {
          case SelectableOptionMenuItemType.Divider:
            return _this._renderSeparator(item);
          case SelectableOptionMenuItemType.Header:
            return _this._renderHeader(item);
          default:
            return _this._renderOption(item);
        }
      };
      _this._renderOption = function(item) {
        var _a7;
        var _b3 = _this.props, _c3 = _b3.onRenderOption, onRenderOption = _c3 === void 0 ? _this._onRenderOption : _c3, _d3 = _b3.hoisted.selectedIndices, selectedIndices = _d3 === void 0 ? [] : _d3;
        var isItemSelected = item.index !== void 0 && selectedIndices ? selectedIndices.indexOf(item.index) > -1 : false;
        var itemClassName = item.hidden ? _this._classNames.dropdownItemHidden : isItemSelected && item.disabled === true ? _this._classNames.dropdownItemSelectedAndDisabled : isItemSelected ? _this._classNames.dropdownItemSelected : item.disabled === true ? _this._classNames.dropdownItemDisabled : _this._classNames.dropdownItem;
        var title = item.title;
        var id = _this._listId + item.index;
        var labelId = (_a7 = item.id) !== null && _a7 !== void 0 ? _a7 : id + "-label";
        var multiSelectItemStyles = _this._classNames.subComponentStyles ? _this._classNames.subComponentStyles.multiSelectItem : void 0;
        return !_this.props.multiSelect ? React73.createElement(CommandButton, {
          id,
          key: item.key,
          "data-index": item.index,
          "data-is-focusable": !item.disabled,
          disabled: item.disabled,
          className: itemClassName,
          onClick: _this._onItemClick(item),
          // eslint-disable-next-line react/jsx-no-bind
          onMouseEnter: _this._onItemMouseEnter.bind(_this, item),
          // eslint-disable-next-line react/jsx-no-bind
          onMouseLeave: _this._onMouseItemLeave.bind(_this, item),
          // eslint-disable-next-line react/jsx-no-bind
          onMouseMove: _this._onItemMouseMove.bind(_this, item),
          role: "option",
          "aria-selected": isItemSelected ? "true" : "false",
          ariaLabel: item.ariaLabel,
          title,
          "aria-posinset": _this._sizePosCache.positionInSet(item.index),
          "aria-setsize": _this._sizePosCache.optionSetSize
        }, onRenderOption(item, _this._onRenderOption)) : React73.createElement(Checkbox, {
          id,
          key: item.key,
          disabled: item.disabled,
          onChange: _this._onItemClick(item),
          inputProps: __assign({ "aria-selected": isItemSelected, onMouseEnter: _this._onItemMouseEnter.bind(_this, item), onMouseLeave: _this._onMouseItemLeave.bind(_this, item), onMouseMove: _this._onItemMouseMove.bind(_this, item), role: "option" }, {
            "data-index": item.index,
            "data-is-focusable": !(item.disabled || item.hidden)
          }),
          label: item.text,
          title,
          // eslint-disable-next-line react/jsx-no-bind
          onRenderLabel: _this._onRenderItemLabel.bind(_this, __assign(__assign({}, item), { id: labelId })),
          className: css(itemClassName, "is-multi-select"),
          checked: isItemSelected,
          styles: multiSelectItemStyles,
          ariaPositionInSet: !item.hidden ? _this._sizePosCache.positionInSet(item.index) : void 0,
          ariaSetSize: !item.hidden ? _this._sizePosCache.optionSetSize : void 0,
          ariaLabel: item.ariaLabel,
          ariaLabelledBy: item.ariaLabel ? void 0 : labelId
        });
      };
      _this._onRenderOption = function(item) {
        return React73.createElement("span", { className: _this._classNames.dropdownOptionText }, item.text);
      };
      _this._onRenderMultiselectOption = function(item) {
        return React73.createElement("span", { id: item.id, "aria-hidden": "true", className: _this._classNames.dropdownOptionText }, item.text);
      };
      _this._onRenderItemLabel = function(item) {
        var _a7 = _this.props.onRenderOption, onRenderOption = _a7 === void 0 ? _this._onRenderMultiselectOption : _a7;
        return onRenderOption(item, _this._onRenderMultiselectOption);
      };
      _this._onPositioned = function(positions) {
        if (_this._focusZone.current) {
          _this._requestAnimationFrame(function() {
            var selectedIndices = _this.props.hoisted.selectedIndices;
            if (_this._focusZone.current) {
              if (!_this._hasBeenPositioned && selectedIndices && selectedIndices[0] && !_this.props.options[selectedIndices[0]].disabled) {
                var element = getDocument().getElementById("".concat(_this._id, "-list").concat(selectedIndices[0]));
                if (element) {
                  _this._focusZone.current.focusElement(element);
                }
                _this._hasBeenPositioned = true;
              } else {
                _this._focusZone.current.focus();
              }
            }
          });
        }
        if (!_this.state.calloutRenderEdge || _this.state.calloutRenderEdge !== positions.targetEdge) {
          _this.setState({
            calloutRenderEdge: positions.targetEdge
          });
        }
      };
      _this._onItemClick = function(item) {
        return function(event) {
          if (!item.disabled) {
            _this.setSelectedIndex(event, item.index);
            if (!_this.props.multiSelect) {
              _this.setState({
                isOpen: false
              });
            }
          }
        };
      };
      _this._onScroll = function() {
        var win = getWindowEx(_this.context);
        if (!_this._isScrollIdle && _this._scrollIdleTimeoutId !== void 0) {
          win.clearTimeout(_this._scrollIdleTimeoutId);
          _this._scrollIdleTimeoutId = void 0;
        } else {
          _this._isScrollIdle = false;
        }
        _this._scrollIdleTimeoutId = win.setTimeout(function() {
          _this._isScrollIdle = true;
        }, _this._scrollIdleDelay);
      };
      _this._onMouseItemLeave = function(item, ev) {
        if (_this._shouldIgnoreMouseEvent()) {
          return;
        }
        if (_this._host.current) {
          if (_this._host.current.setActive) {
            try {
              _this._host.current.setActive();
            } catch (e) {
            }
          } else {
            _this._host.current.focus();
          }
        }
      };
      _this._onDismiss = function() {
        _this.setState({ isOpen: false });
      };
      _this._onDropdownBlur = function(ev) {
        var disabled = _this._isDisabled();
        if (disabled) {
          return;
        }
        if (_this.state.isOpen) {
          return;
        }
        _this.setState({ hasFocus: false });
        if (_this.props.onBlur) {
          _this.props.onBlur(ev);
        }
      };
      _this._onDropdownKeyDown = function(ev) {
        var disabled = _this._isDisabled();
        if (disabled) {
          return;
        }
        _this._lastKeyDownWasAltOrMeta = _this._isAltOrMeta(ev);
        if (_this.props.onKeyDown) {
          _this.props.onKeyDown(ev);
          if (ev.defaultPrevented) {
            return;
          }
        }
        var newIndex;
        var selectedIndex = _this.props.hoisted.selectedIndices.length ? _this.props.hoisted.selectedIndices[0] : -1;
        var containsExpandCollapseModifier = ev.altKey || ev.metaKey;
        var isOpen = _this.state.isOpen;
        switch (ev.which) {
          case KeyCodes.enter:
            _this.setState({
              isOpen: !isOpen
            });
            break;
          case KeyCodes.escape:
            if (!isOpen) {
              return;
            }
            _this.setState({
              isOpen: false
            });
            break;
          case KeyCodes.up:
            if (containsExpandCollapseModifier) {
              if (isOpen) {
                _this.setState({ isOpen: false });
                break;
              }
              return;
            }
            if (_this.props.multiSelect) {
              _this.setState({ isOpen: true });
            } else if (!_this._isDisabled()) {
              newIndex = _this._moveIndex(ev, -1, selectedIndex - 1, selectedIndex);
            }
            break;
          case KeyCodes.down:
            if (containsExpandCollapseModifier) {
              ev.stopPropagation();
              ev.preventDefault();
            }
            if (containsExpandCollapseModifier && !isOpen || _this.props.multiSelect) {
              _this.setState({ isOpen: true });
            } else if (!_this._isDisabled()) {
              newIndex = _this._moveIndex(ev, 1, selectedIndex + 1, selectedIndex);
            }
            break;
          case KeyCodes.home:
            if (!_this.props.multiSelect) {
              newIndex = _this._moveIndex(ev, 1, 0, selectedIndex);
            }
            break;
          case KeyCodes.end:
            if (!_this.props.multiSelect) {
              newIndex = _this._moveIndex(ev, -1, _this.props.options.length - 1, selectedIndex);
            }
            break;
          case KeyCodes.space:
            break;
          default:
            return;
        }
        if (newIndex !== selectedIndex) {
          ev.stopPropagation();
          ev.preventDefault();
        }
      };
      _this._onDropdownKeyUp = function(ev) {
        var disabled = _this._isDisabled();
        if (disabled) {
          return;
        }
        var shouldHandleKey = _this._shouldHandleKeyUp(ev);
        var isOpen = _this.state.isOpen;
        if (_this.props.onKeyUp) {
          _this.props.onKeyUp(ev);
          if (ev.defaultPrevented) {
            return;
          }
        }
        switch (ev.which) {
          case KeyCodes.space:
            _this.setState({
              isOpen: !isOpen
            });
            break;
          default:
            if (shouldHandleKey && isOpen) {
              _this.setState({ isOpen: false });
            }
            return;
        }
        ev.stopPropagation();
        ev.preventDefault();
      };
      _this._onZoneKeyDown = function(ev) {
        var _a7, _b3;
        var elementToFocus;
        _this._lastKeyDownWasAltOrMeta = _this._isAltOrMeta(ev);
        var containsExpandCollapseModifier = ev.altKey || ev.metaKey;
        switch (ev.which) {
          case KeyCodes.up:
            if (containsExpandCollapseModifier) {
              _this.setState({ isOpen: false });
            } else {
              if (_this._host.current) {
                elementToFocus = getLastFocusable(_this._host.current, _this._host.current.lastChild, true);
              }
            }
            break;
          case KeyCodes.home:
          case KeyCodes.end:
          case KeyCodes.pageUp:
          case KeyCodes.pageDown:
            break;
          case KeyCodes.down:
            if (!containsExpandCollapseModifier && _this._host.current) {
              elementToFocus = getFirstFocusable(_this._host.current, _this._host.current.firstChild, true);
            }
            break;
          case KeyCodes.escape:
            _this.setState({ isOpen: false });
            break;
          case KeyCodes.tab:
            _this.setState({ isOpen: false });
            var document_1 = getDocument();
            if (document_1) {
              if (ev.shiftKey) {
                (_a7 = getPreviousElement(document_1.body, _this._dropDown.current, false, false, true, true)) === null || _a7 === void 0 ? void 0 : _a7.focus();
              } else {
                (_b3 = getNextElement(document_1.body, _this._dropDown.current, false, false, true, true)) === null || _b3 === void 0 ? void 0 : _b3.focus();
              }
            }
            break;
          default:
            return;
        }
        if (elementToFocus) {
          elementToFocus.focus();
        }
        ev.stopPropagation();
        ev.preventDefault();
      };
      _this._onZoneKeyUp = function(ev) {
        var shouldHandleKey = _this._shouldHandleKeyUp(ev);
        if (shouldHandleKey && _this.state.isOpen) {
          _this.setState({ isOpen: false });
          ev.preventDefault();
        }
      };
      _this._onDropdownClick = function(ev) {
        if (_this.props.onClick) {
          _this.props.onClick(ev);
          if (ev.defaultPrevented) {
            return;
          }
        }
        var isOpen = _this.state.isOpen;
        var disabled = _this._isDisabled();
        if (!disabled && !_this._shouldOpenOnFocus()) {
          _this.setState({
            isOpen: !isOpen
          });
        }
        _this._isFocusedByClick = false;
      };
      _this._onDropdownMouseDown = function() {
        _this._isFocusedByClick = true;
      };
      _this._onFocus = function(ev) {
        var disabled = _this._isDisabled();
        if (!disabled) {
          if (_this.props.onFocus) {
            _this.props.onFocus(ev);
          }
          var state = { hasFocus: true };
          if (_this._shouldOpenOnFocus()) {
            state.isOpen = true;
          }
          _this.setState(state);
        }
      };
      _this._isDisabled = function() {
        var disabled = _this.props.disabled;
        var isDisabled = _this.props.isDisabled;
        if (disabled === void 0) {
          disabled = isDisabled;
        }
        return disabled;
      };
      _this._onRenderLabel = function(props2) {
        var label = props2.label, required = props2.required, disabled = props2.disabled;
        var labelStyles = _this._classNames.subComponentStyles ? _this._classNames.subComponentStyles.label : void 0;
        return label ? React73.createElement(Label, { className: _this._classNames.label, id: _this._labelId, required, styles: labelStyles, disabled }, label) : null;
      };
      initializeComponentRef(_this);
      var multiSelect = props.multiSelect, selectedKey = props.selectedKey, selectedKeys = props.selectedKeys, defaultSelectedKey = props.defaultSelectedKey, defaultSelectedKeys = props.defaultSelectedKeys, options = props.options;
      if (true) {
        warnDeprecations(COMPONENT_NAME6, props, {
          isDisabled: "disabled",
          onChanged: "onChange",
          placeHolder: "placeholder",
          onRenderPlaceHolder: "onRenderPlaceholder"
        });
        warnMutuallyExclusive(COMPONENT_NAME6, props, {
          defaultSelectedKey: "selectedKey",
          defaultSelectedKeys: "selectedKeys",
          selectedKeys: "selectedKey"
        });
        if (multiSelect) {
          var warnMultiSelect = function(prop) {
            return warn("Dropdown property '".concat(prop, "' cannot be used when 'multiSelect' is true. Use '").concat(prop, "s' instead."));
          };
          if (selectedKey !== void 0) {
            warnMultiSelect("selectedKey");
          }
          if (defaultSelectedKey !== void 0) {
            warnMultiSelect("defaultSelectedKey");
          }
        } else {
          var warnNotMultiSelect = function(prop) {
            return warn("Dropdown property '".concat(prop, "s' cannot be used when 'multiSelect' is false/unset. Use '").concat(prop, "' instead."));
          };
          if (selectedKeys !== void 0) {
            warnNotMultiSelect("selectedKey");
          }
          if (defaultSelectedKeys !== void 0) {
            warnNotMultiSelect("defaultSelectedKey");
          }
        }
      }
      _this._id = props.id || getId("Dropdown");
      _this._labelId = _this._id + "-label";
      _this._listId = _this._id + "-list";
      _this._optionId = _this._id + "-option";
      _this._isScrollIdle = true;
      _this._hasBeenPositioned = false;
      _this._sizePosCache.updateOptions(options);
      _this.state = {
        isOpen: false,
        hasFocus: false,
        calloutRenderEdge: void 0
      };
      return _this;
    }
    Object.defineProperty(DropdownInternal2.prototype, "selectedOptions", {
      /**
       * All selected options
       */
      get: function() {
        var _a7 = this.props, options = _a7.options, selectedIndices = _a7.hoisted.selectedIndices;
        return getAllSelectedOptions(options, selectedIndices);
      },
      enumerable: false,
      configurable: true
    });
    DropdownInternal2.prototype.componentWillUnmount = function() {
      clearTimeout(this._scrollIdleTimeoutId);
    };
    DropdownInternal2.prototype.componentDidUpdate = function(prevProps, prevState) {
      if (prevState.isOpen === true && this.state.isOpen === false) {
        this._gotMouseMove = false;
        this._hasBeenPositioned = false;
        if (this.props.onDismiss) {
          this.props.onDismiss();
        }
      }
    };
    DropdownInternal2.prototype.render = function() {
      var id = this._id;
      var props = this.props;
      var className = props.className, label = props.label, options = props.options, ariaLabel = props.ariaLabel, required = props.required, errorMessage = props.errorMessage, propStyles = props.styles, theme = props.theme, panelProps = props.panelProps, calloutProps = props.calloutProps, _a7 = props.onRenderTitle, onRenderTitle = _a7 === void 0 ? this._getTitle : _a7, _b3 = props.onRenderContainer, onRenderContainer = _b3 === void 0 ? this._onRenderContainer : _b3, _c3 = props.onRenderCaretDown, onRenderCaretDown = _c3 === void 0 ? this._onRenderCaretDown : _c3, _d3 = props.onRenderLabel, onRenderLabel = _d3 === void 0 ? this._onRenderLabel : _d3, _e2 = props.onRenderItem, onRenderItem = _e2 === void 0 ? this._onRenderItem : _e2, selectedIndices = props.hoisted.selectedIndices;
      var _f = this.state, isOpen = _f.isOpen, calloutRenderEdge = _f.calloutRenderEdge, hasFocus = _f.hasFocus;
      var onRenderPlaceholder = props.onRenderPlaceholder || props.onRenderPlaceHolder || this._getPlaceholder;
      if (options !== this._sizePosCache.cachedOptions) {
        this._sizePosCache.updateOptions(options);
      }
      var selectedOptions = getAllSelectedOptions(options, selectedIndices);
      var divProps = getNativeProps(props, divProperties);
      var disabled = this._isDisabled();
      var errorMessageId = id + "-errorMessage";
      this._classNames = getClassNames12(propStyles, {
        theme,
        className,
        hasError: !!(errorMessage && errorMessage.length > 0),
        hasLabel: !!label,
        isOpen,
        required,
        disabled,
        isRenderingPlaceholder: !selectedOptions.length,
        panelClassName: panelProps ? panelProps.className : void 0,
        calloutClassName: calloutProps ? calloutProps.className : void 0,
        calloutRenderEdge
      });
      var hasErrorMessage = !!errorMessage && errorMessage.length > 0;
      return React73.createElement(
        "div",
        { className: this._classNames.root, ref: this.props.hoisted.rootRef, "aria-owns": isOpen ? this._listId : void 0 },
        onRenderLabel(this.props, this._onRenderLabel),
        React73.createElement(
          "div",
          __assign({ "data-is-focusable": !disabled, "data-ktp-target": true, ref: this._dropDown, id, tabIndex: disabled ? -1 : 0, role: "combobox", "aria-haspopup": "listbox", "aria-expanded": isOpen ? "true" : "false", "aria-label": ariaLabel, "aria-labelledby": label && !ariaLabel ? mergeAriaAttributeValues(this._labelId, this._optionId) : void 0, "aria-describedby": hasErrorMessage ? this._id + "-errorMessage" : void 0, "aria-required": required, "aria-disabled": disabled, "aria-controls": isOpen ? this._listId : void 0 }, divProps, { className: this._classNames.dropdown, onBlur: this._onDropdownBlur, onKeyDown: this._onDropdownKeyDown, onKeyUp: this._onDropdownKeyUp, onClick: this._onDropdownClick, onMouseDown: this._onDropdownMouseDown, onFocus: this._onFocus }),
          React73.createElement(
            "span",
            { id: this._optionId, className: this._classNames.title, "aria-live": hasFocus ? "polite" : void 0, "aria-atomic": hasFocus ? true : void 0, "aria-invalid": hasErrorMessage },
            // If option is selected render title, otherwise render the placeholder text
            selectedOptions.length ? onRenderTitle(selectedOptions, this._onRenderTitle) : onRenderPlaceholder(props, this._onRenderPlaceholder)
          ),
          React73.createElement("span", { className: this._classNames.caretDownWrapper }, onRenderCaretDown(props, this._onRenderCaretDown))
        ),
        isOpen && onRenderContainer(__assign(__assign({}, props), { onDismiss: this._onDismiss, onRenderItem }), this._onRenderContainer),
        hasErrorMessage && React73.createElement("div", { role: "alert", id: errorMessageId, className: this._classNames.errorMessage }, errorMessage)
      );
    };
    DropdownInternal2.prototype.focus = function(shouldOpenOnFocus) {
      if (this._dropDown.current) {
        this._dropDown.current.focus();
        if (shouldOpenOnFocus) {
          this.setState({
            isOpen: true
          });
        }
      }
    };
    DropdownInternal2.prototype.setSelectedIndex = function(event, index) {
      var _a7 = this.props, options = _a7.options, selectedKey = _a7.selectedKey, selectedKeys = _a7.selectedKeys, multiSelect = _a7.multiSelect, notifyOnReselect = _a7.notifyOnReselect, _b3 = _a7.hoisted.selectedIndices, selectedIndices = _b3 === void 0 ? [] : _b3;
      var checked = selectedIndices ? selectedIndices.indexOf(index) > -1 : false;
      var newIndexes = [];
      index = Math.max(0, Math.min(options.length - 1, index));
      if (selectedKey !== void 0 || selectedKeys !== void 0) {
        this._onChange(event, options, index, checked, multiSelect);
        return;
      }
      if (!multiSelect && !notifyOnReselect && index === selectedIndices[0]) {
        return;
      } else if (multiSelect) {
        newIndexes = selectedIndices ? this._copyArray(selectedIndices) : [];
        if (checked) {
          var position = newIndexes.indexOf(index);
          if (position > -1) {
            newIndexes.splice(position, 1);
          }
        } else {
          newIndexes.push(index);
        }
      } else {
        newIndexes = [index];
      }
      event.persist();
      this.props.hoisted.setSelectedIndices(newIndexes);
      this._onChange(event, options, index, checked, multiSelect);
    };
    DropdownInternal2.prototype._copyArray = function(array) {
      var newArray = [];
      for (var _i = 0, array_1 = array; _i < array_1.length; _i++) {
        var element = array_1[_i];
        newArray.push(element);
      }
      return newArray;
    };
    DropdownInternal2.prototype._moveIndex = function(event, stepValue, index, selectedIndex) {
      var options = this.props.options;
      if (selectedIndex === index || options.length === 0) {
        return selectedIndex;
      }
      if (index >= options.length) {
        index = 0;
      } else if (index < 0) {
        index = options.length - 1;
      }
      var stepCounter = 0;
      while (options[index].itemType === SelectableOptionMenuItemType.Header || options[index].itemType === SelectableOptionMenuItemType.Divider || options[index].disabled) {
        if (stepCounter >= options.length) {
          return selectedIndex;
        }
        if (index + stepValue < 0) {
          index = options.length;
        } else if (index + stepValue >= options.length) {
          index = -1;
        }
        index = index + stepValue;
        stepCounter++;
      }
      this.setSelectedIndex(event, index);
      return index;
    };
    DropdownInternal2.prototype._renderFocusableList = function(props) {
      var _a7 = props.onRenderList, onRenderList = _a7 === void 0 ? this._onRenderList : _a7, label = props.label, ariaLabel = props.ariaLabel, multiSelect = props.multiSelect;
      return React73.createElement(
        "div",
        { className: this._classNames.dropdownItemsWrapper, onKeyDown: this._onZoneKeyDown, onKeyUp: this._onZoneKeyUp, ref: this._host, tabIndex: 0 },
        React73.createElement(FocusZone, { ref: this._focusZone, direction: FocusZoneDirection.vertical, id: this._listId, className: this._classNames.dropdownItems, role: "listbox", "aria-label": ariaLabel, "aria-labelledby": label && !ariaLabel ? this._labelId : void 0, "aria-multiselectable": multiSelect }, onRenderList(props, this._onRenderList))
      );
    };
    DropdownInternal2.prototype._renderSeparator = function(item) {
      var index = item.index, key = item.key;
      var separatorClassName = item.hidden ? this._classNames.dropdownDividerHidden : this._classNames.dropdownDivider;
      if (index > 0) {
        return React73.createElement("div", { role: "presentation", key, className: separatorClassName });
      }
      return null;
    };
    DropdownInternal2.prototype._renderHeader = function(item) {
      var _a7 = this.props.onRenderOption, onRenderOption = _a7 === void 0 ? this._onRenderOption : _a7;
      var key = item.key, id = item.id;
      var headerClassName = item.hidden ? this._classNames.dropdownItemHeaderHidden : this._classNames.dropdownItemHeader;
      return React73.createElement("div", { id, key, className: headerClassName }, onRenderOption(item, this._onRenderOption));
    };
    DropdownInternal2.prototype._onItemMouseEnter = function(item, ev) {
      if (this._shouldIgnoreMouseEvent()) {
        return;
      }
      var targetElement = ev.currentTarget;
      targetElement.focus();
    };
    DropdownInternal2.prototype._onItemMouseMove = function(item, ev) {
      var doc = getDocumentEx(this.context);
      var targetElement = ev.currentTarget;
      this._gotMouseMove = true;
      if (!this._isScrollIdle || doc.activeElement === targetElement) {
        return;
      }
      targetElement.focus();
    };
    DropdownInternal2.prototype._shouldIgnoreMouseEvent = function() {
      return !this._isScrollIdle || !this._gotMouseMove;
    };
    DropdownInternal2.prototype._isAltOrMeta = function(ev) {
      return ev.which === KeyCodes.alt || ev.key === "Meta";
    };
    DropdownInternal2.prototype._shouldHandleKeyUp = function(ev) {
      var keyPressIsAltOrMetaAlone = this._lastKeyDownWasAltOrMeta && this._isAltOrMeta(ev);
      this._lastKeyDownWasAltOrMeta = false;
      return !!keyPressIsAltOrMetaAlone && !(isMac() || isIOS());
    };
    DropdownInternal2.prototype._shouldOpenOnFocus = function() {
      var hasFocus = this.state.hasFocus;
      var openOnKeyboardFocus = this.props.openOnKeyboardFocus;
      return !this._isFocusedByClick && openOnKeyboardFocus === true && !hasFocus;
    };
    DropdownInternal2.defaultProps = {
      options: []
    };
    DropdownInternal2.contextType = WindowContext;
    return DropdownInternal2;
  }(React73.Component)
);

// node_modules/@fluentui/react/lib/components/Dropdown/Dropdown.styles.js
var _a6;
var _b2;
var _c2;
var _d2;
var GlobalClassNames10 = {
  root: "ms-Dropdown-container",
  label: "ms-Dropdown-label",
  dropdown: "ms-Dropdown",
  title: "ms-Dropdown-title",
  caretDownWrapper: "ms-Dropdown-caretDownWrapper",
  caretDown: "ms-Dropdown-caretDown",
  callout: "ms-Dropdown-callout",
  panel: "ms-Dropdown-panel",
  dropdownItems: "ms-Dropdown-items",
  dropdownItem: "ms-Dropdown-item",
  dropdownDivider: "ms-Dropdown-divider",
  dropdownOptionText: "ms-Dropdown-optionText",
  dropdownItemHeader: "ms-Dropdown-header",
  titleIsPlaceHolder: "ms-Dropdown-titleIsPlaceHolder",
  titleHasError: "ms-Dropdown-title--hasError"
};
var DROPDOWN_HEIGHT = 32;
var DROPDOWN_ITEM_HEIGHT = 36;
var highContrastAdjustMixin = (_a6 = {}, _a6["".concat(HighContrastSelector, ", ").concat(HighContrastSelectorWhite.replace("@media ", ""))] = __assign({}, getHighContrastNoAdjustStyle()), _a6);
var highContrastItemAndTitleStateMixin = {
  selectors: __assign((_b2 = {}, _b2[HighContrastSelector] = {
    backgroundColor: "Highlight",
    borderColor: "Highlight",
    color: "HighlightText"
  }, _b2[".ms-Checkbox-checkbox"] = (_c2 = {}, _c2[HighContrastSelector] = {
    borderColor: "HighlightText"
  }, _c2), _b2), highContrastAdjustMixin)
};
var highContrastBorderState = {
  selectors: (_d2 = {}, _d2[HighContrastSelector] = {
    borderColor: "Highlight"
  }, _d2)
};
var MinimumScreenSelector = getScreenSelector(0, ScreenWidthMinMedium);
var getStyles20 = function(props) {
  var _a7, _b3, _c3, _d3, _e2, _f, _g, _h, _j, _k, _l, _m;
  var theme = props.theme, hasError = props.hasError, hasLabel = props.hasLabel, className = props.className, isOpen = props.isOpen, disabled = props.disabled, required = props.required, isRenderingPlaceholder = props.isRenderingPlaceholder, panelClassName = props.panelClassName, calloutClassName = props.calloutClassName, calloutRenderEdge = props.calloutRenderEdge;
  if (!theme) {
    throw new Error("theme is undefined or null in base Dropdown getStyles function.");
  }
  var globalClassnames = getGlobalClassNames(GlobalClassNames10, theme);
  var palette = theme.palette, semanticColors = theme.semanticColors, effects = theme.effects, fonts = theme.fonts;
  var rootHoverFocusActiveSelectorNeutralDarkMixin = {
    color: semanticColors.menuItemTextHovered
  };
  var rootHoverFocusActiveSelectorNeutralPrimaryMixin = {
    color: semanticColors.menuItemText
  };
  var borderColorError = {
    borderColor: semanticColors.errorText
  };
  var dropdownItemStyle = [
    globalClassnames.dropdownItem,
    {
      backgroundColor: "transparent",
      boxSizing: "border-box",
      cursor: "pointer",
      display: "flex",
      alignItems: "center",
      padding: "0 8px",
      width: "100%",
      minHeight: DROPDOWN_ITEM_HEIGHT,
      lineHeight: 20,
      height: 0,
      position: "relative",
      border: "1px solid transparent",
      borderRadius: 0,
      wordWrap: "break-word",
      overflowWrap: "break-word",
      textAlign: "left",
      ".ms-Button-flexContainer": {
        width: "100%"
      }
    }
  ];
  var dropdownHeaderStyle = [
    globalClassnames.dropdownItemHeader,
    __assign(__assign({}, fonts.medium), { fontWeight: FontWeights.semibold, color: semanticColors.menuHeader, background: "none", backgroundColor: "transparent", border: "none", height: DROPDOWN_ITEM_HEIGHT, lineHeight: DROPDOWN_ITEM_HEIGHT, cursor: "default", padding: "0 8px", userSelect: "none", textAlign: "left", selectors: (_a7 = {}, _a7[HighContrastSelector] = __assign({ color: "GrayText" }, getHighContrastNoAdjustStyle()), _a7) })
  ];
  var selectedItemBackgroundColor = semanticColors.menuItemBackgroundPressed;
  var itemSelectors = function(isSelected) {
    var _a8, _b4;
    if (isSelected === void 0) {
      isSelected = false;
    }
    return {
      selectors: (_a8 = {
        "&:hover": [
          {
            color: semanticColors.menuItemTextHovered,
            backgroundColor: !isSelected ? semanticColors.menuItemBackgroundHovered : selectedItemBackgroundColor
          },
          highContrastItemAndTitleStateMixin
        ],
        "&.is-multi-select:hover": [
          { backgroundColor: !isSelected ? "transparent" : selectedItemBackgroundColor },
          highContrastItemAndTitleStateMixin
        ],
        "&:active:hover": [
          {
            color: semanticColors.menuItemTextHovered,
            backgroundColor: !isSelected ? semanticColors.menuItemBackgroundPressed : semanticColors.menuItemBackgroundHovered
          },
          highContrastItemAndTitleStateMixin
        ]
      }, _a8[".".concat(IsFocusVisibleClassName, " &:focus:after")] = (_b4 = {
        left: 0,
        top: 0,
        bottom: 0,
        right: 0
      }, _b4[HighContrastSelector] = {
        inset: "2px"
      }, _b4), _a8[HighContrastSelector] = {
        border: "none"
      }, _a8)
    };
  };
  var dropdownItemSelected = __spreadArray(__spreadArray([], dropdownItemStyle, true), [
    {
      backgroundColor: selectedItemBackgroundColor,
      color: semanticColors.menuItemTextHovered
    },
    itemSelectors(true),
    highContrastItemAndTitleStateMixin
  ], false);
  var dropdownItemDisabled = __spreadArray(__spreadArray([], dropdownItemStyle, true), [
    {
      color: semanticColors.disabledText,
      cursor: "default",
      selectors: (_b3 = {}, _b3[HighContrastSelector] = {
        color: "GrayText",
        border: "none"
      }, _b3)
    }
  ], false);
  var titleOpenBorderRadius = calloutRenderEdge === RectangleEdge.bottom ? "".concat(effects.roundedCorner2, " ").concat(effects.roundedCorner2, " 0 0") : "0 0 ".concat(effects.roundedCorner2, " ").concat(effects.roundedCorner2);
  var calloutOpenBorderRadius = calloutRenderEdge === RectangleEdge.bottom ? "0 0 ".concat(effects.roundedCorner2, " ").concat(effects.roundedCorner2) : "".concat(effects.roundedCorner2, " ").concat(effects.roundedCorner2, " 0 0");
  return {
    root: [globalClassnames.root, className],
    label: globalClassnames.label,
    dropdown: [
      globalClassnames.dropdown,
      normalize,
      fonts.medium,
      {
        color: semanticColors.menuItemText,
        borderColor: semanticColors.focusBorder,
        position: "relative",
        outline: 0,
        userSelect: "none",
        selectors: (_c3 = {}, _c3["&:hover ." + globalClassnames.title] = [
          !disabled && rootHoverFocusActiveSelectorNeutralDarkMixin,
          { borderColor: isOpen ? palette.neutralSecondary : palette.neutralPrimary },
          highContrastBorderState
        ], _c3["&:focus ." + globalClassnames.title] = [
          !disabled && rootHoverFocusActiveSelectorNeutralDarkMixin,
          { selectors: (_d3 = {}, _d3[HighContrastSelector] = { color: "Highlight" }, _d3) }
        ], _c3["&:focus:after"] = [
          {
            pointerEvents: "none",
            content: "''",
            position: "absolute",
            boxSizing: "border-box",
            top: "0px",
            left: "0px",
            width: "100%",
            height: "100%",
            // see https://github.com/microsoft/fluentui/pull/9182 for semantic color disc
            border: !disabled ? "2px solid ".concat(palette.themePrimary) : "none",
            borderRadius: "2px",
            selectors: (_e2 = {}, _e2[HighContrastSelector] = {
              color: "Highlight"
            }, _e2)
          }
        ], _c3["&:active ." + globalClassnames.title] = [
          !disabled && rootHoverFocusActiveSelectorNeutralDarkMixin,
          { borderColor: palette.themePrimary },
          highContrastBorderState
        ], _c3["&:hover ." + globalClassnames.caretDown] = !disabled && rootHoverFocusActiveSelectorNeutralPrimaryMixin, _c3["&:focus ." + globalClassnames.caretDown] = [
          !disabled && rootHoverFocusActiveSelectorNeutralPrimaryMixin,
          { selectors: (_f = {}, _f[HighContrastSelector] = { color: "Highlight" }, _f) }
        ], _c3["&:active ." + globalClassnames.caretDown] = !disabled && rootHoverFocusActiveSelectorNeutralPrimaryMixin, _c3["&:hover ." + globalClassnames.titleIsPlaceHolder] = !disabled && rootHoverFocusActiveSelectorNeutralPrimaryMixin, _c3["&:focus ." + globalClassnames.titleIsPlaceHolder] = !disabled && rootHoverFocusActiveSelectorNeutralPrimaryMixin, _c3["&:active ." + globalClassnames.titleIsPlaceHolder] = !disabled && rootHoverFocusActiveSelectorNeutralPrimaryMixin, _c3["&:hover ." + globalClassnames.titleHasError] = borderColorError, _c3["&:active ." + globalClassnames.titleHasError] = borderColorError, _c3)
      },
      isOpen && "is-open",
      disabled && "is-disabled",
      required && "is-required",
      required && !hasLabel && {
        selectors: (_g = {
          ":before": {
            content: "'*'",
            color: semanticColors.errorText,
            position: "absolute",
            top: -5,
            right: -10
          }
        }, _g[HighContrastSelector] = {
          selectors: {
            ":after": {
              right: -14
              // moving the * 4 pixel to right to alleviate border clipping in HC mode.
            }
          }
        }, _g)
      }
    ],
    title: [
      globalClassnames.title,
      normalize,
      {
        backgroundColor: semanticColors.inputBackground,
        borderWidth: 1,
        borderStyle: "solid",
        borderColor: semanticColors.inputBorder,
        borderRadius: isOpen ? titleOpenBorderRadius : effects.roundedCorner2,
        cursor: "pointer",
        display: "block",
        height: DROPDOWN_HEIGHT,
        lineHeight: DROPDOWN_HEIGHT - 2,
        padding: "0 28px 0 8px",
        position: "relative",
        overflow: "hidden",
        whiteSpace: "nowrap",
        textOverflow: "ellipsis"
      },
      isRenderingPlaceholder && [globalClassnames.titleIsPlaceHolder, { color: semanticColors.inputPlaceholderText }],
      hasError && [globalClassnames.titleHasError, borderColorError],
      disabled && {
        backgroundColor: semanticColors.disabledBackground,
        border: "none",
        color: semanticColors.disabledText,
        cursor: "default",
        selectors: (_h = {}, _h[HighContrastSelector] = __assign({ border: "1px solid GrayText", color: "GrayText", backgroundColor: "Window" }, getHighContrastNoAdjustStyle()), _h)
      }
    ],
    caretDownWrapper: [
      globalClassnames.caretDownWrapper,
      {
        height: DROPDOWN_HEIGHT,
        lineHeight: DROPDOWN_HEIGHT - 2,
        paddingTop: 1,
        position: "absolute",
        right: 8,
        top: 0
      },
      !disabled && {
        cursor: "pointer"
      }
    ],
    caretDown: [
      globalClassnames.caretDown,
      { color: palette.neutralSecondary, fontSize: fonts.small.fontSize, pointerEvents: "none" },
      disabled && {
        color: semanticColors.disabledText,
        selectors: (_j = {}, _j[HighContrastSelector] = __assign({ color: "GrayText" }, getHighContrastNoAdjustStyle()), _j)
      }
    ],
    errorMessage: __assign(__assign({ color: semanticColors.errorText }, theme.fonts.small), { paddingTop: 5 }),
    callout: [
      globalClassnames.callout,
      {
        boxShadow: effects.elevation8,
        borderRadius: calloutOpenBorderRadius,
        selectors: (_k = {}, _k[".ms-Callout-main"] = { borderRadius: calloutOpenBorderRadius }, _k)
      },
      calloutClassName
    ],
    dropdownItemsWrapper: { selectors: { "&:focus": { outline: 0 } } },
    dropdownItems: [globalClassnames.dropdownItems, { display: "block" }],
    dropdownItem: __spreadArray(__spreadArray([], dropdownItemStyle, true), [itemSelectors()], false),
    dropdownItemSelected,
    dropdownItemDisabled,
    dropdownItemSelectedAndDisabled: [dropdownItemSelected, dropdownItemDisabled, { backgroundColor: "transparent" }],
    dropdownItemHidden: __spreadArray(__spreadArray([], dropdownItemStyle, true), [{ display: "none" }], false),
    dropdownDivider: [globalClassnames.dropdownDivider, { height: 1, backgroundColor: semanticColors.bodyDivider }],
    dropdownDividerHidden: [globalClassnames.dropdownDivider, { display: "none" }],
    dropdownOptionText: [
      globalClassnames.dropdownOptionText,
      {
        overflow: "hidden",
        whiteSpace: "nowrap",
        textOverflow: "ellipsis",
        minWidth: 0,
        maxWidth: "100%",
        wordWrap: "break-word",
        overflowWrap: "break-word",
        margin: "1px"
      }
    ],
    dropdownItemHeader: dropdownHeaderStyle,
    dropdownItemHeaderHidden: __spreadArray(__spreadArray([], dropdownHeaderStyle, true), [{ display: "none" }], false),
    subComponentStyles: {
      label: { root: { display: "inline-block" } },
      multiSelectItem: {
        root: {
          padding: 0
        },
        label: {
          alignSelf: "stretch",
          padding: "0 8px",
          width: "100%"
        },
        input: {
          selectors: (_l = {}, _l[".".concat(IsFocusVisibleClassName, " &:focus + label::before")] = {
            outlineOffset: "0px"
          }, _l)
        }
      },
      panel: {
        root: [panelClassName],
        main: {
          selectors: (_m = {}, // In case of extra small screen sizes
          _m[MinimumScreenSelector] = {
            // panelWidth xs
            width: 272
          }, _m)
        },
        contentInner: { padding: "0 0 20px" }
      }
    }
  };
};

// node_modules/@fluentui/react/lib/components/Dropdown/Dropdown.js
var Dropdown = styled(DropdownBase, getStyles20, void 0, {
  scope: "Dropdown"
});
Dropdown.displayName = "Dropdown";
export {
  Dropdown,
  DropdownBase,
  SelectableOptionMenuItemType as DropdownMenuItemType
};
//# sourceMappingURL=@fluentui_react_lib_Dropdown.js.map
